#+TITLE: Wake Up Snorlax!
#+AUTHOR: noctuid
#+TODO: TODO(t) IN-PROGRESS(p) WAITING(w) | DONE(d) CANCELED(c)

# [[./todo.org]]

# I'm using ~org-sort-entries~ (with =a=) for sorting many subheadings.  In others, I'm grouping related subheadings.

#+begin_quote
He could code anything--but life is short, and most significant systems were terribly large.  So Pham learned to hack about with the leviathans of the past.
#+end_quote

* Initial Notes
** Org Configuration
I moved my Emacs init file to org after becoming comfortable enough with evil to use Emacs instead of vim for editing my init file. The initial reason I switched to org was to be able to use org's outline syntax instead of marker folds (={{{...}}}=). The main reasons I haven't switched back are because I prefer writing notes using org's markup and soft-wrapping over using comments and hard-wrapping. Also, org's extra features and packages like [[https://github.com/abo-abo/worf][worf]] make org very convenient and powerful, and I like being able to easily export to other formats.

That said, using an org init file has a lot of downsides as well. Input lag can be an issue for larger org files depending on the enabled minor modes, having to first open a new buffer to edit an elisp source block can be annoying, and ~org-babel-load-file~ is very slow and requires loading org mode. Also, org's outline syntax can easily be used in non-org files, so that is not a unique feature of an org configuration.

There are ways to mitigate these issues though. After disabling some minor modes (mainly =git-gutter-mode=), input lag is not an issue for me. Using ~polymode~ allows editing elisp directly in the same buffer. Previously, ~polymode~ was completely unusable for me in large files because moving the point into a code block froze Emacs for a couple of seconds. A lot of work has gone into polymode, and speed is no longer an issue (thank you @vspinu), but my polymode config still needs work. On the other hand, ~org-edit-special~ may be desirable as a form of narrowing. Finally, slow tangling can be dealt with either by tangling (asynchronously) after startup or by [[http://www.holgerschurig.de/en/emacs-efficiently-untangling-elisp/][using a custom tangling function]]. Both of these solutions don't require loading org during startup.

** Changes From Default Evil/Vim Keybindings
As great as vim's default keybindings are, they aren't tailored towards my most commonly used actions/commands, and I don't use QWERTY, so I change a lot of them. Some of these are common swaps (e.g. =;= as =:=), but a lot of these changes are more opinionated.

*** Basic Swaps/Changes
- line movement keys swapped (e.g. swapping default =j= and =gj=)
- =Y= consistent with =D= (see ~evil-want-Y-yank-to-eol~)
- =a= and =A= swapped
- =;= instead of =:=
- =:= as ~eval-expression~ (default =;= moved to =r= prefix)
- =/= as a swiper command (default =/= moved to =r= prefix)
- =RET= for following (e.g. links or jumping to definitions like =M-.= or vim's =C-]=) and for confirmation/finalization (e.g. finalizing org capture, finalizing git commit, exiting org source mode buffer, etc.)

*** Colemak Swaps/Changes
- =hnei= instead of =hjkl= (for text editing, only =ne= are used)
- default =n= and =N= to =k= and =K=
- default =K= to =N=
- default =e= to =j=
- =H= for "jump to beginning" commands (e.g. beginning of heading or function)
- =l= as =C-o= and =L= as =C-i=; =i= is kept for entering insert state

The default =J= (join) and (particularly) =K= (doc lookup) are useful in vim; so I keep their functionality. I don't use the default =H= or =L= (which swap/move windows) at all, so I remap them to more useful commands.
I find =C-o= (~evil-jump-backward~) to be a command that deserves a better position, so I rebind =l= to it (mnemonic "[l]ast") instead of using =l= for insertion, which is a common Colemak change. For symmetry, I also remove =h=, so =hi= do not perform horizontal movement. The vertical movement keybindings are useful enough for me to keep, especially when using relative line numbers. I use a modifier with =h= and =i= if I need horizontal movement (navigation layer; not part of Emacs config). In modes where insertion doesn't make sense and horizontal movement is more useful (e.g. =mu4e= and =dired=), I keep =hnei=.

Although I now use Colemak-DH (where =m= is in the QWERTY =h= position), I still use =h= as "left." This is partially because all my configuration files already used =h= before I switchedB. ecause the idea of Colemak-DH is to move =h= to a better location, I don't think any changes are necessary.

*** Hybrid Modal/Chording
I don't exclusively use modal keybindings.  I'm using more and more modifier keybindings because chords are better for one-off actions such as [[#window-managementnavigation][Window Management/Navigation]], basic buffer navigation actions like =M-f= and =M-b=, commenting single lines, pasting at the point, etc.  For example, I used to have all window management keybindings under a prefix key in normal state, but now I use only control keybindings.

*** Standard Prefixes
These are global prefixes that are sometimes bound in =general-override-mode-map= (whose evil auxiliary keymaps are evil intercept keymaps).  =m= and =,= do not need to be bound globally since they are specific to the current major mode and group respectively.  Keys like =r= that may not be useful in every major mode are not bound in an evil intercept map either.  =SPC= and =t= are the main keys that are bound in evil intercept maps, so that their functionality will always be available.

Having a lot of prefixes helps to keep the number of keypresses required for a command at around two for the most common commands.  I've remapped my least used vim letter keys as prefixes (which conveniently happen to also be home row keys for Colemak).  =s= and =r= are probably the least generic/useful default vim keys.  The default =s= and =S= are equivalent to =cl= and =cc=.  They aren't useful enough to me to deserve dedicated keys.  The same is true for =r= (~evil-replace~), and I don't use =R= (~evil-replace-state~) at all.  I use =x= occasionally (e.g. =xp= is convenient for swapping characters), so I keep it.  I never use =X=, but it's not in a good enough position for me to want to repurpose it.  On the other hand, =SPC= is generally the best position on the keyboard and doesn't have a unique keybinding either (same as =l=), so its one of my most used prefix keys.

The more "controversial" keys I rebind are =m=, =h=, =t=, and =T=.  I used ='= a lot more than =m= in vim and didn't use =m= at all until recently in Emacs (you can persist markers, but you have to use =desktop-mode= or extract the code to do it yourself).  I don't use =M= at all (~evil-window-middle~, which moves the point to the middle of the window), so I move ~evil-set-marker~ to =M= and use =m= as a prefix.  As for =t=, =T=, =f=, and =F=, I prefer to use a two-char search command that will search across lines and allow selection with avy when there is more than one match (like =vim-sneak= or =vim-easymotion= or just ~evil-avy-goto-char-2~).  I bind these commands to =f= and =F= and use =t= as a prefix key as I can just change the characters I search for if I want to go to the character before some other character.

- =SPC=: for buffer/file/group navigation/management
- =,=: for "quickmarked" files/applications for the current group
- =r=: for "[r]emote" movement and for "[r]emoved" (or "[r]emapped") keys
  - used for remote motions (motions using avy; also used for remote text objects in =evil-(inner|outer)-text-objects-map=)
  - used for preserving some clobbered keys (e.g. the default =;=, =,=, and =/= are now prefixed with =r=)
- formerly =s=, now =C-t=: for "[s]tarting" applications (mu4e, elfeed, mingus, woman, proced, calc, etc.) and for "[s]traight" commands (on =ss= currently)
  - the commands I have bound on this prefix should be available in any context, so it doesn't make sense to use =s= (which I am binding to something else in some modes like =magit-status-mode=); now =s= can always be used for something that makes sense in the current major mode
  - similarly, it doesn't really make sense to have to switch to normal state to be able to use some of these commands
  - =C-t= matches =t= as another universal prefix I guess
- =t=: previously my "leader" key in vim
  - formerly window navigation/management - now dedicated control keybindings are used for window management
  - other general-purpose/commonly used commands (e.g. ~link-hint-open-link~)
- =T=: vterm (possibly also better as a chord)
- =h=: formerly bound to ~help-command~, now ~evil-avy-goto-word-1~ (just use =C-h= for help)
- =m=: used for "[m]ajor [m]ode" specific keybindings (e.g. org commands)
- =to=: used to "[to]ggle" options and minor modes (previously I was using =co=, but I didn't want =c= to be a prefix everywhere)

Some of these make sense as normal state prefixes (e.g. =r= for more motions).  Some of them don't really (e.g. =t= is just a whole bunch of miscellaneous commands, many which are state-agnostic), but I leave them as normal state prefixes because I'm used to the keybindings and because I don't really have better keys to put them on.  I'm trying to reserve chords for the most frequently used one-off actions (especially those useful when editing in order to minimize extra transitions between normal and insert state).  I don't really care as much if some actions unrelated to editing (like file navigation) are only available in normal state since it's the "default" state anyway.

*** Why I Bind All My Own Keys
It's partially because I used a non-QWERTY keyboard layout, partially
because I have a lot of non-standard customizations (see previous heading) and like having full control, and partially because I've already done it.  When I learn a new mode (e.g. magit), I look through all the commands anyway.  Binding them doesn't take a significant amount of extra time.  It also serves as reference for what commands I found most useful.

I think using =evil-collection= is a great idea if you're new to Emacs or for anyone whose setup isn't as weird as mine.  I'm trying to use it more myself (at least for reference or as a base with my changes on top).

** Configuration Principles
My configuration may not meet these requirements at this point in time, but these are the goals.

- Speed (nice but not a primary goal)
  - Aggressively use autoloads and ~with-eval-after-load~ for configuration to cut down on startup time when it makes sense. Previously I had a lot of ~use-package~ statements with =:defer <time>=. I avoid this now unless I think it's unlikely I need to use a package immediately and there's no better way to autoload it. For packages that don't make sense to load with keybindings I have often copied what doom does with some minor modifications. Example differences: I am using the =evil-(operator|visual)-state-entry-hook= hooks for loading packages that just provide text objects, I'm using =evil-insert-state-entry-hook= with read-only/major mode type checks for loading some packages, I'm using a hook for when I run a keybinding to switch the scratch buffer to Emacs lisp mode, etc.). I'm also using doom's :defer-incrementally for larger packages (org, lispy, magit, etc.). :defer-incrementally helps prevent large pauses especially if you start the daemon before creating a client.
  - Configuration should work when using the daemon (e.g. some functionality that relies on GUI Emacs needs to be run later). When using the daemon, startup time isn't as important, but it should still be fast. I try to keep ~emacs-init-time~ at <0.6 seconds (when I started using Emacs, I was requiring everything during initialization, and startup could take 20-60 seconds on my old laptop). Probably I could get things to look faster if I load after init (though that will require some changes).
  - Use profiling to diagnose performance issues during and after startup.
  - Benchmark with a combination of benchmark-init, profile-dotemacs, and tracking where packages are required for debugging (see custom init.el flags)
- Intelligent handling of errors in init file
  - Localize recoverable errors and convert them to warnings whenever possible (e.g. if a package fails to install, warn and don't run its configuration). This means wrapping anything that requires a package to be loaded in a ~with-eval-after-load~ (usually via ~use-package~ or ~general-with-package~).
  - Isolate sections (source blocks) where possible, so that one section failing will not affect other sections. When there is some non-recoverable error somewhere in my init (e.g. ~(call-to-misspelled-function)~), I can start Emacs with =--with-demoted-errors= (flag I'm handling in =./init.el=) to demote errors for every source block. This means that I can still use Emacs with most of my configuration to fix my init file without needing to switch to a stable configuration or a different editor.
  - Use a stable init file for errors that break everything (e.g. missing/extra parens). I'm automatically saving my configuration when it successfully loads with a =-stable.el= suffix, and I can load this configuration by specifying =--stable=. As for package breakage, straight and elpaca can handle locking versions/commits (next bullet).
  - Use package lock files to be able to recover with if package updates break things.
  - Don't assume that any packages besides the core packages (e.g. =elpaca=, =use-package=, =setup=, =general=, and =evil=) have been loaded. Sections should otherwise be independent and reorderable.
  - Conditionally load non-portable functionality to prevent errors when using on other computers. Don't rely on unpushed functionality in personal packages (I was really bad about this in the past).
- Idempotency
  - Make configuration idempotent, so that any part can be run again without issues. It isn't as important to be able to reload the whole file in Emacs as it is for other software since it's more normal to just incrementally eval whatever you're working on.
- Short/Sane/Consistent Keybindings
  - As mentioned in the previous section, I prefer to have a lot of prefix keys to keep keybindings shorter.
  - I need to work on keybinding consistency (=m= keybindings are slightly different between programming modes). I plan to use and contribute to =evil-collection= more in the future to do this.
- Readability/Editabilty
  - Document issues and the purpose of any code that might not be immediately clear later. All non-trivial functions should have docstrings.
  - Use one big org file for fast/easy navigation.

I have some more package-specific guidelines listed in the use-package, elpaca, and general.el sections below.

** Style Guidelines
- Sharp quote all functions (including commands in keybindings).
- Don't enable minor modes with a =+1= argument (any argument is unnecessary when ~define-minor-mode~ is used; the mode is only toggled when the command is called interactively; this means that it is not necessary to use a lambda or named function to enable a minor mode with ~add-hook~).
- Generally try to follow these [[https://github.com/bbatsov/emacs-lisp-style-guide][Emacs Lisp Style Guidelines]].

* Utilities/Helper Packages and Basic Setup
** CL Lib
Used throughout configuration.
#+begin_src emacs-lisp
(require 'cl-lib)
#+end_src

** Map
Necessary to be able to use ~(setf (map-elt ...) ...)~, for example.
#+begin_src emacs-lisp
(require 'map)
#+end_src

** Helpers
*** General
#+begin_src emacs-lisp
(defconst noct-lisp-modes
  '(emacs-lisp-mode
    lisp-interaction-mode
    ielm-mode
    eshell-mode
    fennel-mode
    scheme-mode
    clojure-mode
    cider-repl-mode
    lisp-mode
    sly-mrepl-mode)
  "List for all used lisp modes.")

(defconst noct-lisp-mode-hooks
  (mapcar (lambda (mode) (intern (format "%s-hook" mode)))
          noct-lisp-modes)
  "List of hooks for all used lisp modes.")

(defconst noct-minibuffer-maps
  '(minibuffer-local-map
    minibuffer-local-ns-map
    minibuffer-local-completion-map
    minibuffer-local-must-match-map
    minibuffer-local-isearch-map
    evil-ex-completion-map)
  "List of minibuffer keymaps.")

(defconst noct-self-insert-commands
  '(self-insert-command
    org-self-insert-command
    LaTeX-insert-left-brace
    outshine-self-insert-command
    lispy-space)
  "List of self-insert commands.")

(defconst noct-shell-prompt-pattern
  "^[^#$%»>\\n]*[#$%»>] *"
  "Prompt pattern for my shell.")

(defconst noct-emacs-from-nix
  (string-match-p "/nix/store" invocation-directory)
  "Whether the current Emacs was installed through Nix.")

(defun noct-blog-dir-p (file)
  "Return whether the current file is in my blog post directory."
  (file-in-directory-p
   file
   (expand-file-name "content-org" (getenv "BLOG"))))

(defun noct-kill-this-buffer ()
  "`kill-this-buffer' with no menu-bar checks.
`kill-this-buffer' is supposed to be called from the menu bar.
See https://www.reddit.com/r/emacs/comments/64xb3q/killthisbuffer_sometimes_just_stops_working/."
  (interactive)
  (if (minibufferp)
      (abort-recursive-edit)
    (kill-buffer (current-buffer))))

(defun noct-inhibit-message-advice (oldfun &rest args)
  "Apply OLDFUN to ARGS with `inhibit-message' non-nil."
  (let ((inhibit-message t))
    (apply oldfun args)))

(defun noct-no-message (orig-fun &rest args)
  "Apply ORIG-FUN to ARGS with `message' overriden as `ignore'."
  (cl-letf (((symbol-function 'message) #'ignore))
    (apply orig-fun args)))

;; TODO as good as `quiet!'
(defmacro noct-silently (&rest body)
  (declare (indent 0) (debug t))
  `(let ((inhibit-message t)
         (save-silently t))
     (cl-letf (((symbol-function 'message) #'ignore))
       ,@body)))

(defun noct-silence-advice (oldfun &rest args)
  (noct-silently
    (apply oldfun args)))

(defun noct-inhibit-error-advice (oldfunc &rest args)
  "Run OLDFUN with ARGS, demoting errors to warnings.
Unlike with `with-demoted-errors', do this regardless of the value of
`debug-on-error'."
  (let (debug-on-error)
    (condition-case err
        (apply oldfunc args)
      (error
       (display-warning 'noct-error (format "Demoted error: %S" err))
       nil))))

(cl-defun noct-basename (&optional (file (buffer-file-name)))
  "Return the basename of FILE."
  (file-name-sans-extension (file-name-nondirectory file)))

;; TODO simplest way to evaluate /parts/ of a variable once only
(defmacro noct-letenv (env-binds &rest body)
  "Bind ENV-BINDS temporarily while running BODY.
Restore the old values for all specified environment variables after running
BODY (even on failure)."
  (declare (indent 1) (debug let))
  (let ((original-env (cl-gensym)))
    `(let ((,original-env
            (list ,@(mapcar (lambda (bind)
                              `(cons ,(car bind) (getenv ,(car bind))))
                            env-binds))))
       (unwind-protect
           (progn
             ,@(mapcar (lambda (bind)
                         `(setenv ,(car bind) ,(cadr bind)))
                       env-binds)
             ,@body)
         ,@(mapcar (lambda (bind)
                     `(setenv ,(car bind)
                              (alist-get ,(car bind)
                                         ,original-env
                                         nil
                                         nil
                                         #'equal)))
                   env-binds)))))

;; TODO use something more sophisticated?
;; alternatively, username check alone should be enough
(defconst noct-personal-computer-p
  (and (string= (user-login-name) "noctuid")
       (file-directory-p "~/ag-sys")))

(defmacro noct-with-q-to-exit (&rest body)
  `(progn ,@body
          (general-def 'normal 'local "q" #'delete-frame)))

(defun noct-bind-q-to-quit ()
  "Bind q to `quit-window' in the current buffer."
  (general-def 'normal 'local "q" #'quit-window))

(defmacro noct-disable-global-mode (mode)
  "Return a function that disables a global minor mode for the current buffer.
This works by adding to `after-change-major-mode-hook' locally to disable the
mode. Doing something like (add-hook 'major-mode-hook (lambda () (mode -1)))
will not work because global minor modes enable minor modes after major mode
hooks run."
  `(lambda ()
     (general-add-hook 'after-change-major-mode-hook
                       (lambda () (,mode -1))
                       t
                       t)))


(defmacro noct-run-at-active-interval (interval idle-interval &rest body)
  "Every INTERVAL seconds, unless idle for > IDLE-INTERVAL seconds, run BODY.
Also, after IDLE-INTERVAL seconds of idle time, run BODY. This allows using an
idle timer to quickly run BODY when Emacs becomes idle but also ensures that
BODY is run periodically even if Emacs is actively being used."
  (declare (indent 2))
  `(progn
     (run-at-time (current-time) ,interval
                  (lambda ()
                    (let* ((idle-time (current-idle-time))
                           (idle-secs (when idle-time
                                        (float-time idle-time))))
                      (unless (and idle-secs
                                   (> idle-secs ,idle-interval))
                        ,@body))))
     (run-with-idle-timer ,idle-interval t (lambda () ,@body))))

(defmacro noct-defun (name arglist &optional docstring &rest body)
  "`defun' but guaranteed return the created function."
  (declare (doc-string 3) (indent 2))
  `(progn (defun ,name ,arglist ,docstring ,@body)
          #',name))

(defmacro noct-c (&rest body)
  "Like `general-lambda' but create named function based on BODY.
Strip out parens and replace spaces/newlines with - to make the name more
readable."
  (declare (indent defun))
  ;; generally don't like overuse threading macros, but this seems like the
  ;; place to use
  ;; makes flycheck unhappy though
  (let ((name (thread-last
                body
                (format "%s")
                (replace-regexp-in-string "[()]" "")
                (replace-regexp-in-string (rx (or space "\n")) "-")
                (intern))))
    `(noct-defun ,name ()
       (interactive)
       ,@body)))

(defmacro noct-disable (mode)
  "Return a named function that disables MODE."
  (let ((name (intern (format "noct-disable-%s" mode))))
    `(noct-defun ,name (&rest _)
       ,(format "Disable %s." mode)
       (,mode -1))))

(defun noct-undo-a (orig-fun &rest args)
  "Wrap a call to ORIG-FUN with ARGS in `evil-with-undo'."
  (evil-with-undo
    (apply orig-fun args)))

(defun noct-add-undo-bounds (command)
  "Advise COMMAND to be wrapped in `evil-with-undo'."
  (general-after 'evil
    (general-add-advice command :around #'noct-undo-a)))
#+end_src

*** GUI Related
#+begin_src emacs-lisp
;; TODO handling minor modes that should only be enabled for GUI frames is
;; difficult; previously, I was toggling modes using `focus-in-hook' (now
;; obsolete), and it didn't work well
;; TODO for daemon, probably would be better to run once and add to
;; `server-after-make-frame-hook'
;; (defmacro noct-if-gui-p (then else &optional once)
;;   "Every time a frame is created, run THEN if it is a GUI frame.
;; Otherwise run ELSE. If ONCE is non-nil, only run THEN or ELSE the first time a
;; frame is created."
;;   (declare (indent 1)))
;; NOTE it seems the best way to handle this is for the minor mode itself to
;; take care of it by dynamically checking `display-graphic-p' like ivy-posframe
;; now does

(defmacro noct-after-gui (&rest body)
  "Run BODY once after the first GUI frame is created."
  (declare (indent 0) (debug t))
  `(if (display-graphic-p)
       (progn ,@body)
     (general-add-hook 'server-after-make-frame-hook
                       (lambda () ,@body)
                       nil
                       nil
                       t)))

;; NOTE these only work for GUI
(defun noct-default-monitor-geometry ()
  "Return geometry for the first monitor in `display-monitor-attributes-list'."
  (let* ((first-monitor (car (display-monitor-attributes-list))))
    (alist-get 'geometry first-monitor)))

(defun noct-default-monitor-width ()
  "Return the width of the first monitor in `display-monitor-attributes-list'."
  (nth 2 (noct-default-monitor-geometry)))

(defun noct-default-monitor-height ()
  "Return the height of the first monitor in `display-monitor-attributes-list'."
  (nth 3 (noct-default-monitor-geometry)))

(defun noct-border-width ()
  "Return the width to use for borders.
Uses 4 pixels FHD and 8 on 4k."
  (round (* 0.00208333333 (noct-default-monitor-width))))

(defun noct-posframe-poshandler-frame-near-top-center (info)
  "Handler to display posframe centered near the top."
  (cons (/ (- (plist-get info :parent-frame-width)
              (plist-get info :posframe-width))
           2)
        (round (* 0.02 (noct-default-monitor-height)))))
#+end_src

*** TODO Popup Handling and =display-buffer-alist=
Generally, I have one or two "main" windows open at a time (split horizontally). I like to display "popups" at the top (e.g. help mode windows, magit buffers, etc.). Previously, I used shackle, but for such a simple setup, it's easy enough to use =display-buffer-alist= directly.

**** Popup Helpers
#+begin_src emacs-lisp
;; https://web.archive.org/web/20160409014815/https://www.lunaryorn.com/2015/04/29/the-power-of-display-buffer-alist.html
(defmacro noct-match-major-mode (mode)
  "Create a function that returns whether the current `major-mode' is MODE."
  (let ((name (intern (format "noct-match-%s" mode))))
    `(progn
       (defun ,name (buffer-or-name _action)
         (ignore-errors
           (let ((buffer (get-buffer buffer-or-name)))
             (eq ',mode (buffer-local-value 'major-mode buffer)))))
       #',name)))

(defun noct-display-and-select-buffer (func buffer alist)
  "Call FUNC with BUFFER and ALIST.
Select the window afterwards if possible. This is modified from
`shackle--display-buffer-reuse'. Additionally set the window to be fixed size."
  (let ((window (funcall func buffer alist)))
    (when (and window (window-live-p window))
      (select-window window t))
    ;; TODO this breaks slots; doesn't work for non-side windows
    ;; (with-current-buffer buffer
    ;;   (setq window-size-fixed t))
    window))

(defun noct-display-buffer-reuse-window (buffer alist)
  "Call `display-buffer-reuse-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (noct-display-and-select-buffer #'display-buffer-reuse-window buffer alist))

(defun noct-display-buffer-in-side-window (buffer alist)
  "Call `display-buffer-in-side-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (noct-display-and-select-buffer #'display-buffer-in-side-window buffer alist))

(defun noct-display-buffer-in-side-window-no-header (buffer alist)
  "`noct-display-buffer-in-side-window' but don't have a header line.
Having a header line in some buffers will cause text to be cut off at the
bottom (e.g. transient and frog menu)."
  (noct-display-buffer-in-side-window buffer alist)
  (setf (buffer-local-value 'header-line-format buffer) nil))

(defun noct-display-buffer-same-window (buffer alist)
  "Call `display-buffer-same-window' with BUFFER and ALIST.
Select the window afterwards if possible."
  (noct-display-and-select-buffer #'display-buffer-same-window buffer alist))

(defun shackle--split-some-window (frame alist)
  "Return a window if splitting any window was successful.
This function tries using the largest window on FRAME for
splitting, if all windows are the same size, the selected one is
taken, in case this fails, the least recently used window is used
for splitting.  ALIST is passed to `window--try-to-split-window'
internally."
  (or (window--try-to-split-window (get-largest-window frame t) alist)
      (window--try-to-split-window (get-lru-window frame t) alist)))

(defun shackle--display-buffer-popup-window (buffer alist)
  "Display BUFFER in a popped up window.
This is a stripped down version of `shackle--display-buffer-popup-window'.
ALIST is passed to `shackle--window-display-buffer' internally.
If PLIST contains the :other key with t as value, reuse the next
available window if possible."
  (let ((window (if (not (one-window-p))
                    (next-window nil 'nominibuf)
                  (shackle--split-some-window (selected-frame) alist))))
    (window--display-buffer buffer window 'window alist)))

(defun noct-display-buffer-creating-other-window (buffer alist)
  "Call `display-buffer-in-other-window' with BUFFER and ALIST.
If another window does not exist, create it. Select the window afterwards if
possible."
  (noct-display-and-select-buffer #'shackle--display-buffer-popup-window
                                  buffer alist))

(defmacro noct-handle-window (condition &rest body)
  "Display windows matching CONDITION with the settings in BODY."
  (declare (indent 1) (debug t))
  (let ((condition (if (and (symbolp condition)
                            (string-match "-mode$" (symbol-name condition)))
                       `(noct-match-major-mode ,condition)
                     condition)))
    `(cl-pushnew
      (list ,condition ,@body)
      display-buffer-alist
      :test 'equal)))

(defmacro noct-handle-popup (condition &optional slot)
  "Display popups matching CONDITION in a side window at the top.
When SLOT is non-nil, display popup buffers in that SLOT in the side window."
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window noct-display-buffer-in-side-window)
     '(side . top)
     '(slot . ,slot)
     '(window-height . 0.5)))

(defmacro noct-handle-popup-no-header (condition &optional slot)
  "Display popups matching CONDITION in a side window at the top.
Remove the header line. This handles some buffers where text would be cut off
when there is a header line. When SLOT is non-nil, display popup buffers in that
SLOT in the side window."
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window
       noct-display-buffer-in-side-window-no-header)
     '(side . top)
     '(slot . ,slot)
     '(window-height . 0.5)))

(defmacro noct-handle-popup-same-window (condition)
  "Display popups matching CONDITION in the current window."
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window noct-display-buffer-same-window)))

(defmacro noct-handle-popup-other-window (condition)
  "Display popups matching CONDITION in the other window.
Create another window if one doesn't exist"
  `(noct-handle-window ,condition
     '(noct-display-buffer-reuse-window
       noct-display-buffer-creating-other-window)))

(defmacro noct-handle-popup-other-window-no-select (condition)
  "Display popups matching CONDITION in the other window without selecting it.
Create another window if one doesn't exist"
  `(noct-handle-window ,condition
     'shackle--display-buffer-popup-window))

(defun noct-side-window-p ()
  "Return non-nil if the selected window is a side window."
  (window-parameter (selected-window) 'window-side))
#+end_src

**** Basic =display-buffer-alist= setup
#+begin_src emacs-lisp
(noct-handle-popup (rx "*Warnings*"))

(cl-pushnew
 (list (rx "*Async Shell Command*" (0+ any)) #'display-buffer-no-window)
 display-buffer-alist)
#+end_src

*** Email Info and Variables
#+begin_src emacs-lisp
(when (locate-library "noct-info")
  (require 'noct-info))
#+end_src

*** Debugging
Useful for debugging vertico, ivy, etc.
#+begin_src emacs-lisp
;; https://github.com/raxod502/prescient.el/issues/56#issuecomment-614094583
(defun raxod502-force-debug (func &rest args)
  (condition-case e
      (apply func args)
    ((debug error) (signal (car e) (cdr e)))))

;; for example
;; (general-add-advice 'ivy--exhibit :around #'raxod502-force-debug)
#+end_src

*** Custom Declares
See [[https://old.reddit.com/r/emacs/comments/gi70ye/weekly_tipstricketc_thread/fqg7qys/][here]]. Can't currently think of a good use case but will probably use at some point.

** =package.el=
Currently, I only use =package.el= if I want to use the package list buffer. I generally don't use it for installing anything.
#+begin_src emacs-lisp
(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")))
#+end_src

** elpaca and =use-package.el=
When I first tried Emacs, I thought the idea of using centralized package repositories was interesting but was annoyed when packages I wanted to use weren't (yet) in any package archive. Alternatives like =el-get= and =quelpa= weren't quite what I wanted. =straight.el= and elpaca are nice in that they fully replace =package.el= for me while still making use of recipes from elpa, melpa, etc. This means that while you can specify your own recipe, it's usually not necessary.

I use elpaca to compile/autoload my personal local packages. I also occasionally use it to contribute to packages (by directly working with the downloaded repo). Even if I didn't use it for development, having the git repos available locally is useful for many reasons. It's great to have READMEs and other files available locally, to be able to use git blame, and to be able to switch to or lock any commit.

Since ~setq~, ~add-hook~, and ~evil-define-key~ can all be used before the specified settings, hooks, and keymaps exist, I previously preferred to use them outside of ~use-package~. I didn't like nesting these inside of ~use-package~ especially for more complicated packages where my configuration is split across many headings. On the other hand, this can potentially affect startup time. I considered writing my configuration so that headings could be /optionally/ tangled into a previous =:config= section or to optionally tangle headings into a new ~with-eval-after-load~ call (specifically ~general-with-package~ provided by general.el). I decided this would be too convoluted/misleading and am now just using ~general-with-package~ manually. I've stopped being bothered with the nesting.

Here are the guidelines I follow for using ~use-package~ keywords and the order I use them in.

Package installation:
- =:ensure= (from elpaca) to specify recipes for custom or local packages

Package loading:
- =:disabled= for disabled packages (e.g. unused themes)
- =:if=, =:when=, and =:unless= for conditionally loading/configuring the package
- =:after= when it only makes sense to load one package after another (not used for "core" packages like =evil= that are loaded immediately) (usually not necessary)
- =:demand t= for packages that should be loaded immediately (e.g. =evil=)
- =:defer number= for packages whose functionality should be quickly available but is not necessary immediately (use sparingly)
- =:defer-incrementally= for packages with lots of dependencies (functionality from doom)
- =:ghook= to add to hooks that will later run and load the package
- =:mode= as a temporary solution for major modes that don't add to =auto-mode-alist=
- =:commands= as a temporary solution for packages that don't have autoload cookies
- =:general= for any keybindings meant to load the package (and not others; I use this keyword only to make it very clear how the package will be loaded)
- =:init= for any settings that need to be set before loading the package (e.g. =evil-want-keybinding=) and for function calls meant to load the package (e.g. enabling a global minor mode, setting another package's variable to a function from this package, etc.)

Note that using =:after= will put the rest of the non-installation configuration in an ~eval-after-load~ (including the =:init= section, the =(require package)= statement generated from =:demand t=, etc.). Also note that by default only =:init= can fail if the package isn't successfully installed (see ~use-package-check-before-init~); specifying =:demand=, for example, will cause an error if the package fails to install.

As a workaround, I'm setting a default value for =:when= in ~use-package-defaults~ (that is used even when =:when= is explicitly specified) to prevent package configuration if package installation fails. See [[https://github.com/jwiegley/use-package/issues/693][issue 693]] and [[https://github.com/jwiegley/use-package/issues/739][issue 739]].

Package configuration:
- =:blackout= (or =:diminish= or =:delight=) for diminishing minor mode names
- =:gfhook= for any setup configuration for a mode (e.g. set local variables or enable/disable minor modes)
- =:config= for any basic package setup; more complicated setup should go in specific subheadings

In the =:config= section, I generally put settings (~setq~ then any face configuration then ~add-hook~), then keybindings, then enabling any modes, and then any other configuration.

*** Elpaca
 #+begin_src emacs-lisp
(defun noct-get-nix-emacs-date ()
  "Extract date as number from --prefix path in `system-configuration-options'."
  (when-let ((path (and (string-match "--prefix=\\([^ ]+\\)"
                                      system-configuration-options)
                        (match-string 1 system-configuration-options)))
             (date (and (string-match "emacs-git-\\([0-9]\\{8\\}\\)[^0-9]" path)
                        (match-string 1 path))))
    (string-to-number date)))

(when noct-personal-computer-p
  (when-let ((emacs-date (noct-get-nix-emacs-date)))
    (setq elpaca-core-date (list emacs-date))))

;; NOTE: this is intentionally different from where `noct-elpaca-lock' writes to
(defconst noct-elpaca-lock-file
  (expand-file-name "elpaca-lock" user-emacs-directory))

(when (file-exists-p noct-elpaca-lock-file)
  (setq elpaca-lock-file noct-elpaca-lock-file))

(defvar elpaca-installer-version 0.11)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1 :inherit ignore
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (<= emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let* ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))

(elpaca elpaca-use-package
  ;; Enable Elpaca support for use-package's :ensure keyword.
  (elpaca-use-package-mode)
  ;; :ensure by defualt
  (setq use-package-always-ensure t))
(elpaca-wait)

(defmacro noct-elpaca-after-init (&rest body)
  "Run BODY after emacs initialization.
If after emacs initialization already, run BODY now."
  (declare (indent 0) (debug t))
  `(if elpaca-after-init-time
       (progn ,@body)
     (general-add-hook 'elpaca-after-init-hook (lambda () ,@body))))
 #+end_src

*** Use-package
#+begin_src emacs-lisp
;; don't require `use-package' when loading compiled file; saves a millisecond
;; or 2; compiling now saves ~0.1s overall (maybe another 0.1s after general
;; rewrite)
(eval-when-compile
  (require 'use-package)

  ;; don't actually need `eval-when-compile' for rest since currently loading
  ;; entire init file before compiling already
  (setq use-package-always-defer t)

  ;; (defun noct-package-available-p (package keywords)
  ;;     "Return whether PACKAGE is in `noct-straight-packages'.
  ;; Also return non-nil if KEYWORDS contains :straight nil."
  ;;     (or (and (memq :straight keywords)
  ;;              (null (plist-get keywords :straight)))
  ;;         ;; must be quoted so doesn't check at expansion time
  ;;         `(memq ',package noct-straight-packages)))

  ;; don't do anything if installation fails; like
  ;; `use-package-check-before-init' but works for :config and other keywords;
  ;; recording `straight-use-package' return values instead of using
  ;; `locate-library' since it was adding an extra 0.15 seconds to init
  ;; (cl-pushnew '(:when
  ;;               noct-package-available-p
  ;;               t)
  ;;             use-package-defaults
  ;;             :test #'equal)
  )

;; demote installation errors to messages
;; this variable is no longer changed by straight
;; (advice-add use-package-ensure-function :around #'noct-use-package-ensure)

;; NOTE: this method is no longer usable with elpaca
;; (when (bound-and-true-p noct-with-demoted-errors)
;;   (advice-add 'straight-use-package :around #'noct-inhibit-error-advice))
;; can test with something like this:
;; (use-package does-not-exist)

(use-package blackout
  :ensure (:host github :repo "raxod502/blackout")
  :demand t)
#+end_src

** Async Init Tangling
See =./init.el=. This is installed as a dependency by other packages, but I'm installing it here to be explicit.
#+begin_src emacs-lisp
(use-package async)
#+end_src

** =general.el=
Principles:
- Prefer using ~general-def~ or a more specific wrapper for all keybindings (more concise than ~define-key~, consistent interface to all keybindings, syntax is mostly interchangeable with builtin and evil definers, records keybindings, etc.).
- Prefer using general hook and setting wrappers (e.g. ~general-setq~ instead of ~setq~ and ~general-pushnew~ instead of ~cl-pushnew~ or ~add-to-list~; they allow recording settings/hooks and call ~defcustom~ :set functions unlike ~setq~).
- Use =:general= and =:ghook= keywords for keybindings and hooks meant to load packages.
- Use ~general-with-package~ instead of ~use-package~ if the ~use-package~ statement would only have =:config= and not install the package (like ~with-eval-after-load~ but allows automatically recording the package name with keybindings and settings). All general functions should appear in either a ~general-with-package~ or a ~use-package~ statement if there is a specific, corresponding package.
#+begin_src emacs-lisp
(use-package general
  :ensure `(general
            ;; need to use in rest of config
            :wait t
            ,@(when noct-personal-computer-p
                (list :repo "~/src/emacs/general")))
  :demand t)

(use-package annalist
  :ensure `(annalist
            ;; need to use in rest of config
            :wait t
            ,@(when noct-personal-computer-p
                (list :repo "~/src/emacs/annalist")))
  :gfhook
  ('annalist-describe-hook #'noct-bind-q-to-quit)
  ('annalist-describe-hook (noct-disable visual-fill-column-mode)))

(general-auto-unbind-keys)

(eval-and-compile
  (defalias 'gsetq #'general-setq)
  ;; TODO replace with `satch-opt'
  (defalias 'opt #'general-setq)
  (defalias 'gsetq-local #'general-setq-local)
  (defalias 'gsetq-default #'general-setq-default))

;; NOTE may rename these based on purpose and do find and replace if ever decide
;; to change the keybindings
(general-create-definer general-spc
  :states '(normal visual)
  :keymaps 'override
  :prefix "SPC")

(general-create-definer general-cc
  :states '(normal insert)
  ;; don’t want prefix in e.g. vterm insert
  ;; :keymaps 'override
  :prefix "C-c")

(general-create-definer general-t
  :states 'normal
  :keymaps 'override
  :prefix "t")

(general-create-definer general-r
  :states 'motion
  :prefix "r")

;; TODO rename to something else
(general-create-definer general-s
  :keymaps '(insert normal)
  :keymaps 'override
  :prefix "C-t")

(general-create-definer general-m
  :states 'normal
  :prefix "m")

(general-create-definer general-comma
  :states 'normal
  :prefix ",")
#+end_src

** Setup.el
#+begin_src emacs-lisp
(use-package setup
  :ensure (:wait t)
  :demand t
  :config
  ;; from wiki
  (defun setup-wrap-to-install-package (body _name)
    "Wrap BODY in an `elpaca' block if necessary.
The body is wrapped in an `elpaca' block if `setup-attributes'
contains an alist with the key `elpaca'."
    (if (assq 'elpaca setup-attributes)
        `(elpaca ,(cdr (assq 'elpaca setup-attributes)) ,@(macroexp-unprogn body))
      body))
  ;; Add the wrapper function
  (add-to-list 'setup-modifier-list #'setup-wrap-to-install-package)
  (setup-define :elpaca
    (lambda (order &rest recipe)
      (push (cond
	         ((eq order t) `(elpaca . ,(setup-get 'feature)))
	         ((eq order nil) '(elpaca . nil))
	         (`(elpaca . (,order ,@recipe))))
	        setup-attributes)
      ;; If the macro wouldn't return nil, it would try to insert the result of
      ;; `push' which is the new value of the modified list. As this value usually
      ;; cannot be evaluated, it is better to return nil which the byte compiler
      ;; would optimize away anyway.
      nil)
    :documentation "Install ORDER with `elpaca'.
The ORDER can be used to deduce the feature context."
    :shorthand #'cadr)

  ;; personal/not wiki
  ;; infers feature name unlike builtin :require
  (setup-define :demand
    (lambda (&rest features)
      (if features
          `(progn ,@(mapcar
                     (lambda (feature)
                       `(unless (require (',(or feature (setup-get 'feature))
                                          nil t))
                          ,(setup-quit)))
                     features))
        `(unless (require ',(setup-get 'feature) nil t)
           ,(setup-quit))))
    :documentation "Try to require FEATURE, or stop evaluating body.
The first FEATURE can be used to deduce the feature context."
    :repeatable nil)

  ;; personal/not wiki
  (setup-define :config
    (lambda (&rest body)
      `(once-with-eval-after-load ',(setup-get 'feature) ,@body))
    :documentation
    "Evaluate BODY once (with once.el), when current feature loads."
    :debug '(body)
	:indent 0)

  (setup-define :blackout
    (lambda (&optional mode replacement)
      `(blackout ',(if (memq mode '(nil t))
                       (setup-get 'feature)
                     mode)
                 ,replacement))
    :documentation "Blackout MODE or the current feature with REPLACEMENT."
    :repeatable nil
	:indent 0)

  ;; https://www.emacswiki.org/emacs/SetupEl#h5o-7
  (setup-define :autoload
    (lambda (func)
      (let ((fn (if (memq (car-safe func) '(quote function))
                    (cadr func)
                  func)))
        `(unless (fboundp (quote ,fn))
           (autoload (function ,fn) ,(symbol-name (setup-get 'feature)) nil t))))
    :documentation "Autoload FUNC if not already bound."
    :repeatable t
    :signature '(FUNC ...))

  ;; alternative version of :file-match that supports specifying mode
  (setup-define :mode
    (lambda (pat &optional mode)
      (let ((mode (or mode (setup-get 'mode))))
        `(cl-pushnew (cons ,pat ',mode) auto-mode-alist)))
    :repeatable nil)

  ;; personal/not wiki
  ;; TODO use satch-add-hook
  (setup-define :hooks
    (lambda (hooks &optional funcs &rest args)
      (let ((funcs (or funcs `#',(setup-get 'func))))
        `(general-add-hook ,hooks ,funcs ,@args)))
    :repeatable nil)

  ;; personal/not wiki
  (setup-define :fhooks
    (lambda (arg1 &optional arg2 &rest args)
      (let ((hooks (if arg2
                       arg1
                     `',(setup-get 'hook)))
            (funcs (or arg2 arg1)))
        `(general-add-hook ,hooks ,funcs ,@args)))
    :repeatable nil)

  (defmacro noct-use (arg1 &rest args)
    (declare (indent 1))
    `(setup ,(if (listp arg1)
                 (if (eq (car arg1) :no-install)
                     (cadr arg1)
                   arg1)
               `(:elpaca ,arg1))
       ,@args))

  ;; https://www.emacswiki.org/emacs/SetupEl#h5o-4
  (defmacro defsetup (name signature &rest body)
    "Shorthand for `setup-define'.
NAME is the name of the local macro.  SIGNATURE is used as the
argument list for FN.  If BODY starts with a string, use this as
the value for :documentation.  Any following keywords are passed
as OPTS to `setup-define'."
    (declare (debug defun))
    (let (opts)
      (when (stringp (car body))
        (setq opts (nconc (list :documentation (pop body))
                          opts)))
      (while (keywordp (car body))
        (let* ((prop (pop body))
               (val `',(pop body)))
          (setq opts (nconc (list prop val) opts))))
      `(setup-define ,name
         (cl-function (lambda ,signature ,@body))
         ,@opts))))
#+end_src

** Once.el
 #+begin_src emacs-lisp
(noct-use ( :elpaca once
            :wait t
            :host github :repo "emacs-magus/once"
            :files (:defaults "once-setup/*.el"))
  (:demand)
  (gsetq once-shorthand t)
  ;; (require 'once-incrementally)
  ;; (once-enable-incremental-loading)
  (eval-and-compile
    ;; must set before loading
    (gsetq once-setup-keyword-aliases
           '(":once-x-require" ":require-once"
             ":once-require-incrementally" ":require-incrementally")))
  (require 'once-setup))
#+end_src

** On.el - Extra Hooks
#+begin_src emacs-lisp
(noct-use ( :elpaca on
            :host github :repo "ajgrf/on.el")
  (:demand)

  (defvar noct-elisp-scratch-hook nil
    "Hook run when scratch buffer switches from fundamental to emacs-lisp mode.
Can't use `after-change-major-mode-hook' hook since that triggers during init.")

  ;; TODO remove other after one is called
  (defmacro noct-after-buffer (&rest body)
    "Run BODY once after switching buffers or when finding a file.
Doom uses a lot. Additionally run once in `noct-elisp-scratch-hook', so
BODY run if I switch the scratch buffer to elisp."
    (declare (indent defun))
    `(let ((fun (lambda (&rest _)
                  ,@body)))
       (general-add-hook '(on-switch-buffer-hook
                           noct-elisp-scratch-hook) fun nil nil t)
       (general-add-advice 'after-find-file :before fun nil t)))

  (defmacro noct-after-window (&rest body)
    "Run BODY once after switching windows or when finding a file."
    (declare (indent defun))
    `(let ((fun (lambda (&rest _)
                  ,@body)))
       (general-add-hook 'on-switch-window-hook fun nil nil t)
       (general-add-advice 'after-find-file :before fun nil t)))

  (defmacro noct-pre-command-or-post-file (&rest body)
    "Run BODY once in `pre-command-hook' or when finding a file."
    (declare (indent defun))
    `(let ((fun (lambda (&rest _)
                  ,@body)))
       (general-add-hook 'pre-command-hook fun nil nil t)
       (general-add-advice 'after-find-file :before fun nil t)))

  (defmacro noct-post-insert-and-writable (&rest body)
    "Run BODY in `evil-insert-state-entry-hook' for the first writable buffer."
    (declare (indent defun))
    `(progn
       (general-add-hook 'evil-insert-state-entry-hook
                         (lambda ()
                           (unless buffer-read-only
                             ,@body
                             t))
                         nil
                         nil
                         #'identity))))
#+end_src

** Doom Helpers
*** Large File Handling
#+begin_src emacs-lisp
(defvar-local doom-large-file-p nil)
(put 'doom-large-file-p 'permanent-local t)

(defvar doom-large-file-size-alist '(("." . 3.0))
  "An alist mapping regexps (like `auto-mode-alist') to filesize thresholds.

If a file is opened and discovered to be larger than the threshold, Doom
performs emergency optimizations to prevent Emacs from hanging, crashing or
becoming unusably slow.

These thresholds are in MB, and is used by `doom--optimize-for-large-files-a'.")

(defvar doom-large-file-excluded-modes
  '(so-long-mode
    special-mode archive-mode tar-mode jka-compr
    git-commit-mode image-mode doc-view-mode doc-view-mode-maybe
    ebrowse-tree-mode pdf-view-mode tags-table-mode)
  "Major modes that `doom-check-large-file-h' will ignore.")

(defun doom--optimize-for-large-files-a (orig-fn &rest args)
  "Set `doom-large-file-p' if the file is too large.

Uses `doom-large-file-size-alist' to determine when a file is too large. When
`doom-large-file-p' is set, other plugins can detect this and reduce their
runtime costs (or disable themselves) to ensure the buffer is as fast as
possible."
  (if (setq doom-large-file-p
            (and buffer-file-name
                 (not doom-large-file-p)
                 (file-exists-p buffer-file-name)
                 (ignore-errors
                   (> (nth 7 (file-attributes buffer-file-name))
                      (* 1024 1024
                         (assoc-default buffer-file-name
                                        doom-large-file-size-alist
                                        #'string-match-p))))))
      (prog1 (apply orig-fn args)
        (if (memq major-mode doom-large-file-excluded-modes)
            (setq doom-large-file-p nil)
          (when (fboundp 'so-long-minor-mode) ; in case the user disabled it
            (so-long-minor-mode))
          (message "Large file! Cutting corners to improve performance")))
    (apply orig-fn args)))

(general-add-advice 'after-find-file :around #'doom--optimize-for-large-files-a)
#+end_src


*** Defer Incrementally
TODO Put this in a package.
#+begin_src emacs-lisp
;; https://github.com/hlissner/doom-emacs/blob/42a21dffddeee57d84e82a9f0b65d1b0cba2b2af/core/core.el#L353
(defvar doom-incremental-packages '(t)
  "A list of packages to load incrementally after startup. Any large packages
here may cause noticeable pauses, so it's recommended you break them up into
sub-packages. For example, `org' is comprised of many packages, and can be
broken up into:
  (doom-load-packages-incrementally
   '(calendar find-func format-spec org-macs org-compat
     org-faces org-entities org-list org-pcomplete org-src
     org-footnote org-macro ob org org-clock org-agenda
     org-capture))
This is already done by the lang/org module, however.
If you want to disable incremental loading altogether, either remove
`doom-load-packages-incrementally-h' from `emacs-startup-hook' or set
`doom-incremental-first-idle-timer' to nil.")

(defvar doom-incremental-first-idle-timer 2.0
  "How long (in idle seconds) until incremental loading starts.
Set this to nil to disable incremental loading.")

(defvar doom-incremental-idle-timer 0.75
  "How long (in idle seconds) in between incrementally loading packages.")

(defvar doom-incremental-load-immediately nil
  ;; (daemonp)
  "If non-nil, load all incrementally deferred packages immediately at startup.")

(defmacro appendq! (sym &rest lists)
  "Append LISTS to SYM in place."
  `(setq ,sym (append ,sym ,@lists)))

(defun doom-load-packages-incrementally (packages &optional now)
  "Registers PACKAGES to be loaded incrementally.
If NOW is non-nil, load PACKAGES incrementally, in `doom-incremental-idle-timer'
intervals."
  (if (not now)
      (appendq! doom-incremental-packages packages)
    (while packages
      (let ((req (pop packages)))
        (unless (featurep req)
          (message "Incrementally loading %s" req)
          (condition-case e
              (or (while-no-input
                    ;; If `default-directory' is a directory that doesn't exist
                    ;; or is unreadable, Emacs throws up file-missing errors, so
                    ;; we set it to a directory we know exists and is readable.
                    (let ((default-directory user-emacs-directory)
                          (gc-cons-threshold most-positive-fixnum)
                          file-name-handler-alist)
                      (require req nil t))
                    t)
                  (push req packages))
            ((error debug)
             (message "Failed to load '%s' package incrementally, because: %s"
                      req e)))
          (if (not packages)
              (message "Finished incremental loading")
            (run-with-idle-timer doom-incremental-idle-timer
                                 nil #'doom-load-packages-incrementally
                                 packages t)
            (setq packages nil)))))))

(defun doom-load-packages-incrementally-h ()
  "Begin incrementally loading packages in `doom-incremental-packages'.
If this is a daemon session, load them all immediately instead."
  (if doom-incremental-load-immediately
      (mapc #'require (cdr doom-incremental-packages))
    (when (numberp doom-incremental-first-idle-timer)
      (run-with-idle-timer doom-incremental-first-idle-timer
                           nil #'doom-load-packages-incrementally
                           (cdr doom-incremental-packages) t))))

(add-hook 'emacs-startup-hook #'doom-load-packages-incrementally-h)

;; Adds two keywords to `use-package' to expand its lazy-loading capabilities:
;;
;;   :after-call SYMBOL|LIST
;;   :defer-incrementally SYMBOL|LIST|t
;;
;; Check out `use-package!'s documentation for more about these two.
(eval-when-compile
  (dolist (keyword '(:defer-incrementally :after-call))
    (push keyword use-package-deferring-keywords)
    (setq use-package-keywords
          (use-package-list-insert keyword use-package-keywords :after)))

  (defalias 'use-package-normalize/:defer-incrementally #'use-package-normalize-symlist)
  (defun use-package-handler/:defer-incrementally (name _keyword targets rest state)
    (use-package-concat
     `((doom-load-packages-incrementally
        ',(if (equal targets '(t))
              (list name)
            (append targets (list name)))))
     (use-package-process-keywords name rest state))))
#+end_src

** Memoize
#+begin_src emacs-lisp
(noct-use (:elpaca memoize :wait t)
  (:demand))
#+end_src

** No Littering
Consistently sets the paths for various configuration, history, temporary, etc. files created by Emacs packages (e.g. =savehist-file=).
#+begin_src emacs-lisp
(noct-use (:elpaca no-littering :wait t)
  (:demand))
#+end_src

** Evil and Evil Collection
*** Setup
#+begin_src emacs-lisp
(use-package evil
  :ensure (:wait t)
  :init
  (gsetq evil-overriding-maps nil
         evil-intercept-maps nil
         evil-insert-state-bindings nil
         ;; must be set before loading evil no matter what
         evil-want-keybinding nil
         ;; required for gn
         evil-search-module 'evil-search
         evil-ex-search-persistent-highlight nil
         ;; Y like D
         evil-want-Y-yank-to-eol t)
  ;; prevent undo-tree from loading (not yet a variable to disable)
  ;; also flyspell (don't need immediately)
  (general-add-advice
   'require :around
   (noct-defun noct-prevent-evil-requires (orig-fun &rest args)
     (unless (memq (car args) '(undo-tree flyspell shell))
       (apply orig-fun args))))
  (evil-mode)
  (general-remove-advice 'require #'noct-prevent-evil-requires)
  :config
  ;; use `general-key-dispatch' for "c" (e.g. to bind cx to `evil-exchange')
  (general-def :prefix-map 'noct-c-map
    "c" (general-simulate-key (#'evil-change "c")))
  (general-def 'normal
    "c" (general-key-dispatch #'evil-change
          :inherit-keymap noct-c-map))
  (general-def 'visual "c" #'evil-change)
  ;; add back wanted insert state keybindings
  (general-def 'insert
    "C-o" #'evil-execute-in-normal-state
    "C-r" #'evil-paste-from-register
    ;; trying out since don't normally use `universal-argument' in insert
    "C-u" #'evil-delete-back-to-indentation))

(use-package evil-collection
  :ensure `(evil-collection
            :host github
            :repo "emacs-evil/evil-collection"
            ,@(when noct-personal-computer-p
                (list :repo "~/src/forks/evil-collection")))
  :config
  ;; e.g. binds in eshell normal mode
  (gsetq evil-collection-key-blacklist '("C-n"))
  ;; TODO now using these for window management
  ;; (defun noct-make-evil-collection-translations (mode mode-keymaps &rest _rest)
  ;;   (when mode-keymaps
  ;;     (general-with mode
  ;;       (general-translate-key 'normal mode-keymaps
  ;;         "C-n" "C-j"
  ;;         "C-e" "C-k"))))

  ;; (general-add-hook 'evil-collection-setup-hook
  ;;                   #'noct-make-evil-collection-translations)
  )
#+end_src

*** Settings
**** Improvements from Vim
#+begin_src emacs-lisp
(general-with 'evil
  ;; I always disliked this behavior in vim
  (gsetq evil-move-cursor-back nil
         ;; this doesn't matter as much with above setting
         evil-move-beyond-eol t
         ;; default to inserting `<,`> when run `evil-ex' in visual char state;
         ;; unlike vim, ex commands will only apply to the selected region instead
         ;; of the selected lines when `<,`> is used
         evil-ex-visual-char-range t))
#+end_src

**** Normal State Everywhere
Use normal state as the default state for all modes.
#+begin_src emacs-lisp
;; not necessary to set `evil-normal-state-modes' (since normal is the default
;; state) but it's more explicit
(general-with 'evil
  (gsetq evil-normal-state-modes (append evil-emacs-state-modes
                                         evil-normal-state-modes)
         evil-emacs-state-modes nil
         evil-motion-state-modes nil))
#+end_src

**** Appearance
I prefer to distinguish mode by cursor color/shape instead of having to look at some indicator on the mode line.
#+begin_src emacs-lisp
(general-with 'evil
  (gsetq evil-mode-line-format nil
         evil-normal-state-cursor '(box "orchid")
         evil-normal-state-cursor '(box "dark gray")
         evil-motion-state-cursor '(box "YellowGreen")
         evil-insert-state-cursor '(bar "Blue")
         evil-emacs-state-cursor '(bar "Red")
         evil-visual-state-cursor '(box "#F86155")))
#+end_src

**** Undo Granularity
#+begin_src emacs-lisp
;; insert is one change, even if use <left>, <right>, etc.

;; the problem with `evil-want-fine-undo' non-nil is that a lot of things that
;; end up being just self-insertion become undo points (e.g. `lispy-space')
;; (gsetq evil-want-fine-undo t)
#+end_src

*** Advice
#+begin_src emacs-lisp
(general-with 'evil
  ;; TODO move this stuff to some dedicated non-package-specific heading; no
  ;; need to load after evil
  (defun noct-nop-kill-new (orig-func &rest args)
    "Run ORIG-FUNC with ARGS preventing any `kill-new's from running."
    ;; http://endlessparentheses.com/understanding-letf-and-how-it-replaces-flet.html
    (cl-letf (((symbol-function 'kill-new) #'ignore))
      (apply orig-func args)))

  ;; don't copy for C-w/C-<backspace> or visually selected text
  (general-add-advice '(backward-kill-word
                        evil-visual-paste
                        evil-delete-backward-word
                        lispyville-delete-backward-word)
                      :around #'noct-nop-kill-new))
#+end_src

*** Remaps
**** General Swaps/Changes
#+begin_src emacs-lisp
(general-with 'evil
  ;; make home and end act on visual lines
  ;; also note `evil-respect-visual-line-mode'
  ;; don't know if I like the changes to d, p, y, and it seems they need work:
  ;; https://github.com/emacs-evil/evil/issues/188
  (general-def '(insert normal)
    "<home>" #'evil-beginning-of-visual-line
    "<end>" #'evil-end-of-visual-line)

  (defun noct-evil-insert-visual-line (count &optional vcount)
    (interactive "p")
    (let ((evil-respect-visual-line-mode t))
      (evil-insert-line count vcount)))

  (general-def 'normal "I" #'noct-evil-insert-visual-line)

  (defun noct-evil-append-visual-line (count &optional vcount)
    (interactive "p")
    (let ((evil-respect-visual-line-mode t))
      (evil-append-line count vcount)))

  (defun noct-evil-insert-at-last-change ()
    "Insert at the last change."
    (interactive)
    (evil-goto-mark ?.)
    (evil-append 1))

  (general-def 'normal
    "gI" #'noct-evil-insert-at-last-change
    ;; just "@q" won't work in insert state (if recorded in insert state), but
    ;; that doesn't seem efficient
    "Q" "@q"
    "t." #'evil-ex-repeat
    "tv" #'evil-visual-block
    ;; swap a and A
    "a" #'noct-evil-append-visual-line
    "A" #'evil-append)

  (general-def 'motion ";" nil)
  (general-def 'normal
    ";" #'evil-ex)
  (general-r ";" #'evil-repeat-find-char)

  (defun noct-norm@q ()
    "Apply macro in q register on selected lines."
    (interactive)
    (evil-ex-normal (region-beginning) (region-end) "@q"))

  ;; comparable to "xnoremap Q :norm @q<cr>" in vim
  (general-def 'visual "Q" #'noct-norm@q)

  ;; since using m as prefix
  (general-def 'normal "M" #'evil-set-marker)

  ;; exit emacs state with ESC (in GUI emacs)
  (general-def 'emacs "<escape>" #'evil-normal-state)

  ;; change xall
  (evil-ex-define-cmd "xa[ll]" #'save-buffers-kill-terminal))

;; camelCase word (not a remap but affects word keybindings)
(global-subword-mode)
(blackout 'subword-mode)
#+end_src

**** Colemak Swaps
#+begin_src emacs-lisp
(once-with 'evil
  ;; dead
  ;; (evil-redirect-digit-argument evil-motion-state-map
  ;;                               "0" #'evil-beginning-of-visual-line)

  ;; swap visual and real line movement commands
  (general-def 'motion
    "n" #'evil-next-visual-line
    "e" #'evil-previous-visual-line
    "^" #'evil-first-non-blank-of-visual-line
    "$" #'evil-end-of-visual-line
    "gn" #'evil-next-line
    "ge" #'evil-previous-line
    "g0" #'evil-beginning-of-line
    "g$" #'evil-end-of-line
    "g^" #'evil-first-non-black)

  ;; add back lost keys
  (general-def 'motion
    "j" #'evil-forward-word-end
    "gj" #'evil-backward-WORD-end
    "k" #'evil-ex-search-next
    "K" #'evil-ex-search-previous
    "gk" #'evil-next-match)

  ;; l for "[l]ast"
  (general-def 'motion
    "l" #'evil-jump-backward
    "L" #'evil-jump-forward)

  (defun noct-evil-line-advice (oldfun &rest args)
    "Set a jump point for numbered line jumps (>1 line)."
    (let ((old-pos (point)))
      (apply oldfun args)
      (when (> (abs (- (line-number-at-pos old-pos)
                       (line-number-at-pos (point))))
               1)
        (save-excursion
          (goto-char old-pos)
          (evil-set-jump)))))

  (general-advice-add '(evil-next-line
                        evil-previous-line
                        evil-next-visual-line
                        evil-previous-visual-line)
                      :around #'noct-evil-line-advice))
#+end_src

**** Escape Everywhere
Escape should be bound to ~keyboard-quit~ or ~keyboard-escape-quit~ in various minibuffer keymaps.
#+begin_src emacs-lisp
(general-def :keymaps noct-minibuffer-maps
  "<escape>" #'keyboard-escape-quit)
#+end_src

*** Repeat in Visual State
https://github.com/emacs-evil/evil/issues/742
#+begin_src emacs-lisp
(general-with 'evil
  ;; make v, V, and C-v start recording
  (evil-set-command-property 'evil-visual-char :repeat t)
  (evil-set-command-property 'evil-visual-line :repeat t)
  (evil-set-command-property 'evil-visual-block :repeat t)

  (defun noct-evil-repeat-motion (flag)
    "Repeation for motions. Motions are recorded by keystroke but only in insert state."
    ;; also record motions in visual state
    (when (memq evil-state '(insert replace visual))
      (evil-repeat-keystrokes flag)))
  (general-add-advice 'evil-repeat-motion :override #'noct-evil-repeat-motion)

  (defun noct-evil-repeat-start ()
    "Start recording a new repeat into `evil-repeat-info'."
    ;; don't stop recording in visual state
    (unless (evil-visual-state-p)
      (evil-repeat-reset t)
      (evil-repeat-record-buffer)))
  (general-add-advice 'evil-repeat-start :override #'noct-evil-repeat-start)

  (defun noct-evil-repeat-stop ()
    "Stop recording a repeat.
Update `evil-repeat-ring' with the accumulated changes
in `evil-repeat-info' and clear variables."
    ;; don't stop recording in visual state
    (unless (evil-visual-state-p)
      (unwind-protect
          (when (and (evil-repeat-recording-p))
            (setq evil-repeat-info
                  (evil-normalize-repeat-info evil-repeat-info))
            (when (and evil-repeat-info evil-repeat-ring)
              (ring-insert evil-repeat-ring evil-repeat-info)))
        (evil-repeat-reset nil))))

  (general-add-advice 'evil-repeat-stop :override #'noct-evil-repeat-stop))
#+end_src

** elpaca Keybindings
#+begin_src emacs-lisp
(defun noct-elpaca-lock ()
  (interactive)
  (elpaca-write-lock-file
   (expand-file-name "elpaca/elpaca-lock" user-emacs-directory)))

(general-s "P" #'elpaca-manager)
(general-s "L" #'elpaca-log)
(general-s :infix "s"
  "l" #'elpaca-log
  ;; completing read for package
  "i" #'elpaca-info
  ;; try for session
  "u" #'elpaca-try
  "p" #'elpaca-update
  ;; update recipe repositories equivalent
  "P" #'elpaca-update-menus
  "a" #'elpaca-update-all
  "r" #'elpaca-rebuild
  "v" #'elpaca-visit
  "b" #'elpaca-browse
  ;; https://github.com/progfolio/elpaca/issues/24#issuecomment-2629569714
  ;; https://github.com/progfolio/elpaca/issues/447
  "L" #'noct-elpaca-lock)
(general-with-package 'evil-collection
  (general-add-hook 'elpaca-ui-mode-hook #'evil-normalize-keymaps)
  ;; p - pull, u - unmark, r -rebuild, x - execute, s - search, etc.
  ;; ~/src/forks/evil-collection/modes/elpaca/evil-collection-elpaca.el
  (evil-collection-init 'elpaca))

(noct-handle-popup-same-window "*elpaca-info*")
#+end_src

** Hydra
I generally avoid =:exit t= hydras; =which-key= is automatic and good enough already. I've removed a lot of my hydras. I am planning on adding more back when I get a chance, but I probably won't use ~defhydra~ during initialization.
#+begin_src emacs-lisp
(use-package hydra
  :config
  (gsetq hydra-is-helpful t
         ;; prevents message from disappearing
         hydra-lv t))
#+end_src

** Other Constants
#+begin_src emacs-lisp
(defun noct-mode-line-height ()
  "Return the height to use for the mode line.
This should be run in a graphical frame."
  ;; 35 on 4k
  (round (* 0.00911458333333333 (noct-default-monitor-width))))

(defun noct-smaller-mode-line-height ()
  "Return the height to use for a smaller mode line.
This should be run in a graphical frame."
  ;; 30 on 4k
  (round (* 0.0078125 (noct-default-monitor-width))))
#+end_src

* Basic and Builtin Functionality
** General Settings
#+begin_src emacs-lisp
;; split horizontally on right (i.e. split line going from top to bottom)
;; http://stackoverflow.com/questions/2081577/setting-emacs-split-to-horizontal
(gsetq split-height-threshold nil
       split-width-threshold 0)

(gsetq
 ;; like scrolloff in vim
 scroll-margin 5
 ;; recenter the point if it goes >20 lines past what is visible
 ;; the default (0) is kind of annyoying because it recenters even if you just
 ;; go one line down from the window bottom, but a higher value is nice to
 ;; automatically recenter after any bigger jump
 scroll-conservatively 20
 ;; scroll-preserve-screen-position t
 )

;; default; was previously using as nil
(gsetq sentence-end-double-space t)

;; don't ask; follow symlinks to file under version control
(gsetq find-file-visit-truename t
       vc-follow-symlinks t)

;; put path before buffer name when uniquifying a buffer (instead of after)
(gsetq uniquify-buffer-name-style 'forward)

;; use system trash for file deletion (includes dired and backups)
(gsetq delete-by-moving-to-trash t)

;; quickly display current incomplete keystrokes in echo area
(gsetq echo-keystrokes 0.1)

;; save clipboard to kill ring before replacing
(gsetq save-interprogram-paste-before-kill t)

;; a lot of unix tools expect this; it's required for the crontab, for example
(gsetq require-final-newline t)

;; new in emacs 26; kill running processes without confirmation on Emacs exit
(gsetq confirm-kill-processes nil)

;; I don't use bidirectional text; improves speed for long lines (even when no
;; bidirectional text)
(gsetq bidi-inhibit-bpa t)
(gsetq-default bidi-display-reordering 'left-to-right
               bidi-paragraph-direction 'left-to-right)

;; NOTE it is pretty much never necessary to set these; Emacs sets them
;; correctly based on platform already
;; (terminal-coding-system) already defaults to utf-8-unix (linux)
;; (set-terminal-coding-system 'utf-8)
;; (keyboard-coding-system) already defaults to utf-8-unix (linux)
;; (set-keyboard-coding-system 'utf-8)
;; same for `default-file-name-coding-system'
;; (set-file-name-coding-system 'utf-8)
;; this is mainly just a combination of the past three
;; (prefer-coding-system 'utf-8)

;; defaults to "English"
;; (set-language-environment 'utf-8)

;; increase number of messages
(gsetq message-log-max 10000)

(gsetq kill-do-not-save-duplicates t)

(gsetq adaptive-fill-mode t)
#+end_src

** General Keybindings
#+begin_src emacs-lisp
;; allow binding <C-i> differently from tab
(noct-elpaca-after-init
  (general-def input-decode-map
    "C-i" [C-i]
    "C-m" [C-m]))

;; worse keybinding but sometimes I use on OSX
(general-def "C-v" #'yank)

(general-def
  "C-y" #'yank
  "M-y" #'yank-pop)

(general-def '(normal visual)
  ":" #'eval-expression)

(general-def '(insert normal)
  "C-;" #'eval-expression)

(general-t ";" #'execute-extended-command)

(general-spc "F" #'find-file)
#+end_src

** Appearance/GUI
*** Settings
#+begin_src emacs-lisp
(gsetq x-gtk-use-system-tooltips nil
       pos-tip-internal-border-width (noct-border-width))

;; looks better
(gsetq x-underline-at-descent-line t)

;; https://github.com/baskerville/bspwm/issues/551#issuecomment-574975395
;; https://github.com/d12frosted/homebrew-emacs-plus#emacs-28-and-emacs-27
(gsetq window-resize-pixelwise t
       frame-resize-pixelwise t)

;; https://github.com/hlissner/doom-emacs/blob/01aadd8900be45f912124d9d815d8790f540d38c/core/core.el#L177
(setq idle-update-delay 1)

;; https://github.com/hlissner/doom-emacs/blob/01aadd8900be45f912124d9d815d8790f540d38c/core/core.el#L228
;; "Reduce rendering/line scan work for Emacs by not rendering cursors or
;; regions in non-focused windows."
(gsetq-default cursor-in-non-selected-windows nil)
(gsetq highlight-nonselected-windows nil)

;; "More performant rapid scrolling over unfontified regions. May cause brief
;; spells of inaccurate fontification immediately after scrolling."
(gsetq fast-but-imprecise-scrolling t)
#+end_src

*** Font
#+begin_src emacs-lisp
;; no
;; - iosevka - don't need a thin font (and a lot taller than others)
;; - 3270 - medium looks horrible; narrow is better but not favorite
;; - anonymous pro - not terrible but don't particularly like
;; - daddytimemono - a little too weird
;; - gohu - looks like a bitmap font; awful
;; - heavy data - completely unreadable garbage
;; - lekton - meh
;; - monofur - nice but a little too weird
;; - monoid - meh
;; - m+ - too tall (is this monospace...? messes up alignment)
;; - open dyslexic - too weird (is this monospace...? messes up alignment)
;; - overpass - meh (does not look monospaced...? messes up alignment)
;; - proggy - blurry
;; - source code pro - office code pro looks much better to me
;; - share tech mono
;; - space mono - don't like parens, and it's really wide
;; - tinos - monospace version is broken?
;; - aurulent - parens too weird
;; - ProFontWindows - slightly too weird (may change mind)
;; - VictorMono - don't like parens; quite tall
;; - recursive - monospaced version is messed up

;; untried
;; - recursive - couldn't get working properly
;; - input mono
;; - monaco
;; - cmu typewriter
;; - pt mono
;; - lucida console
;; - julia mono
;; - comic mono

(defconst noct-fine-fonts
  (list "BlexMono Nerd Font-11"
        "Hack Nerd Font-11"
        "iMWritingMonoS Nerd Font-11"
        ;; "iMWritingDuoS Nerd Font-11"
        ;; first used fonts
        "Inconsolata Nerd Font-12"
        "InconsolataGo Nerd Font-12"
        "InconsolataLGC Nerd Font-10"
        "LiterationMono Nerd Font-11"
        "MesloLGS Nerd Font-11"
        ;; taller; don't like as much
        ;; "MesloLGL Nerd Font-11"
        "Migu 1M-12"
        "NotoMono Nerd Font-11"
        "RobotoMono Nerd Font-10"
        "TerminessTTF Nerd Font-12"
        "DroidSansMono Nerd Font-10"
        ;; not too far off from droid sans; like slightly better
        "Cousine Nerd Font-11"
        ;; like better than both cousine and droid sans
        "DejaVu Sans Mono-11"
        ;; cool asterisk but otherwise don't love it
        "GoMono Nerd Font-10"
        "BitstreamVeraSansMono Nerd Font-10")
  "Fonts that are fine but don't stand out to me.")

(defconst noct-good-fonts
  (list "FantasqueSansMono Nerd Font-12"
        "Hurmit Nerd Font-10"
        "mononoki Nerd Font-12"
        ;; fira fonts are former favorites but no italics
        ;; "Fira Mono-10"
        "FiraCode Nerd Font-10"
        "CodeNewRoman Nerd Font-11"
        ;; nice but pretty plain
        "JetBrainsMono Nerd Font-11"
        ;; solid font
        "Ubuntu Mono-12"
        ;; weird but not too weird; really like but doesn't have italics
        "agave Nerd Font-12")
  "Good fonts.")

(defconst noct-favorite-fonts
  (list "Delugia-10"
        ;; okay but I much prefer office code pro
        ;; "SauceCodePro Nerd Font-10"
        "Office Code Pro D-10")
  "My favorite fonts.
The difference from `noct-preferred-fonts' is that there are no
duplicates/fallback variants included here.")

(defun noct-set-font (&optional font)
  "Set the font."
  (interactive)
  (let* ((fonts (unless font
                  (cl-remove-if-not
                   (lambda (font) (find-font (font-spec :name font)))
                   (append noct-favorite-fonts noct-good-fonts))))
         (font (or font (completing-read "Font:" fonts))))
    (when font
      ;; `set-face-attribute' has more convenient syntax than `set-frame-font'
      (set-face-attribute 'default nil :font font))))

(general-s "f" #'noct-set-font)

;; this is slow on the first run even if set only one font (0.01-0.05 seconds)
;; (noct-set-font ...)
;; instead set the default frame font in ./early-init.el

;; https://www.djcbsoftware.nl/code/mu/mu4e/Fancy-characters.html#Fancy-characters
(use-package unicode-fonts
  :disabled t
  :init
  ;; TODO somewhat slow; worth it?
  ;; TODO when running when starting the server, ends up invalidating the cache and
  ;; doing everything again
  (noct-after-gui
    (unicode-fonts-setup)))
#+end_src

*** Ligature
I avoided ligatures for a long time, but at this point, I don't see a reason to avoid them.  I'm not going to use =prettify-symbols-mode= to prettify lambda as a single character, and I never use most of these symbols, but some of them look pretty nice without getting in the way (e.g. elisp comments: =;;=, double colon, www, ellipsis, etc.).  These don't affect editing like prettifying lambda to a single character does.
#+begin_src emacs-lisp
(use-package ligature
  :defer-incrementally t
  :config
  (ligature-set-ligatures t '("www" "..."))

  ;; enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))

  ;; only use ligature for 2 semicolons (unfortunately there is not one for 3/4
  ;; in any font I've seen)
  (ligature-set-ligatures
   noct-lisp-modes
   '((";" (rx (* ";")))))

  ;; enable all Cascadia Code ligatures in programming modes
  (ligature-set-ligatures
   'prog-mode
   '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
     ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
     "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
     "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
     "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
     "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
     "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
     "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
     ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
     "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
     "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
     "?=" "?." "??"  ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
     "\\\\" "://"))

  (global-ligature-mode t))
#+end_src

** Auth Source
#+begin_src emacs-lisp
(general-with-package 'auth-source
  ;; use encrypted authinfo file by default
  (gsetq auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc"))
  (when (featurep 'noct-info)
    ;; use asymmetric encryption for authinfo.gpg
    (gsetq auth-source-gpg-encrypt-to (list user-mail-address))))
#+end_src

** Auto Compression
Automatically uncompress (for editing) and recompress (when saving) compressed files (e.g. =.gz= files).
#+begin_src emacs-lisp
(noct-use (:no-install jka-compr-hook)
  (auto-compression-mode))
#+end_src

** Auto Revert
#+begin_src emacs-lisp
(blackout 'auto-revert-mode)
#+end_src

** Auto Saving
#+begin_src emacs-lisp
(gsetq auto-save-interval 30
       auto-save-timeout 5
       ;; don't create auto-save ~ files
       auto-save-default nil)

(auto-save-visited-mode)

(defun noct-save ()
  "If in a file buffer and not executing/recording a macro, save."
  (when (and (or (buffer-file-name)
                 (bound-and-true-p org-src-source-file-name))
             (not (or executing-kbd-macro defining-kbd-macro)))
    (noct-silently
      (save-buffer))))

(defun noct-toggle-save-on-insert-exit ()
  "Enable or disable saving on insert state exit."
  (interactive)
  (if (and (boundp 'evil-insert-state-exit-hook)
           (memq #'noct-save evil-insert-state-exit-hook ))
      (general-remove-hook 'evil-insert-state-exit-hook #'noct-save)
    (general-add-hook 'evil-insert-state-exit-hook #'noct-save)))

;; not for now
;; (noct-toggle-save-on-insert-exit)

(general-def noct-toggle-map "S" #'noct-toggle-save-on-insert-exit)

(general-def "C-s" #'save-buffer)
#+end_src

** Backup
#+begin_src emacs-lisp
(defun noct-backup-predicate (file)
  "Return whether to backup FILE.
Don't backup remote directories or encrypted files."
  (not (or (file-remote-p file)
           (string-match-p (car epa-file-handler) file))))

(gsetq backup-enable-predicate #'noct-backup-predicate
       ;; don't delink hardlinks
       backup-by-copying t
       ;; add version numbers to backups
       version-control t
       ;; automatically delete old versions
       delete-old-versions t
       kept-new-versions 30
       kept-old-versions 20
       ;; backup files under version control too
       vc-make-backup-files t)
#+end_src

** Bookmarks
#+begin_src emacs-lisp
(general-s
  "M" #'bookmark-set
  "'" #'bookmark-jump)
#+end_src

** Disabling Defaults
#+begin_src emacs-lisp
;; disable startup messages
(gsetq inhibit-startup-message t
       ;; ...
       ;; inhibit-startup-echo-area-message (user-login-name)
       inhibit-splash-screen t)

(general-add-advice 'startup-echo-area-message :override #'ignore)

;; don't flash screen (e.g. when at end of buffer and use `evil-next-line')
;; this is the default
;; (gsetq visible-bell nil)

;; no tool bar, scroll bar, or menu
;; NOTE these combined add 0.2~0.3 seconds to init according to
;; `emacs-init-time' and `profile-dotemacs'; it is now possible to prevent them
;; ever displaying in ~/.emacs.d/early-init.el
;; https://github.com/raxod502/radian/issues/180
;; (tool-bar-mode -1)
;; (scroll-bar-mode -1)
;; (menu-bar-mode -1)

;; no tooltip popups (use echo area instead)
(tooltip-mode -1)

;; don't blink cursor (infuriating)
(blink-cursor-mode -1)
#+end_src

** EPG
Use Emacs for pinentry where possible (pinentry.el is no longer needed).
#+begin_src emacs-lisp
;; TODO why doesn't this work for SSH key passphrase? (SSH_AUTH_SOCK is set
;; correctly in Emacs)
;; TODO allow retries like other pinentry methods
(gsetq epg-pinentry-mode 'loopback)
#+end_src

** Executable
#+begin_src emacs-lisp
;; insert "/usr/bin/env interpreter" for shebangs
(gsetq executable-prefix-env t)
#+end_src

** Fill Column
Also see [[#whitespace][Whitespace Mode]].
#+begin_src emacs-lisp
(gsetq-default fill-column 80)
#+end_src

** Garbage Collection
Testing.
#+begin_src emacs-lisp
(use-package gcmh
  :ghook ('pre-command-hook nil nil nil t)
  :config
  ;; settings used by doom; default infinite threshold causes Emacs to
  ;; completely freeze after working for a while; maybe this will be better
  (gsetq gcmh-idle-delay 10
         gcmh-high-cons-threshold 16777216)
  (general-add-hook 'focus-out-hook #'gcmh-idle-garbage-collect))
#+end_src

** History/Savehist
Persist minibuffer and search history.
#+begin_src emacs-lisp
(gsetq kill-ring-max 300)

(gsetq history-length 3000
       history-delete-duplicates t)

(use-package savehist
  :ensure nil
  :defer-incrementally custom
  :init
  ;; this and :defer-incrementally is how doom loads it
  ;; using `post-command-hook' is enough to trigger for `evil-ex',
  ;; `eval-expression', etc.
  (general-add-hook 'post-command-hook
                    (lambda () (require 'savehist))
                    nil nil t)
  :config
  ;; default
  ;; savehist-save-minibuffer-history t
  (gsetq savehist-additional-variables '(mark-ring
                                         global-mark-ring
                                         search-ring
                                         regexp-search-ring
                                         extended-command-history)
         savehist-autosave-interval 60)

  (savehist-mode))
#+end_src

** H Prefix/Help Mode
Some keys in =help-mode-map= that are worth noting:
- =P=: ~describe-package~
- =S=: ~info-lookup-symbol~
- =b=: ~describe-bindings~
- =e=: ~view-echo-area-messages~ (pulls up messages buffer)
- =l=: ~view-lossage~
- =r=: ~info-emacs-manual~
- =s=: ~describe-syntax~
- =n=: ~view-emacs-news~

Obvious ones:
- =f=: ~describe-function~
- =i=: ~info-mode~
- =k=: ~describe-key~
- =m=: ~describe-mode~
- =v=: ~describe-variable~

#+begin_src emacs-lisp
(general-with-package 'help
  (general-def help-map
    ;; swap c and C
    "c" #'describe-coding-system
    "C" #'describe-key-briefly
    ;; [p]ackage
    "p" #'apropos-library
    ;; very useful (binding over `view-lossage')
    "l" #'find-library
    "h" #'find-function
    "V" #'find-variable
    "e" #'elisp-index-search)

  (general-def 'normal help-mode-map
    "q" #'quit-window
    "ESC" #'quit-window)

  (noct-handle-popup help-mode))
#+end_src

** Indentation
#+begin_src emacs-lisp
;; don't use tabs for indenting by default
(gsetq-default indent-tabs-mode nil
               tab-width 4)
#+end_src

** Minibuffer
#+begin_src emacs-lisp
(gsetq enable-recursive-minibuffers t)

(minibuffer-depth-indicate-mode)

;; don't allow moving the cursor left into the minibuffer promt
;; https://github.com/hlissner/doom-emacs/blob/01aadd8900be45f912124d9d815d8790f540d38c/core/core-ui.el#L368
(gsetq minibuffer-prompt-properties
       '(read-only t face minibuffer-prompt intangible t cursor-intangible t))
(general-add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

;; https://www.reddit.com/r/emacs/comments/4d8gvt/how_do_i_automatically_close_the_minibuffer_after/
(defun helper:kill-minibuffer ()
  "Exit the minibuffer if it is active."
  (when (and (>= (recursion-depth) 1)
             (active-minibuffer-window))
    (abort-recursive-edit)))

(general-add-hook 'mouse-leave-buffer-hook #'helper:kill-minibuffer)

;; equality checks don't work (or are run too soon)
;; TODO finds some way to tell if the minibuffer is the selected window
;; (defun noct-kill-minibuffer ()
;;   "Kill the minibuffer if it is not the active window."
;;   (unless (and (>= (recursion-depth) 1)
;;                (or (not (windowp (active-minibuffer-window)))
;;                    (equal (active-minibuffer-window)
;;                           (selected-window))
;;                    (minibuffer-window-active-p (selected-window))))
;;     (abort-recursive-edit)))
;; (add-hook 'window-configuration-change-hook #'noct-kill-minibuffer)
#+end_src

** Native Compilation
#+begin_src emacs-lisp
;; don't continuously popup warning buffer
(gsetq native-comp-async-report-warnings-errors nil)
#+end_src

** OSX
#+begin_src emacs-lisp
(when (eq system-type 'darwin)
  ;; use command as control
  (gsetq mac-command-modifier 'control
         mac-option-modifier 'meta)
  ;; fix home and end
  (general-def
    "<home>" #'evil-beginning-of-visual-line
    "<end>" #'evil-end-of-visual-line))
#+end_src

** Path Configuration (exec-path-from-shell)
#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :defer-incrementally t
  :config
  ;; make `exec-path' match shell path in GUI Emacs
  ;; this is mainly useful on OSX, e.g. to get poetry in `exec-path' for
  ;; poetry.el
  (when (memq window-system '(mac ns x))
    (gsetq exec-path-from-shell-shell-name "bash"
           exec-path-from-shell-arguments '("-l"))
    (general-pushnew "LSP_USE_PLISTS" exec-path-from-shell-variables)
    (general-pushnew "HATCH_ENV_TYPE_VIRTUAL_PATH"
                     exec-path-from-shell-variables)
    ;; takes about 0.1s
    (exec-path-from-shell-initialize)))
#+end_src

** Profiling
#+begin_src emacs-lisp
(noct-use (:no-install profiler)
  (general-s
    "C-p" #'profiler-start
    "C-r" #'profiler-report
    "C-s" #'profiler-stop))

(noct-use ( :elpaca explain-pause-mode
            :host github
            :repo "lastquestion/explain-pause-mode")
  (general-def noct-toggle-map "e" #'explain-pause-mode))
#+end_src

** Recentf
#+begin_src emacs-lisp
;; ivy also automatically enables recentf-mode
(use-package recentf
  :ensure nil
  :defer-incrementally (easymenu tree-widget timer)
  :init
  (general-add-advice '(after-find-file consult-buffer)
                      :before
                      (lambda (&rest _)
                        (recentf-mode))
                      nil
                      t)
  :config
  (gsetq recentf-max-saved-items 1000)

  (defun doom--recent-file-truename (file)
    (if (or (file-remote-p file nil t)
            (not (file-remote-p file)))
        (file-truename file)
      file))

  ;; settings from doom
  (setq recentf-filename-handlers
        '(;; Text properties inflate the size of recentf's files, and there is
          ;; no purpose in persisting them, so we strip them out.
          substring-no-properties
          ;; Resolve symlinks of local files. Otherwise we get duplicate
          ;; entries opening symlinks.
          doom--recent-file-truename
          ;; Replace $HOME with ~, which is more portable, and reduces how much
          ;; horizontal space the recentf listing uses to list recent files.
          abbreviate-file-name)
        recentf-auto-cleanup 'never)
  (general-add-hook 'kill-emacs-hook #'recentf-cleanup)
  (general-add-hook
   '(on-switch-window-hook write-file-functions)
   (progn (defun doom--recentf-touch-buffer-h ()
            "Bump file in recent file list when it is switched or written to."
            (when buffer-file-name
              (recentf-add-file buffer-file-name))
            ;; Return nil for `write-file-functions'
            nil)
          #'doom--recentf-touch-buffer-h))

  (general-add-advice 'recentf-load-list :around #'noct-silence-advice)

  ;; I haven't had many issues with unwanted files getting in the way
  ;; https://www.reddit.com/r/emacs/comments/3g468d/stop_recent_files_showing_elpa_packages/
  ;; (gsetq recentf-exclude '("^/var/folders\\.*" "COMMIT_EDITMSG\\'" ".*-autoloads\\.el\\'" "[/\\]\\.elpa/" ))

  ;; save recent after 10 seconds of idle time
  ;; if not idle, save every 5 minutes
  (noct-run-at-active-interval (* 5 60) 10
    (noct-silently
      (when recentf-mode
        (recentf-save-list)))))
#+end_src

** Repeat Mode
#+begin_src emacs-lisp
;; TODO make it shut up when starting
(noct-use (:no-install repeat)
  (:once 'pre-command-hook))
#+end_src

** Reload
 #+begin_src emacs-lisp
(noct-use
    (:elpaca reload :host github :repo "progfolio/reload.el"))
 #+end_src

** Reveal
#+begin_src emacs-lisp
;; TODO once-buffer
(use-package reveal
  :ensure nil
  :init
  (noct-after-buffer (global-reveal-mode)))
#+end_src

** Save Place
#+begin_src emacs-lisp
(noct-after-buffer
  (save-place-mode)
  ;; save history after 10 seconds of idle time
  ;; if not idle, save every 5 minutes
  (noct-run-at-active-interval (* 5 60) 10
    (noct-silently
      (when save-place-mode
        (save-place-kill-emacs-hook)))))
#+end_src

** So Long
#+begin_src emacs-lisp
(use-package so-long
  :general (noct-toggle-map "s" #'so-long-mode)
  ;; :once #'after-find-file
  :init
  (general-add-advice 'after-find-file
                      :before
                      (lambda (&rest _)
                        (global-so-long-mode))
                      nil t))
#+end_src

** Scratch Buffer
Suggested [[https://www.reddit.com/r/emacs/comments/4agorq/got_bored_of_the_initial_scratch_message_so/][here]].
#+begin_src emacs-lisp
;; put fortune in scratch buffer
(defun noct-cached-fortune ()
  "Return a cached fortune message."
  (prog1 (when (file-exists-p "~/.cache/fortune")
           (with-temp-buffer
             (insert-file-contents "~/.cache/fortune")
             (delete-trailing-whitespace)
             (buffer-string)))
    ;; generate a new message for next time
    (start-process-shell-command
     "new-fortune"
     nil
     (concat "cowthink -b -W 77 \"$(fortune lambda)\""
             " | sed 's/^/;; /'"
             "  > ~/.cache/fortune"))))

(gsetq initial-scratch-message (noct-cached-fortune))

;; improve startup time (packages enabled for emacs-lisp-mode not
;; loaded immediately)
(gsetq initial-major-mode 'fundamental-mode)

(use-package persistent-scratch
  :general (general-comma "S" #'noct-goto-scratch)
  :config
  (gsetq persistent-scratch-autosave-interval 60)

  (defun noct-goto-scratch ()
    "Open the scratch buffer and set it up if it hasn't been set up.
Enable `persistent-scratch-auto-save-mode' and `emacs-lisp-mode'."
    (interactive)
    (switch-to-buffer "*scratch*")
    (unless persistent-scratch-autosave-mode
      (persistent-scratch-setup-default)
      (emacs-lisp-mode)
      (run-hooks 'noct-elisp-scratch-hook))))
#+end_src

** Sudo Editing
This configuration allows automatically editing root owned files (as opposed to opening them in read only mode). Alternatively, if you usually edit root files from the terminal, emacsclient works fine with sudoedit.

I've switched away from putting this function in a hook because it can be jarring and because there are some situations where I only want to read these files.
#+begin_src emacs-lisp
;; function modified from comment here:
;; http://emacsredux.com/blog/2013/04/21/edit-files-as-root/
;; Additionally:
;; - Support file creation
;; - Support remote connection
;; - Support dired
;; TODO test with remote files again (lost some changes)
(defun noct-maybe-sudo-edit ()
  "If the current file is exists and is unwritable, edit it as root with sudo."
  (interactive)
  (let* ((file (or buffer-file-name
                   (when (derived-mode-p 'dired-mode 'wdired-mode)
                     default-directory)))
         (parent (file-name-directory file))
         ;; don't try to lookup password with auth-source
         auth-sources)
    (when (and file
               (not (file-writable-p file))
               (or (file-exists-p file)
                   ;; might want to create a file
                   (and (file-exists-p parent)
                        (not (file-writable-p parent))))
               ;; don't want to edit Emacs source files as root
               (not (string-match "/usr/share/emacs/.*" file)))
      (let ((method (file-remote-p default-directory 'method))
            (user (file-remote-p default-directory 'user))
            (host (file-remote-p default-directory 'host))
            (localname (file-remote-p file 'localname)))
        (find-file (if method
                       (concat "/" method ":" user "@" host
                               "|sudo:" host ":" localname)
                     (concat "/sudo:root@localhost:" file)))))))

;; [S]u[d]o or [S]udo e[d]it
(general-s "d" #'noct-maybe-sudo-edit)
#+end_src

** Tabulated List Mode and Tablist Mode
#+begin_src emacs-lisp
(noct-use (:no-install tabulated-list)
  (:config
    (general-def 'normal tabulated-list-mode-map
      "o" #'tabulated-list-sort
      "w" #'tabulated-list-next-column
      "b" #'tabulated-list-previous-column)))

;; for mpdel, for example
(use-package tablist
  :ghook ('tabulated-list-mode-hook #'tablist-minor-mode)
  :config
  (general-def 'normal tablist-minor-mode-map
    ;; "s" #'tablist-edit-filter
    "g/" tablist-mode-filter-map
    "," #'tablist-mark-forward)

  (defun noct-tablist-mark-toggle ()
    "Toggle marking the tablist entry on the current line."
    (interactive)
    (let ((marked-re (tablist-marker-regexp))
          (not-marked-re
           (let ((tablist-marker-char ?\s))
             (tablist-marker-regexp))))
      (save-excursion
        (beginning-of-line)
        (cond
         ((looking-at marked-re)
          (tablist-unmark-backward -1))
         ((looking-at not-marked-re)
          (tablist-put-mark))))))

  (defun noct-tablist-marks-toggle (&optional arg interactive)
    "Toggle marking ARG entries forward.

ARG is interpreted as a prefix-arg.  If interactive is non-nil,
maybe use the active region instead of ARG.

See `tablist-put-mark' for how entries are marked."
    (interactive (list current-prefix-arg t))
    (cond
     ;; Mark files in the active region.
     ((and interactive (use-region-p))
      (save-excursion
        ;; store end first because moving point can change region-end with evil
        ;; at least
        (let ((end  (save-excursion
                      (goto-char (region-end))
                      (beginning-of-line)
                      (point))))
          (goto-char (region-beginning))
          (beginning-of-line)
          (tablist-repeat-over-lines
           (1+ (count-lines
                (point)
                end))
           #'noct-tablist-mark-toggle))))
     ;; Mark the current (or next ARG) files.
     (t
      (tablist-repeat-over-lines
       (prefix-numeric-value arg)
       #'noct-tablist-mark-toggle))))

  (general-def '(normal visual) tablist-minor-mode-map
    "," #'noct-tablist-marks-toggle))

(use-package navigel
  :config
  (general-def 'normal navigel-tablist-mode-map
    "h" #'navigel-open-parent))
#+end_src

** Text Scaling Keybindings | Textsize
#+begin_src emacs-lisp
;; (general-def 'normal
;;   "C-=" #'text-scale-increase
;;   "C--" #'text-scale-decrease)

;; change text scale everywhere
(use-package default-text-scale
  :disabled t
  :general
  ('normal
   "C-=" #'default-text-scale-increase
   "C--" #'default-text-scale-decrease))

;; automatically change text size everywhere based on resolution (e.g. to get
;; same size on different sized monitors)
(use-package textsize
  :general
  ('normal
   "C--" #'textsize-decrement
   "C-+" #'textsize-increment
   "C-=" #'textsize-reset)
  :init
  (general-after-gui
    (gsetq textsize-default-points 10)
    (textsize-mode)))
#+end_src

** Toggle Settings Keybindings
#+begin_src emacs-lisp
(general-def
  :prefix-command 'noct-toggle
  :prefix-map 'noct-toggle-map
  "d" #'toggle-debug-on-error
  "q" #'toggle-debug-on-quit
  "R" #'read-only-mode
  "A" #'auto-fill-mode
  "t" #'toggle-truncate-lines)

(general-t "o" #'noct-toggle)
#+end_src

** TRAMP
#+begin_src emacs-lisp
;; NOTE remote backups disabled in backup section
;; backing up locally instead with `backup-each-save'
;; https://www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html
(gsetq vc-ignore-dir-regexp (format "\\(%s\\)\\|\\(%s\\)"
                                    vc-ignore-dir-regexp
                                    tramp-file-name-regexp))
#+end_src

** Undo Granularity
#+begin_src emacs-lisp
(noct-add-undo-bounds 'yank)
(noct-add-undo-bounds 'fill-paragraph)
#+end_src

** Which Function Mode
#+begin_src emacs-lisp
;; show current function (or heading) name in modeline
(which-function-mode)
#+end_src

* Completion, Selection, and Matching/Sorting
** Affe
#+begin_src emacs-lisp
(use-package affe
  :general
  (general-spc "?" #'affe-grep)
  :config
  (require 'orderless)
  (defun affe-orderless-regexp-compiler (input _type _ignorecase)
    (setq input (cdr (orderless-compile input)))
    (cons input (apply-partially #'orderless--highlight input t)))
  (gsetq affe-regexp-function #'affe-orderless-regexp-compiler
         affe-highlight-function #'orderless--highlight
         affe-grep-command (concat "rg "
                                   "--null "
                                   "--color=never "
                                   "--max-columns=1000 "
                                   "--no-heading "
                                   "--line-number "
                                   "-v ^$ "
                                   ;; adding these to default
                                   "--hidden "
                                   "--max-columns-preview "
                                   ;; defaults
                                   ".")))
#+end_src

** Avy
#+begin_src emacs-lisp
(use-package avy
  :config
  (gsetq avy-keys '(?a ?r ?s ?t ?d ?h ?o ?w ?f ?p ?l ?u ?y ?x ?c ?, ?. ?n ?e ?i)
         avy-all-windows nil
         ;; decrease timeout
         avy-timeout-seconds 0.2)

  (general-def '(normal insert)
    "C-." #'avy-resume)

  (general-r "." #'avy-resume)

  (general-after 'evil
    (evil-define-motion noct-goto-char-timer-or-swiper-isearch (_count)
      :type inclusive
      :jump t
      :repat abort
      (evil-without-repeat
        (evil-enclose-avy-for-motion
          (when (eq (avy-goto-char-timer) t)
            (let ((swiper-goto-start-of-match (not evil-this-operator)))
              (swiper-isearch avy-text))))))

    (general-r "/" #'noct-goto-char-timer-or-swiper-isearch)

    (general-add-advice 'avy-resume :after #'evil-normal-state)))
#+end_src

** Capf Autosuggest
#+begin_src emacs-lisp
(use-package capf-autosuggest
  :ghook
  'comint-mode-hook
  'eshell-mode-hook)
#+end_src

** Company
*** Setup
#+begin_src emacs-lisp
(use-package company
  :disabled t
  :ghook
  ('comint-mode-hook (noct-disable company-mode))
  ('eshell-mode-hook (noct-disable company-mode))
  :general
  (general-def noct-toggle-map "c" #'company-mode)
  :init
  ;; (noct-pre-command-or-post-file
  ;;   (global-company-mode))
  (noct-post-insert-and-writable
    (global-company-mode))
  :blackout t
  :config
  (general-def '(company-active-map company-search-map)
    "M-n" nil)
  ;; setting idle delay too low can cause a lot of lag depending on the backend
  (gsetq company-idle-delay 0.15
         company-minimum-prefix-length 1
         ;; company-tooltip-limit 15
         ;; e.g.for yasnippet annotations
         ;; company-tooltip-align-annotations t
         company-show-quick-access t
         company-quick-access-keys '("a" "r" "s" "t" "d" "h" "n" "e" "i" "o")
         company-abort-on-unique-match nil
         ;; more space between icon and completion text
         company-icon-margin 3)

  (general-add-hook 'evil-normal-state-entry-hook
                    (noct-defun doom-company-abort-h ()
                      (when company-candidates
                        (company-abort))))

  (defun trishume:company-backend-with-yas (backends)
    "Add :with company-yasnippet to company BACKENDS.
Taken from https://github.com/syl20bnr/spacemacs/pull/179."
    (if (and (listp backends) (memq 'company-yasnippet backends))
        backends
      (append (if (consp backends)
                  backends
                (list backends))
              '(:with company-yasnippet))))

  ;; add yasnippet to all backends
  (gsetq company-backends
         (mapcar #'trishume:company-backend-with-yas company-backends))

  ;; no longer using tab
  ;; tab more similar to vim (tab tabs through completions)
  ;; (require 'company-tng)
  ;; (company-tng-configure-default)

  (general-def company-active-map
    ;; don't take over these keys
    "C-h" nil
    "C-w" nil
    ;; only use quick access keys
    [return] nil
    "RET" nil
    [tab] nil
    "TAB" nil
    "<down>" nil
    "<up>" nil)

  ;; can use for snippet expansion (if take too long to hit tab; shouldn't
  ;; happen normally)
  (general-def company-active-map
    :predicate '(company-explicit-action-p)
    "RET" #'company-complete))
#+end_src

*** Company in Minibuffer
#+begin_src emacs-lisp :tangle no
;; https://github.com/company-mode/company-mode/issues/42
;; modified from https://gist.github.com/Bad-ptr/7787596
;; TODO needs work
;; also would be nice to setup `eval-expression' in childframe
(general-with-package 'company
  (defvar noct-eval-expression-commands
    (list
     ;; #'execute-extended-command
     #'eval-expression
     #'eldoc-eval-expression)
    "Commands for evaluating emacs lisp in the minibuffer.")

  (defvar company-minibuffer-mode)

  (defun company-elisp-minibuffer (command &optional arg &rest ignored)
    "`company-mode' completion back-end for Emacs Lisp in the minibuffer."
    (interactive (list 'interactive))
    (cl-case command
      ('prefix (and (minibufferp)
                    (cl-case company-minibuffer-mode
                      ('execute-extended-command (company-grab-symbol))
                      (t (company-capf `prefix)))))
      ('candidates
       (cl-case company-minibuffer-mode
         ('execute-extended-command (all-completions arg obarray 'commandp))
         (t nil)))))

  (defun minibuffer-company ()
    (unless company-mode
      (when (and global-company-mode (memq this-command noct-eval-expression-commands))

        (setq-local company-minibuffer-mode this-command)

        (setq-local completion-at-point-functions
                    (list (if (fboundp 'elisp-completion-at-point)
                              #'elisp-completion-at-point
                            #'lisp-completion-at-point) t))

        (setq-local company-backends '((company-elisp-minibuffer company-capf)))

        (company-mode 1)

        (when (eq this-command #'execute-extended-command)
          (company-complete)))))

  (general-add-hook 'minibuffer-setup-hook #'minibuffer-company))
#+end_src

*** Org Mode Fix
https://github.com/company-mode/company-mode/issues/50
#+begin_src emacs-lisp
(general-with-package 'company
  ;; something is removing this for some reason
  (general-pushnew #'org-self-insert-command company-begin-commands))
#+end_src

*** Company Try Hard
I haven't run into a case yet where I would need this but am leaving this placeholder for now.

*** Company Box (child frame frontend)
Looks nice and replaces =company-quickhelp= as well. The default company frontend is faster though.
#+begin_src emacs-lisp
(use-package company-box
  ;; :ghook 'company-mode-hook
  :general
  (general-def noct-toggle-map "b" #'company-box-mode)
  :blackout t
  :config
  (gsetq company-box-icons-alist 'company-box-icons-all-the-icons))
#+end_src

*** Company Posframe (child frame frontend)
#+begin_src emacs-lisp
(use-package company-posframe
  :ghook 'company-mode-hook
  :blackout t
  :config
  ;; disable automatic quickhelp
  (gsetq company-posframe-quickhelp-delay nil)
  (general-def noct-toggle-map "C" #'company-posframe-mode))
#+end_src

** Corfu
#+begin_src emacs-lisp
(noct-use corfu-prescient
  (:require-once "corfu")
  (:config
    (opt corfu-prescient-enable-filtering nil)
    (corfu-prescient-mode)))

(noct-use ( :elpaca corfu
            ;; include extensions
            :files (:defaults "extensions/*.el"))
  (noct-post-insert-and-writable
    (global-corfu-mode))
  (general-def noct-toggle-map "F" #'corfu-mode)
  (:config
    (gsetq global-corfu-minibuffer
           (lambda ()
             (and (not (or (bound-and-true-p mct--active)
                           (bound-and-true-p vertico--input)
                           (eq (current-local-map) read-passwd-map)))
                  (where-is-internal #'completion-at-point
                                     (list (current-local-map))))))
    (gsetq corfu-auto t
           corfu-auto-delay 0.15
           corfu-auto-prefix 1
           corfu-bar-width 0.3)

    (defun corfu-move-to-minibuffer ()
      (interactive)
      (pcase completion-in-region--data
        (`(,beg ,end ,table ,pred ,extras)
         (let ((completion-extra-properties extras)
               completion-cycle-threshold completion-cycling)
           (consult-completion-in-region beg end table pred)))))
    (add-to-list 'corfu-continue-commands #'corfu-move-to-minibuffer)

    (general-def corfu-map
      "M-SPC" #'corfu-insert-separator
      ;; explicit selection only for now
      "RET" nil
      "<down>" nil
      "<up>" nil)
    ;; to override vertico C-m mapping
    (general-def 'insert corfu-map "<C-M>" #'corfu-move-to-minibuffer)

    ;; doesn't have a `company-quick-access-keys' equivalent
    (corfu-indexed-mode)
    (gsetq corfu-indexed-start 1)

    (set-face-attribute 'corfu-indexed nil :height 1.0)
    (when (bound-and-true-p ewal-base-palette)
      (set-face-attribute 'corfu-indexed nil :background
                          (ewal-get-color 'background))
      (set-face-attribute 'corfu-indexed nil :foreground
                          (ewal-get-color 'blue))
      (set-face-attribute 'corfu-border nil :background
                          (ewal-get-color 'yellow))
      (set-face-attribute 'corfu-bar nil :background
                          (ewal-get-color 'cursor)))

    (defmacro noct-generate-corfu-select-index (index)
      "Return a named function to run `corfu-complete' for INDEX"
      `(noct-defun ,(intern (format "noct-corfu-complete-%s" index)) ()
         ,(format "Call `corfu-complete' for index %s." index)
         (interactive)
         (let ((corfu--index ,index))
           (corfu-complete))))

    (general-def corfu-map
      "M-a" (noct-generate-corfu-select-index 0)
      "M-r" (noct-generate-corfu-select-index 1)
      "M-s" (noct-generate-corfu-select-index 2)
      "M-t" (noct-generate-corfu-select-index 3)
      "M-d" (noct-generate-corfu-select-index 4)
      "M-h" (noct-generate-corfu-select-index 5)
      "M-n" (noct-generate-corfu-select-index 6)
      "M-e" (noct-generate-corfu-select-index 7)
      "M-i" (noct-generate-corfu-select-index 8)
      "M-o" (noct-generate-corfu-select-index 9))

    ;; don't require multiple escape presses to exit minibuffer
    (general-def :keymaps noct-minibuffer-maps
      "<escape>" (noct-defun corfu-quit-minibuffer ()
                   "`escape-quit-minibuffer' but quit corfu if active."
                   (interactive)
                   (when (and (boundp 'corfu--frame)
                              (frame-live-p corfu--frame))
                     (corfu-quit))
                   (keyboard-escape-quit)))

    ;; sort by recency (but not frecency)
    (corfu-history-mode)
    (general-with 'savehist
      (general-pushnew 'corfu-history savehist-additional-variables))

    ;; looks cool but not that useful; don't normally need docs during completion;
    ;; potentially more distracting than beneficial, but the default delay makes
    ;; it not an issue
    (general-add-hook 'corfu-mode-hook #'corfu-popupinfo-mode)))

(noct-use kind-icon
  (:require-once "corfu")
  (:config
    (gsetq kind-icon-default-face 'corfu-default)
    (general-pushnew #'kind-icon-margin-formatter corfu-margin-formatters)))
#+end_src

** Pcompl Args
[[https://github.com/minad/corfu#completing-with-corfu-in-the-eshell-or-shell][Corfu with Eshell and Shell]]
#+begin_src emacs-lisp
(use-package pcmpl-args
  :after pcomplete
  :demand t)
#+end_src

** Cape
TODO add cape-history
#+begin_src emacs-lisp
;; TODO something makes company unusable... should only be used with corfu?

;; 10446  77% - ...
;; 9014  66%  - company-capf
;; 9014  66%   - cond
;; 9014  66%    - let
;; 9014  66%     - let
;; 9014  66%      - company--capf-data
;; 9014  66%       - let
;; 9014  66%        - if
;; 9014  66%         - let
;; 9014  66%          - company--capf-data-real
;; 9014  66%           - let*
;; 9014  66%            - unwind-protect
;; 9014  66%             - progn
;; 9014  66%              - let
;; 9014  66%               - let
;; 9014  66%                - run-hook-wrapped
;; 9014  66%                 - company--capf-wrapper
;; 9013  66%                  - let
;; 9013  66%                   - catch
;; 9012  66%                    - condition-case
;; 9011  66%                     - completion--capf-wrapper
;; 9011  66%                      - apply
;; 9011  66%                       - corfu--capf-wrapper-advice
;; 9011  66%                        - #<subr completion--capf-wrapper>
;; 9008  66%                         - #<compiled 0x66df05b22cbc4d8>
;; 9008  66%                          - complete-with-action
;; 9008  66%                           - #<compiled 0xe9c51c93b2eb44c>
;; 9008  66%                            - cape--dabbrev-list
;; 9007  66%                             - dabbrev--find-all-expansions
;; 8973  66%                              - dabbrev--find-expansion
;; 8924  66%                               - dabbrev--try-find
;; 7689  56%                                - dabbrev--search
;; 3   0%                                   dabbrev--goto-start-of-abbrev

(use-package cape
  :init
  ;; (general-pushnew #'cape-file completion-at-point-functions)
  ;; (general-pushnew #'cape-dabbrev completion-at-point-functions)

  ;; company adapter examples
  ;; (setq-local completion-at-point-functions
  ;;             (mapcar #'cape-company-to-capf
  ;;                     (list #'company-files
  ;;                           #'company-ispell
  ;;                           #'company-dabbrev)))
  ;; (setq completion-at-point-functions
  ;;       (list
  ;;        (cape-company-to-capf
  ;;         (apply-partially #'company--multi-backend-adapter
  ;;                          '(company-dabbrev company-elisp)))))
  )
#+end_src

** Completion
#+begin_src emacs-lisp
(gsetq completion-ignore-case t)
#+end_src

** FLX
Helper library for fuzzy matching/finding (used by ivy, for example).
#+begin_src emacs-lisp
(use-package flx
  :disabled t)
#+end_src

** Frog Menu
TODO don't delete old window/mess up things
#+begin_src emacs-lisp
(use-package frog-menu
  :ensure (:host github :repo "clemera/frog-menu")
  :config
  (general-after 'avy
    (gsetq frog-menu-avy-keys avy-keys))
  (general-after-gui
    (gsetq frog-menu-posframe-border-width (noct-border-width)))
  ;; readable background color
  (set-face-background 'frog-menu-posframe-background-face "black")
  ;; for now don't use posframe
  (gsetq frog-menu-type-function (lambda () 'avy-side-window))
  ;; show at top instead of bottom
  (gsetq frog-menu-display-option-alist
         '((avy-posframe . noct-posframe-poshandler-frame-near-top-center)
           (avy-side-window . (noct-display-buffer-in-side-window-no-header
                               (side . top))))))
#+end_src

** Helm
TODO Try more helm.
*** Setup
#+begin_src emacs-lisp
(use-package helm
  :config
  ;; altered helm-mini (similar to helm-for-files)
  (gsetq helm-mini-default-sources
         '(helm-source-buffers-list
           helm-source-recentf
           helm-source-files-in-current-dir
           helm-source-locate
           helm-source-buffer-not-found))

  ;; can always cancel out of fuzzy with a space
  (gsetq helm-buffers-fuzzy-matching t
         helm-recentf-fuzzy-match t
         helm-locate-fuzzy-match t
         helm-semantic-fuzzy-match t
         helm-imenu-fuzzy-match t)

  ;; settings for helm-find-files
  (gsetq helm-ff-search-library-in-sexp t
         helm-ff-file-name-history-use-recentf t
         helm-ff-skip-boring-files t)

  (general-def 'helm-map
    "<tab>" #'helm-execute-persistent-action)

  (helm-autoresize-mode))

;; Filtering:
;; - ^<text> (to start with)
;; - *<major mode>, e.g. *dired or *!dired
;; - /<dir> or !/<dir>
;; @<text> for filtering by buffer contents

;; ./ to reach default dir quickly; ~/ for home or / for root or ../ for back
#+end_src

*** Helm FLX
#+begin_src emacs-lisp
(use-package helm-flx
  :after helm
  :demand t
  :config
  (helm-flx-mode))
#+end_src

*** Helm Posframe
#+begin_src emacs-lisp
(use-package helm-posframe
  :disabled t
  :after helm
  :demand t
  :config
  (gsetq helm-posframe-poshandler
         #'noct-posframe-poshandler-frame-near-top-center)
  ;; TODO no border setting currently; make issue
  ;; (when (display-graphic-p)
  ;;   (gsetq helm-posframe-border-width (round (* 0.001 (x-display-pixel-width)))
  ;;          ;; this is in columns (i.e. character width) not pixels
  ;;          helm-posframe-width 120))
  (helm-posframe-enable))
#+end_src

** Headlong
Select candidate as soon as there is only one (like the headlong package but for ivy and vertico). This is used for cases where you know there is a correct match in the candidates and there aren't too many candidates. Right now, I'm using it mainly for dired (like ranger's =f=), but this could be used elsewhere.
#+begin_src emacs-lisp
;; TODO consider making a PR with a better implementation
(defvar noct-ivy-command nil)
(defvar noct-ivy-major-mode nil)

(defun noct-set-ivy-info (&rest _)
  (setq noct-ivy-command this-command
        noct-ivy-major-mode major-mode))

(general-add-advice 'ivy-read :before #'noct-set-ivy-info)

(defun noct-wait-for-user (seconds)
  "Wait for user to stop typing for SECONDS."
  (while (not (sit-for seconds t))
    (discard-input)))

(defun noct-premature-select ()
  (cond ((or (and (memq noct-ivy-command '(counsel-find-file dired-goto-file))
                  (memq noct-ivy-major-mode '(ranger-mode dired-mode)))
             (eq noct-ivy-command #'projectile-find-test-file))
         (cond ((= ivy--length 0)
                (backward-delete-char-untabify 1))
               ((= ivy--length 1)
                (noct-wait-for-user 0.2)
                (ignore-errors (ivy-done)))))))

(general-add-advice 'ivy--exhibit :after #'noct-premature-select)

;; (defvar noct-block-input nil)
;; (defun noct-maybe-block-input ()
;;   (when noct-block-input
;;     (setq noct-block-input nil)
;;     (sleep-for 2)
;;     (discard-input)))

;; (general-add-hook 'post-command-hook #'noct-maybe-block-input)


(defvar noct-vertico-command nil)
(defvar noct-vertico-major-mode nil)
(defun noct-set-vertico-info (&rest _)
  (setq noct-vertico-command this-command
        noct-vertico-major-mode major-mode))
(general-add-advice 'completing-read-default :before #'noct-set-vertico-info)

(defvar vertico--total)
(declare-function vertico-exit "vertico")
(defun noct-vertico-premature-select (&rest _)
  (cond ((or (and (memq current-minibuffer-command '(find-file
                                                     dired-goto-file))
                  (memq noct-vertico-major-mode '(ranger-mode dired-mode)))
             (eq noct-vertico-command #'projectile-find-test-file))
         (cond
          ;; this will actually mess things up; require manually going back
          ;; ((= vertico--total 0)
          ;;  (call-interactively #'evil-delete-backward-char))
          ((= vertico--total 1)
           (noct-wait-for-user 0.2)
           (ignore-errors (vertico-exit)))))))

(general-add-advice 'vertico--update :after #'noct-vertico-premature-select)
#+end_src

** Ivy
*** Setup
#+begin_src emacs-lisp
(use-package ivy
  :blackout t
  :config
  (gsetq ivy-height 25
         ivy-wrap t
         ;; wait for user to stop typing for this long before refreshing dynamic
         ;; collections
         ivy-dynamic-exhibit-delay-ms 50
         ivy-use-selectable-prompt t
         ivy-count-format "%d/%d "
         ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’
         ivy-use-virtual-buffers t
         ivy-virtual-abbreviate 'full)

  ;; ivy-sort-functions-alist
  ;; ivy-initial-inputs-alist

  (general-def ivy-minibuffer-map
    "<escape>" #'minibuffer-keyboard-quit
    "<next>" #'ivy-scroll-up-command
    "<prior>" #'ivy-scroll-down-command
    "C-e" #'previous-history-element
    "C-n" #'next-history-element
    "M-a" #'ivy-avy
    "M-d" #'ivy-dispatching-done
    "M-c" #'ivy-occur)

  (ivy-set-actions
   t
   `(("h" (lambda (x) (helpful-command (intern x))) "helpful")
     (,(kbd "RET") xref-find-definitions "follow")
     ("f" xref-find-definitions "follow"))))

;; TODO bind for more functions (e.g. not locate)
;; "<up>" #'ivy-previous-line-and-call
;; "<down>" #'ivy-next-line-and-call

;; TODO consider adding better keybindings for these:
;; ivy-call
;; ivy-dispatching-call
#+end_src

*** Ivy Occur
TODO evil bindings stop working after wgrep finish edit
#+begin_src emacs-lisp
(general-with-package 'ivy
  (general-def 'normal '(ivy-occur-mode-map ivy-occur-grep-mode-map)
    "n" #'ivy-occur-next-line
    "e" #'ivy-occur-previous-line
    "w" #'ivy-wgrep-change-to-wgrep-mode
    "RET" #'ivy-occur-press-and-switch
    ;; TODO ivy-occur-revert-buffer
    ;; ivy-occur-press
    "a" #'ivy-occur-read-action
    "o" #'ivy-occur-dispatch
    "c" #'ivy-occur-toggle-calling
    "d" #'ivy-occur-delete-candidate)

  (noct-handle-window ivy-occur-grep-mode
    '(display-buffer-same-window)))
#+end_src

*** Ivy Hydra
#+begin_src emacs-lisp
(use-package ivy-hydra
  :after ivy
  :demand t
  :config
  (general-def hydra-ivy/keymap
    "j" nil
    "k" nil
    "n" #'hydra-ivy/ivy-next-line
    "e" #'hydra-ivy/ivy-previous-line
    "<escape>" #'hydra-ivy/keyboard-escape-quit-and-exit))
#+end_src

*** Ivy Rich
#+begin_src emacs-lisp
(use-package ivy-rich
  ;; requires counsel when enabling `ivy-rich-mode'
  :after counsel
  :demand t
  :config
  ;; default `ivy-switch-buffer' is good enough; remove transformer before
  ;; enabling `ivy-rich-mode'
  (cl-remf ivy-rich-display-transformers-list 'ivy-switch-buffer)
  (ivy-rich-mode))
#+end_src

*** Ivy Posframe
#+begin_src emacs-lisp
(use-package ivy-posframe
  :disabled t
  :after ivy
  :init
  (general-after-gui
    (ivy-posframe-mode))
  (general-def noct-toggle-map "p" #'ivy-posframe-mode)
  :blackout t
  :config
  (gsetq ivy-posframe-border-width (noct-border-width)
         ;; prevent resizing as type (may need to adjust these)
         ivy-posframe-min-width 150
         ivy-posframe-width 150
         ivy-posframe-height 30
         ivy-posframe-min-height 30)

  ;; default border color
  (custom-set-faces
   '(internal-border ((t (:weight bold
                          :background "#FFFFFF")))))

  ;; TODO posframe currently requires this naming
  (defun ivy-posframe-display-at-frame-top-center (str)
    (ivy-posframe--display
     str
     #'noct-posframe-poshandler-frame-near-top-center))

  (setf (alist-get t ivy-posframe-display-functions-alist)
        #'ivy-posframe-display-at-frame-top-center)

  ;; still put swiper(-isearch) in minibuffer so buffer is visible
  ;; `counsel-fzf' because there is a ton of input if use posfame
  (dolist (cmd '(counsel-fzf
                 counsel-grep
                 lsp-find-references
                 swiper
                 swiper-isearch
                 ivy-xref-show-xrefs))
    (general-pushnew (list cmd)
                     ivy-posframe-display-functions-alist
                     :test 'equal)))
#+end_src

*** Ivy All the Icons
Add icons to ivy/counsel commands.
#+begin_src emacs-lisp
(use-package all-the-icons-ivy
  :init
  (general-after-gui
    (general-after 'ivy
      (all-the-icons-ivy-setup)))
  :config
  (general-after 'counsel-projectile
    (let ((all-the-icons-ivy-file-commands
           '(counsel-projectile
             counsel-projectile-find-file
             counsel-projectile-find-dir)))
      (all-the-icons-ivy-setup))))
#+end_src

*** Dynamically Switch Between Matching Methods
Unlike helm, ivy can't automatically do fuzzy and space as =.*= matching at the same time (see [[https://github.com/abo-abo/swiper/issues/360][this issue]]). Here is an expiremental hack for automatically switching between the two. I am not currently using this (not tangled).
#+begin_src emacs-lisp :tangle no
(general-with-package 'ivy
  ;; dosen't work
  ;; (defun ivy--regex-fuzzy-ignore-space (oldfun str)
  ;;   (funcall oldfun (replace-regexp-in-string " " "" str)))

  ;; (general-add-advice 'ivy--regex-fuzzy :around #'ivy--regex-fuzzy-ignore-space)

  (defvar noct--initial-ivy-regex-function nil)

  (defun noct-ivy-space-switch-to-regex ()
    (interactive)
    (unless (eq ivy--regex-function 'ivy--regex-ignore-order)
      (setq ivy--old-re nil)
      (setq noct--initial-ivy-regex-function ivy--regex-function)
      (setq ivy--regex-function 'ivy--regex-ignore-order))
    (self-insert-command 1))

  (general-def ivy-minibuffer-map
    "SPC" #'noct-ivy-space-switch-to-regex)

  (defun noct-ivy-maybe-reset-regex-function ()
    (interactive)
    (when (active-minibuffer-window)
      (let ((input (replace-regexp-in-string "\n.*" "" (minibuffer-contents))))
        (when (and noct--initial-ivy-regex-function
                   (not (string-match " " input)))
          (setq ivy--old-re nil)
          (setq ivy--regex-function noct--initial-ivy-regex-function)
          (setq noct--initial-ivy-regex-function nil)))))

  (general-add-advice '(ivy-backward-delete-char
                        ivy-delete-char)
                      :after #'noct-ivy-maybe-reset-regex-function))
#+end_src

*** Counsel
#+begin_src emacs-lisp
(use-package counsel
  :general
  ;; (general-t
  ;;   ;; looks nicer than helm-show-kill-ring to me
  ;;   ;; sticking with over `consult-yank' since it supports showing multi-line
  ;;   ;; text
  ;;   "p" #'counsel-yank-pop)

  ;; (general-def help-map "a" #'counsel-apropos)

  ;; (general-spc "y" #'counsel-semantic-or-imenu)

  ((insert normal) "C-:" #'counsel-minibuffer-history)

  ;; extra counsel/[i]vy commands
  (general-s :infix "i"
    "a" #'counsel-linux-app
    "o" #'counsel-outline
    "i" #'counsel-imenu
    "v" #'counsel-set-variable
    "p" #'counsel-list-processes
    "b" #'counsel-descbinds
    "d" #'counsel-dash
    ;; "l" #'counsel-load-theme
    "u" #'counsel-unicode-char
    "g" #'counsel-git-log
    "s" #'counsel-git-stash)

  ;; replace `company-search'
  (general-def company-active-map
    "C-s" #'counsel-company)

  :blackout t
  :config
  (general-after 'helpful
    ;; using this instead of binding them directly allows taking an alternate
    ;; action without also opening the helpful buffer
    (gsetq counsel-describe-function-function #'helpful-callable
           counsel-describe-variable-function #'helpful-variable)))
#+end_src

*** Counsel Buku
This is a really basic ~counsel-buku~. =buku_run= has various issues for me. I may use rofi in the future or may stick with this (see sxhkdrc for binding).
#+begin_src emacs-lisp
(defun counsel-buku-action (cand)
  "Run \"buku --open\" on CAND."
  (let ((db-index (car (split-string cand "\t"))))
    (counsel--run "buku" "--open" db-index)))

(defun counsel-buku ()
  "Open a buku bookmark."
  (interactive)
  (counsel-require-program "buku")
  (let ((cands
         (split-string
          (shell-command-to-string "buku --print --format 5")
          "\n" t)))
    (ivy-read "open bookmark: " cands
              :action #'counsel-buku-action
              :caller 'counsel-buku)))
#+end_src

** Orderless
One notable difference between using orderless (or prescient) and some older fuzzy matchers/plugins is that space does not act as =.*=.  Spaces (by default) separate components, all of which must match.  You can still use space the same way as before (type different parts of a file path separated by space, for example), but now order does not matter.  This allows you to refine your query as needed without having to delete and re-enter a more specific query.

Unlike traditional fuzzy matchers (e.g. flx, fzf, etc.), =orderless= does no sorting/scoring.  This means you can't do something like rank initials as a better match than characters in the middle of the word for a fuzzy query.  However, sorting this way takes extra time, and I've never really liked fuzzy matching.  When I used to use fuzzy matching fzf, I never knew what to type.  I ended up just typing fragments or initials and not actually using fuzzy queries.  Initials and fragments as queries are just easier for me to construct than randomly picking or excluding letters.  Scoring on top of orderless would be a slight improvement (e.g. score a fragment that matches the beginning of a word higher than something in the middle), but scoring would be an improvement, but since you get a comparably small number of garbage results when not using fuzzy matching, orderless without fuzzy matching doesn't really need scoring to be useful.

Combined with frecency sorting, initialism is good enough for me.  Initialism is incredible for completing file paths, heading names, and function/variable names (~describe-variable~, ~describe-function~, ~find-function~, ~find-library~, company, etc.).  With prescient or orderless, if the initialism doesn't get the candidate you want in sight, you can just hit space and add another query (regexp, fuzzy, or whatever you want) to further refine.  As soon as the candidate is visible, you can use a keybinding to select it based on its index (or with something like ~ivy-avy~ or ~selectrum-quick-select~).

Of course, initialism isn't great for everything, but I've found it's often still possible to quickly create queries that are more specific than fuzzy queries but still short.  For example, if I want to pull up a help buffer for a variable in =orderless= but don't remember the specific name, I can start by limiting the query to variables prefixed with =orderless=.  Instead of typing that out exactly, I can get a good approximation by typing something like =o,s= (still undecided on best syntax; might use =o..s=) to match words that start with =o= and end with =s=.  For commands like ~describe-function~, I normally use ~orderless-strict-leading-initialism~ since I always type the first initial first.  I'm relaxing this to ~orderless-strict-initialism~ for queries after the second, so I could type something like =o,s cs= to match =orderless-component-separator=.

This can also work well for other query types where initialism is fairly useless (e.g. text search), and you can always add multiple full word queries as needed.

Even simpler is to just mash out words or partial words separated by spaces (more precise than fuzzy) in cases where initialism or orderless-prefixes can't be used.  Again, if you can't quickly construct a query, then it doesn't matter how great the matching is.  Dumb queries can often get you the result you want faster.

I'm keeping fuzzy out of my default styles, but I've configured things so that I can switch to it if needed by prefixing a query with =f;= or suffixing a query with =;f=.  If you want fuzzy matching, orderless may not be the best choice though.  I've found it can get slow quickly once queries get longer.  I wrote more thoughts on fuzzy matching in [[https://old.reddit.com/r/emacs/comments/v4rq3p/fussy_a_completionstylefuzzy_matchingscoring/ibf5yu8/][this conversation with the author of fussy]].  I did try out fussy then, but at that time the performance was just too noticeably slow for me to try it out for long.

=orderless= is infinitely customizable, so you can choose better default query styles for different commands.  If you wanted, you could remove initialism from ~swiper-isearch~ completely, for example.  I'm still experimenting with how restrictive I can make things without harming usability (e.g. can I remove ~orderless-regexp~ entirely as a default style for the first component for commands like ~describe-function~?).  So far it seems like I don't need to go this far, and I don't need any sorting/ranking to get amazing matching.
#+begin_src emacs-lisp
(use-package orderless
  :init
  (defun orderless--strict-*-initialism (component &optional anchored)
    "Match a COMPONENT as a strict initialism, optionally ANCHORED.
The characters in COMPONENT must occur in the candidate in that
order at the beginning of subsequent words comprised of letters.
Only non-letters can be in between the words that start with the
initials.

If ANCHORED is `start' require that the first initial appear in
the first word of the candidate.  If ANCHORED is `both' require
that the first and last initials appear in the first and last
words of the candidate, respectively."
    (orderless--separated-by
     '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)))
     (cl-loop for char across component collect `(seq word-start ,char))
     (when anchored '(seq (group buffer-start) (zero-or-more (not alpha))))
     (when (eq anchored 'both)
       '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)) eol))))

  (defun orderless-strict-initialism (component)
    "Match a COMPONENT as a strict initialism.
This means the characters in COMPONENT must occur in the
candidate in that order at the beginning of subsequent words
comprised of letters.  Only non-letters can be in between the
words that start with the initials."
    (orderless--strict-*-initialism component))

  (defun orderless-strict-leading-initialism (component)
    "Match a COMPONENT as a strict initialism, anchored at start.
See `orderless-strict-initialism'.  Additionally require that the
first initial appear in the first word of the candidate."
    (orderless--strict-*-initialism component 'start))

  (defun orderless-strict-full-initialism (component)
    "Match a COMPONENT as a strict initialism, anchored at both ends.
See `orderless-strict-initialism'.  Additionally require that the
first and last initials appear in the first and last words of the
candidate, respectively."
    (orderless--strict-*-initialism component 'both))

  (gsetq completion-category-defaults nil
         ;; keep basic as fallback "to ensure that completion commands which
         ;; rely on dynamic completion tables work correctly"
         completion-styles '(orderless basic)
         ;; necessary for tramp hostname completion when using orderless
         completion-category-overrides
         '((file (styles basic partial-completion))))

  (general-with 'ivy
    (setf (alist-get t ivy-re-builders-alist)
          #'orderless-ivy-re-builder)
    ;; doesn't work with `counsel-rg'
    (setf (alist-get 'counsel-rg ivy-re-builders-alist)
          #'ivy--regex-plus))

  :config
  (defvar noct-orderless-separator "[ &]")

  ;; necessary at the time of writing for index-based rules to work
  (defun noct-split-orderless-component (str)
    (let ((components (split-string str noct-orderless-separator)))
      (when (remove "" components)
        components)))

  (gsetq orderless-matching-styles
         '(orderless-strict-initialism orderless-regexp)
         ;; & for company-capf
         ;; can just use `corfu-insert-separator' with corfu
         ;; orderless-component-separator "[ &]"
         orderless-component-separator
         #'noct-split-orderless-component)

  ;; TODO ideally should immediately refresh; right now need to type more to get
  ;; new results
  (defun noct-toggle-orderless-separator ()
    "Toggle the orderless separator."
    (interactive)
    (let ((normal-separator "[ &]")
          (allow-spaces-separator "&"))
      (if (equal noct-orderless-separator normal-separator)
          (setq noct-orderless-separator allow-spaces-separator)
        (setq noct-orderless-separator normal-separator))
      ;; TODO may not be necessary
      (gsetq orderless-component-separator
             #'noct-split-orderless-component)))

  (general-with 'vertico
    (general-def vertico-map "M-SPC" #'noct-toggle-orderless-separator))

  (defun orderless--use-completions-common-part (fn &rest args)
    (let ((orderless-match-faces [completions-common-part]))
      (apply fn args)))

  (advice-add 'company-capf--candidates
              :around #'orderless--use-completions-common-part)

  ;; style dispatchers
  (defconst noct-regexp-to-styles-alist
    `((,(rx (or (and bol "r;")
                (and bol "regexp;")))
       orderless-regexp)
      (,(rx (or (and bol "f;")
                (and ";f" eol)))
       orderless-flex))
    "Alist of regexp to list of styles to use for an orderless component.")

  (cl-defun noct-orderless-specified-styles (pattern)
    "Return a list of styles and a PATTERN without the style specifier."
    (dolist (style-specifier noct-regexp-to-styles-alist)
      (let ((re (car style-specifier))
            (styles (cdr style-specifier)))
        (when (string-match re pattern)
          (cl-return-from noct-orderless-specified-styles
            (cons styles
                  (let ((start (match-beginning 0))
                        (end (match-end 0)))
                    (concat (substring pattern 0 start)
                            (substring pattern end)))))))))

  (defun noct-orderless-style-dispatcher (pattern &rest _)
    "Set style for PATTERN if it matches `noct-regexp-to-styles-alist'."
    (noct-orderless-specified-styles pattern))

  (defconst noct-word-dispatch-pattern (rx ",")
    "Pattern to mark a full word starting/ending with the surrounding letters.")

  (defun noct-orderless-word-dispatcher (pattern &rest _)
    "Replace `noct-word-dispatch-pattern' with regexp to pass a full word.)
The character before, if there is one, is the first character in the word. The
character after, if there is one, marks the final character in the word. For
example, if `noct-dispatch-pattern' is \"..\" then \"o..s\" would match
\"orderless\"."
    (pcase-let ((`(,styles . ,styless-pattern)
                 (noct-orderless-specified-styles pattern)))
      (setq pattern (or styless-pattern pattern))
      (when (and (or (not styles) (memq 'orderless-regexp styles))
                 (string-match noct-word-dispatch-pattern pattern))
        (let* ((start (match-beginning 0))
               (end (match-end 0))
               (left-anchor (unless (= start 0)
                              (substring pattern (1- start) start)))
               (right-anchor (unless (= end (length pattern))
                               (substring pattern end (1+ end)))))
          (cons 'orderless-regexp
                (concat
                 ;; "regexp;"
                 (if left-anchor
                     (substring pattern 0 (1- start))
                   "")
                 (rx word-start)
                 (or left-anchor "")
                 (rx (0+ word))
                 (or right-anchor "")
                 (rx word-end)
                 (if right-anchor
                     (substring pattern (1+ end))
                   "")))))))

  ;; https://github.com/oantolin/emacs-config/blob/da6b98a3343d68c02af7c05153f50cc194d46888/disabled.el#L46
  (defun oantolin-not-containing-dispatcher (literal _index &rest _)
    (when (string-prefix-p "!" literal)
      (cons
       'orderless-regexp
       (rx-to-string
        `(seq
          (group string-start)
          (zero-or-more
           (or ,@(cl-loop for i from 1 below (length literal)
                          collect `(seq ,(substring literal 1 i)
                                        (or (not ,(aref literal i))
                                            string-end)))))
          string-end)))))

  (defconst noct-strict-leading-initialism-commands
    '(apropos-library
      consult-theme
      counsel-set-variable
      describe-command
      describe-face
      describe-function
      describe-keymap
      describe-package
      describe-theme
      describe-variable
      execute-extended-command
      embark-prefix-help-command
      find-function
      find-library
      helpful-callable
      helpful-symbol
      helpful-variable
      Info-goto-emacs-command-node
      info-lookup-symbol
      noct-xref-find-definition
      straight-pull-package
      straight-pull-package-and-deps
      straight-rebuild-package
      straight-use-package
      where-is
      woman)
    "Commands to use `orderless-strict-leading-initialism' for at index 0.")

  ;; TODO re-evaluate what index-based rules would be useful
  (defun noct-orderless-command-and-index-dispatcher (pattern index &rest _)
    "Change the default styles for PATTERN based on `this-command' and INDEX.
Increase strictness to `orderless-strict-leading-initialism' at index 0 for
certain commands (help commands like `describe-function' but not for
file-finding commands)."
    (when (and (= index 0)
               (memq current-minibuffer-command
                     noct-strict-leading-initialism-commands))
      (cons '(orderless-strict-leading-initialism
              ;; can remove/comment to be more strict
              orderless-regexp)
            pattern)))

  (gsetq orderless-style-dispatchers
         (list #'noct-orderless-word-dispatcher
               ;; #'noct-orderless-style-dispatcher
               #'oantolin-not-containing-dispatcher
               #'noct-orderless-command-and-index-dispatcher)))
#+end_src

** Prescient
#+begin_src emacs-lisp
(use-package prescient
  :config
  ;; increase from 100
  (gsetq prescient-history-length 500)

  ;; persist usage statistics
  (prescient-persist-mode))

(use-package company-prescient
  :after company
  :demand t
  :config
  ;; use prescient sorting for company
  (company-prescient-mode))
#+end_src

** Restricto
#+begin_src emacs-lisp
(use-package restricto
  :ensure (:host github :repo "oantolin/restricto")
  :general ( :keymaps noct-minibuffer-maps
             ;; clear prompt but limit to current candidates
             "S-<backspace>" #'restricto-narrow)
  ;; :config
  ;; necessary to use widen
  ;; (restricto-mode)
  )
#+end_src

** Vertico
I've switched to vertico due to some weird display issues with selectrum. Vertico is very simple and just works, and selectrum is now deprecated in favor of it.
#+begin_src emacs-lisp
(noct-use vertico-prescient
  (:require-once "vertico")
  (:config
    (opt vertico-prescient-enable-filtering nil)
    (vertico-prescient-mode)))

(noct-use ( :elpaca vertico
            ;; to get extensions
            :files (:defaults "extensions/*.el"))
  (:autoload 'vertico--advice)
  (define-minor-mode vertico-mode
    "VERTical Interactive COmpletion."
    :global t :group 'vertico
    (dolist (fun '(completing-read-default completing-read-multiple))
      (if vertico-mode
          (advice-add fun :around #'vertico--advice)
        (advice-remove fun #'vertico--advice))))
  (vertico-mode)
  (:config
    (opt vertico-count 10
         vertico-scroll-margin 0
         vertico-cycle t)

    (defun noct-consult-complete-symbol ()
      (interactive)
      (let ((completion-in-region-function #'consult-completion-in-region))
        (call-interactively #'complete-symbol)))
    (general-def 'insert "<C-m>" #'noct-consult-complete-symbol)

    (general-def 'normal "?" #'vertico-repeat)

    (general-add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
    (general-s
      ;; have as ?
      ;; "." #'vertico-repeat
      ;; select previous session to repeat
      "," #'vertico-repeat-select)

    ;; maybe mess with more but pretty broken; minibuffer is best
    ;; (opt vertico-buffer-display-action
    ;;        `(display-buffer-in-side-window
    ;;          (window-height . ,(+ 3 vertico-count))
    ;;          (side . top)))

    (vertico-indexed-mode)
    ;; make numbers look the same as selectrum
    (set-face-attribute 'vertico-indexed nil
                        :height 1.0
                        :inherit 'minibuffer-prompt)

    (vertico-multiform-mode)

    (defmacro noct-generate-vertico-select-index (index)
      "Return a named function to run `vertico-directory-enter' for INDEX."
      `(noct-defun ,(intern (format "noct-vertico-enter %s" index)) ()
         ,(format "Call `vertico-directory-enter' for index %s." index)
         (interactive)
         (let ((vertico--index ,index))
           (vertico-directory-enter))))

    ;; start indexing at 1
    (opt vertico-indexed-start 1)

    (general-def vertico-map
      "<prior>" #'vertico-scroll-down
      "<next>" #'vertico-scroll-up
      "C-n" #'vertico-next-group
      "M-a" (noct-generate-vertico-select-index 0)
      "M-r" (noct-generate-vertico-select-index 1)
      "M-s" (noct-generate-vertico-select-index 2)
      "M-t" (noct-generate-vertico-select-index 3)
      "M-d" (noct-generate-vertico-select-index 4)
      "M-h" (noct-generate-vertico-select-index 5)
      "M-n" (noct-generate-vertico-select-index 6)
      "M-e" (noct-generate-vertico-select-index 7)
      "M-i" (noct-generate-vertico-select-index 8)
      "M-o" (noct-generate-vertico-select-index 9))))
#+end_src

** Consult
#+begin_src emacs-lisp
(use-package consult
  :general
  (general-def
    [remap yank-pop] #'consult-yank-pop)
  (general-def 'normal
    "g/" #'consult-keep-lines)
  (general-spc
    "f" #'consult-buffer
    ;; generally `projectile-find-file' is a better option
    "k" #'noct-consult-find-fd
    "l" #'consult-locate
    "u" (list :def #'consult-outline :jump t)
    "y" (general-predicate-dispatch #'consult-imenu
          (or (eq major-mode 'org-mode)
              (bound-and-true-p poly-org-mode))
          #'consult-org-heading)
    ;; multi-buffer (of same major mode in projcet)
    "Y" #'consult-imenu-multi
    ;; works inside or outside project already
    "/" #'consult-ripgrep)
  ("C-S-y" #'consult-yank-from-kill-ring)
  (general-t "p" #'consult-yank-from-kill-ring)
  (general-s :infix "i" "l" #'consult-theme)
  (general-m "C" #'consult-compile-error)
  (help-map "a" #'consult-apropos
            "i" #'consult-info)
  ('normal "/" (list :def #'consult-line :jump t))
  :config
  ;; TODO move this somewhere else
  (gsetq org-imenu-depth 10)

  ;; drastically decrease; fontification in slow in larger org files
  (gsetq consult-fontify-max-size 250000)

  (gsetq consult-buffer-sources
         (remove 'consult--source-bookmark consult-buffer-sources)
         consult-preview-key '(:debounce 0.1 any))

  ;; Use `consult-completion-in-region' if Vertico is enabled.
  ;; Otherwise use the default `completion--in-region' function.
  (gsetq completion-in-region-function
         (noct-defun minad-completion-in-region-function (&rest args)
           (apply (if (bound-and-true-p vertico-mode)
                      #'consult-completion-in-region
                    #'completion--in-region)
                  args)))

  (general-after 'projectile
    ;; will cause `consult-ripgrep' and similar to use project root
    (gsetq consult-project-root-function #'projectile-project-root))

  (gsetq xref-show-xrefs-function #'consult-xref
         xref-show-definitions-function #'consult-xref)

  (evil-add-command-properties #'consult-imenu :jump t)
  (evil-add-command-properties #'consult-org-heading :jump t)

  (defconst noct-ripgrep-args
    (concat "rg "
            ;; defaults
            "--null "
            "--line-buffered "
            "--color=never "
            "--max-columns=1000 "
            "--path-separator / "
            "--smart-case "
            "--no-heading "
            "--with-filename "
            "--line-number "
            "--search-zip "
            ;; adding these to default
            "--hidden "
            "--max-columns-preview "
            ;; add back manually if need
            ;; "--no-ignore "
            ))
  (gsetq consult-ripgrep-args noct-ripgrep-args)

  (defun noct-consult-find-fd (&optional dir initial)
    "Run `consult-find' using fd."
    (interactive "P")
    (let ((dir (or dir
                   (ignore-errors (projectile-project-root))
                   default-directory))
          (consult-find-command
           (concat "fd --hidden --no-ignore --exclude .git --color=never "
                   "--full-path ARG OPTS")))
      (consult-find dir initial)))

  (defun noct-consult-find-ripgrep (&optional dir initial)
    "Run `consult-find' using ripgrep."
    (interactive "P")
    (let ((dir (or dir
                   (ignore-errors (projectile-project-root))
                   default-directory))
          (consult-find-command
           (concat "ripgrep"
                   noct-ripgrep-args
                   ".")))
      (consult-find dir initial)))

  (defun noct-consult-line-evil-history (&rest _)
    "Add latest `consult-line' search pattern to the evil search history ring.
This only works with orderless and for the first component of the search."
    (when (and (bound-and-true-p evil-mode)
               (eq evil-search-module 'evil-search))
      (let ((pattern (cadr (orderless-compile
                            (car consult--line-history)))))
        (add-to-history 'evil-ex-search-history pattern)
        (setq evil-ex-search-pattern (list pattern t t))
        (setq evil-ex-search-direction 'forward)
        (when evil-ex-search-persistent-highlight
          (evil-ex-search-activate-highlight evil-ex-search-pattern)))))

  (general-add-advice #'consult-line :after #'noct-consult-line-evil-history))

(use-package consult-flycheck
  :general
  (general-m "f" #'consult-flycheck))
#+end_src

** Embark
#+begin_src emacs-lisp
;; TODO bind q quit
;; already has toggle quit
;; embark-general-map
(use-package embark
  :general
  ( :keymaps noct-minibuffer-maps
    "M-x" #'embark-export
    "M-c" #'embark-act
    "C-l" #'embark-become)
  ('(normal insert) "M-c" #'embark-act)
  :config
  ;; after prefix, press `C-h' to get completing read interface for keybindings
  ;; for that prefix
  (gsetq prefix-help-command #'embark-prefix-help-command)

  (gsetq embark-cycle-key "C-n")

  (general-def embark-general-map "y" #'kill-new)

  (general-def embark-identifier-map "f" #'xref-find-definitions)

  (general-def embark-symbol-map "h" #'helpful-symbol)

  (general-def embark-command-map "h" #'helpful-command)

  (general-def embark-variable-map "h" #'helpful-variable)

  (general-def 'normal embark-collect-mode-map
    "RET" #'embark-act)

  (general-def embark-become-file+buffer-map
    "c" #'projectile-switch-project
    "l" #'consult-locate
    "f" #'noct-consult-find-fd
    "p" #'projectile-find-file-in-known-projects
    ;; probably would have used first so giving worse keybinding
    "P" #'projectile-find-file
    ;; so detected
    "b" #'consult-buffer)

  (general-def embark-become-match-map
    "r" #'consult-ripgrep)

  ;; FIXME
  (noct-handle-popup-same-window (rx
                                  (0+ any)
                                  "*Embark Actions*"))
  ;; automatically show available actions with which-key
  ;; (general-after 'which-key
  ;;   (gsetq embark-action-indicator
  ;;          (lambda (map &rest _)
  ;;            (which-key--show-keymap "Embark" map nil nil 'no-paging)
  ;;            #'which-key--hide-popup-ignore-command)
  ;;          embark-become-indicator embark-action-indicator))

  (noct-handle-popup-same-window (rx "*Embark")))


;; required to use embark and consult
;; embark automatically loads
(noct-use embark-consult
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  (:hooks 'embark-collect-mode-hook #'consult-preview-at-point-mode))
#+end_src

** Marginalia
Sets missing metadata for completions (pairs well with embark even if not using ~marginalia-mode~).

#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :ghook
  ('marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))

(use-package marginalia
  :after vertico
  :demand t
  :config
  (marginalia-mode)
  (general-pushnew '(projectile-find-file . project-file)
                   marginalia-command-categories)
  (general-pushnew '(projectile-find-file-in-known-projects . file)
                   marginalia-command-categories)
  (general-pushnew '(projectile-find-dir . file)
                   marginalia-command-categories)
  (general-pushnew '(projectile-switch-project . file)
                   marginalia-command-categories)
  (general-pushnew '(noct-projectile-switch-and-vc . file)
                   marginalia-command-categories)
  ;; needed for `projectile-find-file' after `projectile-switch-project' to work
  (general-pushnew '("Find file:" . file)
                   marginalia-prompt-categories))
#+end_src

** Wgrep
#+begin_src emacs-lisp
(use-package wgrep
  ;; necessary to create autoload
  :general
  (general-def 'normal grep-mode-map "w" #'wgrep-change-to-wgrep-mode)
  :config
  (general-def 'normal wgrep-mode-map
    "RET" #'wgrep-finish-edit))
#+end_src

* Group/Session Management/Navigation
** TODO Desktop.el
start recentf desktop-after-read-hook
#+begin_src emacs-lisp
;; TODO desktop isn't a package; this is in loaddefs
(use-package destkop
  :disabled t
  :ensure nil
  :init (desktop-save-mode)
  :config
  (gsetq desktop-restore-frames nil)

  (general-pushnew 'evil-markers-alist desktop-locals-to-save)

  (desktop-auto-save-set-timer))
#+end_src

** Navigation Quickmarks
*** Quickmark Helpers
#+begin_src emacs-lisp
(defmacro noct-find-file (filename)
  "Create and return named function to visit FILENAME."
  `(noct-defun ,(intern (format "noct-quickmark-find-%s"
                                (if (stringp filename)
                                    filename
                                  (cl-gensym)))) ()
     ,(format "Call `find-file' on %s." filename)
     (interactive)
     (find-file ,filename)))


(defun noct-goto-fuzzy (name)
  "Goto the shortest filename in the root of the project that starts with NAME.
NAME should be lowercase as the uppercase version will also be checked."
  (interactive)
  (require 'projectile nil t)
  (let* ((project-root (or (ignore-errors (projectile-project-root))
                           default-directory))
         (files (or (file-expand-wildcards (concat project-root name "*"))
                    (file-expand-wildcards (concat project-root (upcase name)
                                                   "*")))))
    (when files
      (find-file (car (sort files
                            (lambda (x y)
                              (< (length x) (length y)))))))))

(defun noct-goto-makefile ()
  (interactive)
  (noct-goto-fuzzy "makefile"))

(defun noct-goto-todo ()
  (interactive)
  (noct-goto-fuzzy "todo"))

(defun noct-goto-readme ()
  (interactive)
  (noct-goto-fuzzy "readme"))

;; `view-echo-area-messages' but in current buffer
(defun noct-goto-messages ()
  (interactive)
  (switch-to-buffer "*Messages*"))

(defun noct-goto-backtrace ()
  (interactive)
  (switch-to-buffer "*Backtrace*"))

(defun noct-goto-main ()
  "Go to the shortest filename named the same as the project root dirname.
If projectile is not installed, the current directory's name is used instead.
Globbing is used to find a matching file."
  (interactive)
  (require 'projectile nil t)
  (let ((dir-name
         (file-name-nondirectory
          (directory-file-name
           (file-name-directory
            (or (ignore-errors (projectile-project-root))
                default-directory))))))
    (noct-goto-fuzzy dir-name)))
#+end_src

*** General Quickmarks
#+begin_src emacs-lisp
(defun noct-bind-general-quickmarks (&rest _)
  (defun noct-org-jump-to-datetree-today-smart (&optional file-path)
    "Jump to today's heading or to FILE-PATH if it is not the current buffer."
    (interactive)
    (let ((target-file
           (or file-path (expand-file-name "~/ag-sys/notes/journal.org"))))
      (if (string= (buffer-file-name) target-file)
          (org-datetree-find-date-create (calendar-current-date))
        (find-file target-file))))

  (general-comma
    "a" (noct-find-file "~/ag-sys/else/arch_and_program_info.org")
    "A" (noct-find-file "~/ag-sys/else/accts.org.gpg")
    "b" (noct-find-file "~/ag-sys/else/browse.org")
    "B" (noct-find-file "~/.config/bspwm/bspwmrc")
    "c" #'noct-goto-backtrace
    "d" #'projectile-edit-dir-locals
    "e" (noct-find-file (expand-file-name "awaken.org" user-emacs-directory))
    "g" (noct-find-file "~/ag-sys/else/gaming/games.org")
    "h" (noct-find-file "~/ag-sys/notes/health.org")
    "H" (noct-find-file "~/ag-sys/notes/health.csv")
    "C-h" (noct-find-file "~/ag-sys/notes/medical_history.org")
    "i" (noct-find-file "~/ag-sys/else/interaction.org")
    "I" (noct-find-file "~/ag-sys/else/scrawl/prose/general/ideas.org")
    "j" #'noct-org-jump-to-datetree-today-smart
    "J" (noct-find-file "~/ag-sys/else/japanese/japanese.org")
    ;; pretty useful log file since most programs are started from sxhkd
    "K" (noct-defun noct-find-sxhkd-log ()
          (find-file (format "/tmp/sxhkd_%s.log" (getenv "DISPLAY"))))
    "l" (noct-find-file "~/ag-sys/notes/llm.org")
    "L" (noct-find-file "~/ag-sys/notes/life.org")
    "m" (noct-find-file "~/ag-sys/notes/mind.org")
    "M" #'noct-goto-messages
    "o" #'ff-find-other-file
    "q" (noct-find-file "~/.config/qutebrowser/config.py")
    "r" (noct-find-file "README.org")
    "R" (noct-find-file "~/.config/ranger/rc.conf")
    "t" (noct-find-file "~/ag-sys/notes/tasks.org")
    "SPC" (noct-find-file "~/ag-sys/notes/tasks.org")
    "S-SPC" (noct-find-file "~/ag-sys/notes/log.org")
    "T" (noct-find-file "~/.config/tridactyl/tridactylrc")
    "v" (noct-find-file "~/.config/mpv/history.log")
    "V" (noct-find-file "~/.config/nvim/init.vim")
    "w" (noct-find-file "~/ag-sys/else/workflow.org")
    "x" (noct-find-file "~/.bxinitrc")
    "X" (noct-find-file "/var/log/Xorg.0.log")
    "X" (noct-find-file "~/.local/share/xorg/Xorg.0.log")
    "y" (noct-find-file "~/ag-sys/else/other/skill_toys/skill_toys.org")
    "z" (noct-find-file "~/.zshrc")
    "Z" (noct-find-file "~/.zsh_history")
    "2" (noct-find-file "~/ag-sys/notes/20xx.org")))

(noct-bind-general-quickmarks)
#+end_src

*** Group-specific Quickmarks
#+begin_src emacs-lisp
;; TODO consider removing this pattern
;; [f]irst, [s]econd, [t]hird for most used files
(defun noct-bind-group-quickmarks (name &rest _)
  (pcase name
    ("emacs"
     (general-comma
       "e" (noct-find-file (expand-file-name "early-init.el" user-emacs-directory))
       "," (noct-find-file (expand-file-name "init.el" user-emacs-directory))
       "f" (noct-find-file (expand-file-name "awaken.org" user-emacs-directory))
       "s" (noct-find-file (expand-file-name "unclean.org" user-emacs-directory))
       "t" (noct-find-file (expand-file-name "todo.org" user-emacs-directory))
       "T" (noct-find-file "~/test-emacs/.emacs.d/init.el")))
    ;; "log"
    ("log"
     (general-comma
       "," (noct-find-file "~/ag-sys/notes/tasks.org")
       "f" (noct-find-file "~/ag-sys/notes/tasks.org")
       "t" (noct-find-file "~/ag-sys/notes/tasks.org")))
    ("notes"
     (general-comma
       "," (noct-find-file "~/ag-sys/notes/20xx.org")
       "f" (noct-find-file "~/ag-sys/notes/journal.org")
       "s" (noct-find-file "~/ag-sys/else/interaction.org")
       "t" (noct-find-file "~/ag-sys/notes/tasks.org")))
    ("prog"
     (general-comma
       "," #'noct-goto-main
       "r" #'noct-goto-readme
       "t" #'noct-goto-todo
       "T" #'projectile-find-test-file
       "m" #'noct-goto-makefile
       "p" (general-l
             (eww-open-file
              "~/database/library/programming/common_lisp/pcl_html/index.html"))
       "l"
       (general-l
         (eww-open-file
          "~/database/library/programming/common_lisp/minispec/html/index.html"))))
    ("config"
     (general-comma
       "," (noct-find-file "~/dotfiles/README.org")
       "r" (noct-find-file "~/dotfiles/remap/README.org")
       ;; TODO
       ;; "e" (noct-find-file "~/dotfiles/editing.org")
       "b" (noct-find-file "~/dotfiles/browsing/README.org")))
    ("blog"
     (general-comma
       ;; create post
       "," (noct-defun noct-create-blog-post ()
             (interactive)
             (find-file
              (expand-file-name
               (format "content-org/%s"
                       (read-from-minibuffer "Post file name: "))
               (getenv "BLOG"))))))
    ("wr"
     (general-comma
       "," (noct-find-file "~/ag-sys/else/scrawl/prose/notes/standards+procedure.org")
       "f" (noct-find-file "~/ag-sys/else/scrawl/prose/tr/draft.org")
       "t" (noct-find-file "~/ag-sys/else/scrawl/prose/pots/misc.org")
       "p" (noct-find-file (expand-file-name "plan.org" (projectile-project-root)))
       "w" (noct-find-file (expand-file-name "wiki.org" (projectile-project-root)))
       "m" (noct-find-file (expand-file-name "misc.org" (projectile-project-root)))
       "b" (noct-find-file (expand-file-name "bio.org" (projectile-project-root)))
       "d" (noct-find-file (expand-file-name "draft.org" (projectile-project-root)))
       "i" (noct-find-file "~/ag-sys/else/scrawl/general/ideas.org")
       "c" (noct-find-file "~/ag-sys/else/scrawl/prose/lndn/landon.org")
       "g" (noct-find-file "~/ag-sys/else/scrawl/prose/gen_misc.org")))
    ("cons"
     (general-comma
       "f" (noct-find-file "~/ag-sys/else/consume/books.org")
       "s" (noct-find-file "~/ag-sys/else/consume/nim.org")
       "t" (noct-find-file "~/ag-sys/else/consume/movies.org")
       "m" (noct-find-file "~/ag-sys/else/consume/music.org")))))
#+end_src

** Tab Bar Mode
#+begin_src emacs-lisp
(defun noct-group-setup (name &rest _)
  "Set up main groups."
  (interactive)
  (pcase name
    ;; emacs configuration
    ("emacs"
     (find-file (expand-file-name "awaken.org"  user-emacs-directory)))
    ;; org agenda/todo
    ("log"
     (find-file "~/ag-sys/notes/tasks.org"))
    ;; programming and personal notes
    ("notes"
     (find-file "~/ag-sys/notes/journal.org"))
    ;; programming projects
    ("prog"
     (find-file "~/src"))
    ;; dotfiles
    ("config"
     (find-file "~/.profile"))
    ;; blog
    ("blog"
     (find-file (getenv "BLOG")))
    ;; writing
    ("wr"
     (find-file "~/ag-sys/else/scrawl/prose/tr/draft.org"))
    ;; ebooks and more notes
    ("cons"
     (find-file "~/ag-sys/else/consume/books.org"))
    ("mail"
     (mu4e))
    ("music"
     (mingus))))

(defun noct-tab-select (name)
  "`tab-bar-switch-to-tab' but with extra setup."
  (let ((tab-index (tab-bar--tab-index-by-name name)))
    (if tab-index
        (tab-bar-select-tab (1+ tab-index))
      (tab-bar-new-tab)
      (tab-bar-rename-tab name)
      (noct-group-setup name)))
  (noct-bind-general-quickmarks)
  (noct-bind-group-quickmarks name))

(gsetq tab-bar-show nil)

(tab-bar-mode)
(tab-bar-history-mode)

;; don't allow tab cycling only jumping to specific tab
(general-def tab-bar-mode-map
  "C-<tab>" nil
  "C-S-<tab>" nil
  "C-S-<iso-lefttab>" nil)

(general-def '(insert normal)
  "C-l" #'tab-bar-history-back
  "C-S-l" #'tab-bar-history-forward
  "C-M-L" #'tab-bar-history-forward)

(general-spc
  "a" (noct-c (noct-tab-select "emacs"))
  "r" (noct-c (noct-tab-select "log"))
  "s" (noct-c (noct-tab-select "notes"))
  "t" (noct-c (noct-tab-select "prog"))
  "d" (noct-c (noct-tab-select "config"))
  "h" (noct-c (noct-tab-select "blog"))
  "n" (noct-c (noct-tab-select "wr"))
  "e" (noct-c (noct-tab-select "cons"))
  "i" (noct-c (noct-tab-select "mail"))
  "o" (noct-c (noct-tab-select "music")))
#+end_src

* Window Management/Navigation
:PROPERTIES:
:CUSTOM_ID: window-managementnavigation
:END:

** Ace Window
I generally only use two windows in a frame, but once I start pulling up help buffers, magit status, etc., this can be useful. It also replaces ~other-window~, so it's nice for two windows as well.
#+begin_src emacs-lisp
(use-package ace-window
  :general (general-t "w" #'ace-window)
  :config
  (gsetq aw-keys '(?a ?r ?s ?t ?d ?h ?n ?e ?i ?o)
         aw-scope 'frame))
#+end_src

** Window Splitting/Movement Keybindings
#+begin_src emacs-lisp
(defun noct-kill-buffer-delete-window ()
  "Kill the current buffer and then delete the current window."
  (interactive)
  (noct-kill-this-buffer)
  (delete-window))

(defun noct-vsplit ()
  "Vertically split window and switch to new window."
  (interactive)
  (split-window-below)
  (other-window 1)
  (balance-windows))

(defun noct-hsplit ()
  "Horizontally split window and switch to new window."
  (interactive)
  (split-window-right)
  (other-window 1)
  (balance-windows))

(general-t "-" #'noct-vsplit)

(defun noct-zoom-win ()
  "Toggle making the current window the only one."
  (interactive)
  (if (= (count-windows) 1)
      (winner-undo)
    (delete-other-windows)))

(general-def '(insert normal)
  "C-'" #'noct-hsplit
  "C-n" #'evil-window-prev
  "C-e" #'evil-window-next
  ;; #'balance-windows
  ;; quit-window may not close (may show other buffer); delete always closes
  ;; #'quit-window
  "C-w" #'delete-window
  "M-w" #'noct-kill-this-buffer
  "C-M-w" #'noct-kill-buffer-delete-window
  ;; [o]nly
  "M-o" #'noct-zoom-win
  "C-," #'evil-switch-to-windows-last-buffer)
#+end_src

** Window Too Small For Splitting Fix
See [[https://github.com/rnkn/olivetti/issues/12][here]].
#+begin_src emacs-lisp
(defun rnkn-split-window-right-ignore (&optional size)
  (if (car size) size (list (/ (window-total-width) 2))))

(general-add-advice 'split-window-right
                    :filter-args #'rnkn-split-window-right-ignore)
#+end_src

** Auto Balance Windows
I don't need zoom as this is good enough.

#+begin_src emacs-lisp
;; this messes up `which-key', for example
;; (general-add-hook 'window-configuration-change-hook
;;                   #'balance-windows)

(general-advice-add '(quit-window delete-window org-edit-special)
                    :after
                    (noct-defun noct-balance-advice (&rest _)
                      "Balance windows.
Ignore arguments."
                      (balance-windows)))
#+end_src

** Zoom
I still need to work on my configuration for this. See [[https://github.com/cyrus-and/zoom/issues/17][this issue]] for information on using fixed-sized windows with zoom (there is no perfect solution, and it looks like it would be very difficult to support).
#+begin_src emacs-lisp
(use-package zoom
  :general
  (noct-toggle-map "z" #'zoom-mode)
  (general-t
    "t" #'zoom
    "a" #'balance-windows)
  ;; :init
  ;; (zoom-mode)
  :blackout " ⊞"
  :config
  (gsetq zoom-size '(0.618 . 0.618)))
#+end_src

* Buffer Management/Navigation
** Counsel/Swiper/Ivy
It's a bit hard to decide how to organize counsel, ivy, and swiper since they're all intertwined. I previously had all counsel and ivy configuration together, but I've split them into multiple use-package expression and put the buffer/file related configuration here.

*** Setup
#+begin_src emacs-lisp
(use-package swiper
  :config
  (gsetq swiper-goto-start-of-match t))

;; `counsel-mode' is enabled in previous counsel use-package expression
;; (use-package counsel
;;   :general
;;   ('normal "/" #'counsel-grep-or-swiper)
;;   (general-spc "l" #'counsel-locate))
#+end_src

*** Locate/Find/FD/FZF
#+begin_src emacs-lisp
(general-with-package 'counsel
  (defun noct-fd-fzf (&optional initial-input)
    "Run `counsel-fzf' using fd as fzf's default command."
    (interactive)
    (noct-letenv (("FZF_DEFAULT_COMMAND"
                   "fd --hidden --no-ignore --exclude .git"))
      (counsel-fzf initial-input)))

  ;; have heard some people say ripgrep is faster than fd for files; haven't
  ;; really tried enough to compare
  (defun noct-ripgrep-fzf (&optional initial-input)
    "Run `counsel-fzf' using ripgrep as fzf's default command."
    (interactive)
    (noct-letenv (("FZF_DEFAULT_COMMAND"
                   "rg --files --no-ignore --hidden --follow --glob '!.git'"))
      (counsel-fzf initial-input)))

  (defun noct-ivy-switch-to-locate ()
    "Switch to using locate, preserving the current input.
Requires lexical binding."
    (interactive)
    (let ((input (ivy--input)))
      (ivy-quit-and-run (counsel-locate input))))

  (defun noct-ivy-switch-to-fzf ()
    "Switch to using fzf, preserving the current input."
    (interactive)
    (let ((input (ivy--input)))
      (ivy-quit-and-run (noct-ripgrep-fzf input))))

  (general-def ivy-switch-buffer-map
    "C-l" #'noct-ivy-switch-to-locate
    "C-f" #'noct-ivy-switch-to-fzf))
#+end_src

*** TODO Counsel Grep
Configure ~counsel-grep~ to go to the end of matches and integrate with evil.

TODO: This should be in counsel (variable to jump to match end and evil integration that's already done for swiper).
#+begin_src emacs-lisp
(general-with-package 'counsel
  (let ((rg-flags (concat
                   "--max-columns 200 "
                   "--max-columns-preview "
                   "--hidden "
                   "--no-heading "
                   "--smart-case "
                   "--line-number "
                   "--color never ")))
    (gsetq counsel-grep-base-command (concat "rg " rg-flags "%s %s")
           ;; TODO it would be way better if ripgrep supported trimming the line
           ;; don't quote %s (breaks regex)
           counsel-rg-base-command (concat "rg " rg-flags "%s .")))

  (defun noct-match-beginning ()
    "Go to the beginning of the last match."
    (when-let ((beg (match-beginning 0)))
      (goto-char beg)))

  ;; swiper does these but counsel-grep doesn't
  (defun noct-add-ivy-text-to-history ()
    "Add the last ivy search to `regexp-search-ring'."
    (add-to-history
     'regexp-search-ring
     (ivy--regex ivy-text)
     regexp-search-ring-max))

  (defun noct-evil-search-action ()
    "Update evil search information based on last ivy search."
    (when (and (bound-and-true-p evil-mode)
               (eq evil-search-module 'evil-search))
      (add-to-history 'evil-ex-search-history ivy-text)
      (setq evil-ex-search-pattern (list ivy-text t t))
      (setq evil-ex-search-direction 'forward)
      (when evil-ex-search-persistent-highlight
        (evil-ex-search-activate-highlight evil-ex-search-pattern))))


  (general-add-hook 'counsel-grep-post-action-hook (list
                                                    #'noct-match-beginning
                                                    #'noct-add-ivy-text-to-history
                                                    #'noct-evil-search-action)))
#+end_src

** Ctrlf
#+begin_src emacs-lisp
(use-package ctrlf
  :general
  ('(normal insert)
   "C-f" #'ctrlf-forward-default
   "C-S-f" #'ctrlf-backward-default)
  :config
  ;; must happen after loading ctrlf
  (general-def ctrlf-minibuffer-mode-map
    "<down>" #'ctrlf-forward-default
    "<up>" #'ctrlf-forward-default
    "C-f" #'ctrlf-forward-default
    "C-S-f" #'ctrlf-backward-default
    "<escape>" #'ctrlf-cancel))
#+end_src

** Better Jumper
I prefer to have a buffer-local jumplist and use a separate key for ~winner-undo~ to switch between previously displayed windows/buffers.

[[https://github.com/gilbertw1/better-jumper/issues/14][It would be nice to have completing-read support]].
#+begin_src emacs-lisp
(use-package better-jumper
  :ghook ('pre-command-hook nil nil nil t)
  :general
  (general-def
    [remap evil-jump-forward] #'better-jumper-jump-forward
    [remap evil-jump-backward] #'better-jumper-jump-backward)
  :config
  (gsetq better-jumper-context 'buffer
         ;; save/restore history with savehist
         better-jumper-use-savehist t))
#+end_src

** Deadgrep
#+begin_src emacs-lisp
(use-package deadgrep
  :general (general-t "/" #'deadgrep-incremental)
  :init
  (gsetq smart-jump-find-references-fallback-function
         #'noct-deadgrep-current)
  :config
  (defun noct-deadgrep-current ()
    "Run `deadgrep' with the current selection or symbol at point."
    (interactive)
    (deadgrep (cond ((use-region-p)
                     (buffer-substring-no-properties (region-beginning)
                                                     (region-end)))
                    ((symbol-at-point)
                     (substring-no-properties
                      (symbol-name (symbol-at-point)))))))

  ;; ~/src/forks/evil-collection/evil-collection-deadgrep.el
  (evil-collection-init 'deadgrep))
#+end_src

** Frog Jump Buffer
Useful if constantly switching between only a few files in a project. I don't normally don't keep more than 2 file-visiting buffers open in a frame, so this is useful if I'm working in a project where I'm switching between 5 or so buffers (more than that and it becomes less useful). It can be slightly faster (and definitely less keystrokes) than projectile.
#+begin_src emacs-lisp
(use-package frog-jump-buffer
  :general (general-spc "g" #'frog-jump-buffer)
  :config
  (gsetq frog-jump-buffer-include-current-buffer nil
         frog-jump-buffer-posframe-handler
         #'noct-posframe-poshandler-frame-near-top-center))
#+end_src

** Ibuffer
*** Setup
#+begin_src emacs-lisp
(use-package ibuffer
  :ensure nil
  :general
  (general-s "b" #'ibuffer))
#+end_src

*** All the Icons Ibuffer
#+begin_src emacs-lisp
(use-package all-the-icons-ibuffer
  :ghook ('ibuffer-mode-hook nil nil nil t))
#+end_src

** Outline | Outshine | Outli
#+begin_src emacs-lisp
(use-package outline
  :ensure nil
  :ghook ('(prog-mode-hook conf-mode-hook) #'outline-minor-mode)
  :blackout outline-minor-mode
  :config
  (general-def 'normal outline-minor-mode-map
    "H" (general-l (outline-back-to-heading))
    "TAB" #'outline-toggle-children))

(use-package outshine
  :disabled t
  :blackout t
  :ghook 'outline-minor-mode-hook)

(noct-use ( :elpaca outli
            :host github
            :repo "jdtsmith/outli")
  (gsetq outli-speed-commands
         '(("Outline Navigation")
           ("k" . outline-next-visible-heading)
           ("K" . outline-previous-visible-heading)
           ("n" . outline-forward-same-level)
           ("e" . outline-backward-same-level)
           ("h" . outline-up-heading)
           ("i" . outline-next-heading)
           ("Outline Visibility")
           ("c" . outline-cycle)
           ("C" . outline-cycle-buffer)
           ("w" . outli-toggle-narrow-to-subtree)
           ("W" . widen)
           ;; ("h" . outline-hide-sublevels)
           ("1" . (outline-hide-sublevels 1))
           ("2" . (outline-hide-sublevels 2))
           ("3" . (outline-hide-sublevels 3))
           ("4" . (outline-hide-sublevels 4))
           ("5" . (outline-hide-sublevels 5))
           ("Outline Structure Editing")
           ("E" . outline-move-subtree-up)
           ("N" . outline-move-subtree-down)
           ("<" . outline-demote)
           (">" . outline-promote)
           ("o" . outli-insert-heading-respect-content)
           ("v" . outline-mark-subtree)
           ("?" . outli-speed-command-help)))
  (:hooks '(prog-mode-hook text-mode-hook))
  (:config
    (general-def '(outline-mode-map outli-mode-map)
      "<backtab>" nil)))
#+end_src

** Projectile
Alternatively, there is the builtin ~project-find-file~, [[https://github.com/technomancy/find-file-in-project][find-file-in-project]], and [[https://github.com/h/find-file-in-repository][find-file-in-repository]]. Projectile has a lot of other useful commands though.

#+begin_src emacs-lisp
(noct-use projectile
  (:blackout)
  (autoload 'noct-switch-to-project-root "projectile")
  (autoload 'noct-projectile-switch-and-vc "projectile")
  (general-spc
    "p" #'projectile-find-file
    "P" #'projectile-find-file-in-known-projects
    "c" #'projectile-switch-project
    "C" #'noct-switch-to-project-root
    "v" #'noct-projectile-switch-and-vc
    "-" #'projectile-dired
    "D" #'projectile-find-dir
    "RET" #'projectile-find-tag)
  (general-t
    "S" #'projectile-replace
    "T" #'projectile-test-project)

  ;; I don't use the mode line; no reason to calculate
  (opt projectile-dynamic-mode-line nil)

  ;; this allows using `xref-find-references' without typing directory
  (defun noct-projectile-try (dir)
    "Function for `project-find-functions' using projectile."
    (when (require 'projectile nil t)
      (when-let ((root (projectile-project-root dir)))
        (cons 'transient root))))

  (once-with 'project
    (general-pushnew #'noct-projectile-try project-find-functions))

  (:config
    (opt projectile-enable-caching t
         projectile-project-test-cmd "make test"
         projectile-completion-system 'default
         projectile-project-search-path '("~/src")
         ;; false positives in home directory; these are the git files but
         ;; things like tags, ctags, etc. that will never mark the root of a
         ;; project for me
         projectile-project-root-files nil)

    (defun noct-switch-to-project-root ()
      (interactive)
      (let ((projectile-switch-project-action 'projectile-dired))
        (call-interactively #'projectile-switch-project)))

    (defun noct-projectile-switch-and-vc ()
      "Switch project and run `projectile-vc'"
      (interactive)
      (let ((projectile-switch-project-action 'projectile-vc))
        (call-interactively #'projectile-switch-project)))

    (projectile-mode)

    (projectile-cleanup-known-projects)

    (projectile-register-project-type
     'emacs '("Cask")
     :compile "make compile"
     :test "make test"
     :test-prefix "test-"
     :test-suffix ".el")))


#+end_src

* UI/Appearance/Visual/Formatting
** Adaptive Wrap
This package, for example, will visually indent soft-wrapped lines that are bullet points.
#+begin_src emacs-lisp
(use-package adaptive-wrap
  :ghook ('text-mode-hook #'adaptive-wrap-prefix-mode)
  :general (general-def noct-toggle-map "A" #'adaptive-wrap-prefix-mode))
#+end_src

** All the Icons
A helper library for inserting icons (used by other packages in my config).
#+begin_src emacs-lisp
(use-package all-the-icons
  :init
  (defun all-the-icons-maybe-install-fonts ()
    "Install fonts for all the icons if they have not been installed."
    ;; workaround for this functionality not being included by default
    ;; https://github.com/domtronn/all-the-icons.el/issues/120
    (when (and (display-graphic-p)
               (not (find-font (font-spec :name "all-the-icons"))))
      (all-the-icons-install-fonts t)))
  (general-after-gui
    (all-the-icons-maybe-install-fonts))
  :config
  ;; prevent breakage in tty
  ;; https://github.com/hlissner/doom-emacs/blob/29e4719a7d3c9991445be63e755e0cb31fd4fd00/core/core-ui.el#L479
  (cond
   ((daemonp)
    (defun doom--conditionally-disable-all-the-icons-in-tty-a
        (orig-fn &rest args)
      "Return a blank string in tty Emacs which doesn't support multiple fonts."
      (if (or (not after-init-time) (display-multi-font-p))
          (apply orig-fn args)
        ""))
    (general-add-advice
     '(all-the-icons-octicon
       all-the-icons-material
       all-the-icons-faicon all-the-icons-fileicon
       all-the-icons-wicon all-the-icons-alltheicon)
     :around #'doom--conditionally-disable-all-the-icons-in-tty-a))
   ((not (display-graphic-p))
    (defun doom--disable-all-the-icons-in-tty-a (&rest _)
      "Return a blank string for tty users."
      "")
    (general-add-advice
     '(all-the-icons-octicon
       all-the-icons-material
       all-the-icons-faicon all-the-icons-fileicon
       all-the-icons-wicon all-the-icons-alltheicon)
     :override #'doom--disable-all-the-icons-in-tty-a))))
#+end_src

** Builtin Line Numbers
#+begin_src emacs-lisp
(gsetq-default display-line-numbers 'visual
               display-line-numbers-widen t
               ;; this is the minimum
               display-line-numbers-width 3
               ;; default
               display-line-numbers-current-absolute t)

;; (defun noct-maybe-disable-absolute-current ()
;;   (when (> (count-lines (point-min) (point-max)) 9999)
;;     (setq-local display-line-numbers-current-absolute nil)))
;; (general-add-hook 'find-file-hook #'noct-maybe-disable-absolute-current)

(defun noct-relative ()
  "If `display-line-numbers' is non-nil, switch to relative numbering"
  (when display-line-numbers
    (setq-local display-line-numbers 'visual)))

(defun noct-absolute ()
  "If `display-line-numbers' is non-nil, switch to absolute numbering"
  (when display-line-numbers
    (setq-local display-line-numbers t)))

(general-add-hook 'evil-insert-state-entry-hook #'noct-absolute)
(general-add-hook 'evil-insert-state-exit-hook #'noct-relative)
#+end_src

** Mode Line
*** Any Mode Line
#+begin_src emacs-lisp
(noct-elpaca-after-init
  (column-number-mode)
  (size-indication-mode))
#+end_src

*** Doom Modeline
#+begin_src emacs-lisp
;; (defun noct-set-modeline (setter symbol newval)
;;   (if (eq symbol 'mode-line-format)
;;       (funcall setter 'header-line-format newval)
;;     (funcall setter symbol newval)))

;; doesn't work
;; (defun noct-set-modeline-advice (orig-fun &rest args)
;;   (cl-letf* ((old-set (symbol-function 'set))
;;              (old-set-default (symbol-function 'set-default))
;;              ((symbol-function 'set)
;;               (lambda (symbol newval)
;;                 (funcall #'noct-set-modeline old-set symbol newval)))
;;              ((symbol-function 'set-default)
;;               (lambda (symbol newval)
;;                 (funcall #'noct-set-modeline old-set-default symbol newval))))
;;     (apply orig-fun args)))

(defun noct-set-doom-modeline-advice (key &optional default)
  "Advice for `doom-modeline-set-modeline' to use the header line instead."
  (when-let ((line (doom-modeline key)))
    (setf (if default
              (default-value 'header-line-format)
            (buffer-local-value 'header-line-format (current-buffer)))
          (list "%e" line))))

(use-package doom-modeline
  :init
  (gsetq-default mode-line-format
                 (list (propertize (make-string 300 ?─)
                                   ;; use default background color
                                   'face 'default)))
  (noct-elpaca-after-init
    (general-add-advice
     'doom-modeline-set-modeline
     :override #'noct-set-doom-modeline-advice)
    (doom-modeline-mode)

    ;; show in modeline when something else is using header
    (defun noct-doom-headerline-to-modeline (sym value operation &rest _)
      "Move doom line from header to modeline when there's a different header."
      (when (and (eq sym 'header-line-format)
                 value
                 (eq operation 'set)
                 (not (string-match "dirvish" (symbol-name major-mode)))
                 (not (string-match "doom-modeline"
                                    (format "%s" value))))
        (setq mode-line-format (doom-modeline 'main))))
    (add-variable-watcher 'header-line-format #'noct-doom-headerline-to-modeline))
  :config
  (gsetq doom-modeline-buffer-encoding 'nondefault)
  (general-after-gui
    (gsetq doom-modeline-height (noct-mode-line-height)
           ;; for some reason normal panel's height is broken otherwise
           doom-modeline-hud t)
    ;; TODO why does the `buffer-live-p' check fail for Messages?
    (dolist (bname '(
                     ;; "*scratch*"
                     "*Messages*"))
      (with-current-buffer bname
        (setq header-line-format (doom-modeline 'main)))))

  ;; TODO pushes things off to the side (even if plenty of space)
  ;; (gsetq doom-modeline-minor-modes t)

  ;; (doom-modeline-def-segment iconic-emacs-modeline-starter
  ;;   (list
  ;;    ;; space on left (or - if term)
  ;;    mode-line-front-space
  ;;    ;; report multilingual input; e.g. U: for utf-8
  ;;    mode-line-mule-info
  ;;    ;; for emacsclient frame identification
  ;;    mode-line-client
  ;;    ;; ** if modified, -- if not, %% if RO, %- if RO and modified
  ;;    mode-line-modified
  ;;    ;; indicates a remote buffer
  ;;    mode-line-remote
  ;;    mode-line-frame-identification))

  ;; replace modals section; not really a good alternative without defining a
  ;; completely new modeline
  ;; (doom-modeline-def-segment modals
  ;;   (doom-modeline-segment--iconic-emacs-modeline-starter))

  (gsetq global-mode-string
         (list
          ;; current group
          '(:eval (when (fboundp 'fg--name)
                    (let ((name (fg--name)))
                      (when name
                        (list :propertize (format "[%s] " (fg--name))
                              :face 'bold)
                        (format "[%s] "
                                (propertize (fg--name)
                                            'face 'bold))))))
          '(:eval (bound-and-true-p noct-heading-day-word-count))
          ;; show if clocked in to a heading
          '(:eval (when (and (bound-and-true-p org-mode-line-string)
                             (not (string= org-mode-line-string "")))
                    (concat "Clock: <"
                            (string-trim-left org-mode-line-string)
                            "> ")))))

  ;; https://github.com/seagle0128/doom-modeline/issues/271
  (when (string-match "--with-x-toolkit=lucid" system-configuration-options)
    (defun noct-doom-modeline--font-height (orig-fun &rest args)
      (round (* 0.5 (apply orig-fun args))))
    (general-add-advice 'doom-modeline--font-height
                        :around #'noct-doom-modeline--font-height)))
#+end_src

** Emojify
Display and insert emojis.
 #+begin_src emacs-lisp
(use-package emojify
  :defer-incrementally t
  :config
  (global-emojify-mode))
 #+end_src

** Evil Visual Mark Mode
Display an overlay for evil marks in normal state.
#+begin_src emacs-lisp
(use-package evil-visual-mark-mode
  :defer 3
  :config
  (evil-visual-mark-mode)
  ;; TODO how to render after restoring marks with desktop?
  ;; this doesn't work
  ;; (general-add-hook 'desktop-after-read-hook
  ;;                   (lambda ()
  ;;                     (dolist (buffer (buffer-list))
  ;;                       (with-current-buffer buffer
  ;;                         (evil-visual-mark-render)))))
  )
#+end_src

** Highlight Escape Sequences
Highlights escaped characters.
#+begin_src emacs-lisp
(use-package highlight-escape-sequences
  :init (hes-mode))
#+end_src

** Mini Frame and Maple Minibuffer
#+begin_src emacs-lisp
;; glitchy; both sometimes disappear (when messages in echo area); sometimes
;; slow; not using for now
(use-package mini-frame
  :disabled
  :config
  ;; TODO border color
  (gsetq mini-frame-color-shift-step 0
         mini-frame-show-parameters
         `((top . ,(round (* 0.02 (noct-default-monitor-height))))
           (width . 0.7)
           (height . 1)
           (left . 0.5))))

(use-package maple-minibuffer
  :disabled t
  :ensure ( :host github
            :repo "honmaple/emacs-maple-minibuffer")
  :config
  (setq maple-minibuffer:position-type 'frame-top-center
        maple-minibuffer:border-color
        (or (ignore-errors (ewal-get-color 'foreground) "gray50"))
        maple-minibuffer:height nil
        maple-minibuffer:width 0.7
        maple-minibuffer:cache t))
#+end_src

** Posframe
A helper library for child frames (e.g. used with company and ivy).
#+begin_src emacs-lisp
(use-package posframe)
#+end_src

** Rainbow Mode
This will colorize something like #F3A111. I am enabling this locally in files with colors.
#+begin_src emacs-lisp
(use-package rainbow-mode)
#+end_src

** Show Paren
Smartparens' version is unfortunately too slow.
#+begin_src emacs-lisp
(use-package paren
  :ensure nil
  :init
  (noct-after-buffer (show-paren-mode))
  :config (gsetq show-paren-delay 0))
#+end_src

** Stripe Buffer
#+begin_src emacs-lisp
;; can cause input lag
(use-package stripe-buffer
  ;; :ghook ('org-mode-hook #'turn-on-stripe-table-mode)
  )
#+end_src

** Themes
*** Disable Old Theme When Switching
#+begin_src emacs-lisp
;; https://emacs.stackexchange.com/questions/3112/how-to-reset-color-theme
;; undo old theme before switching to new theme
;; circadian does this too when switching themes
(defun noct-undo-themes (&rest _)
  (mapc #'disable-theme custom-enabled-themes))

(general-add-advice 'load-theme :before #'noct-undo-themes)
#+end_src

*** Installed Themes
#+begin_src emacs-lisp
(use-package twilight-bright-theme)

(use-package nord-theme)

(use-package gruvbox-theme
  :config
  (general-after 'ace-window
    (set-face-attribute 'aw-leading-char-face nil :height 1.0)))

;; dead
;; (use-package gruvbox-dark-theme
;;   :ensure (
;;              :host github
;;              :repo "d125q/gruvbox-dark-emacs")
;;   :init (load-theme 'gruvbox-dark t))

(use-package lenlen-theme
  :disabled t
  :ghook ('elpaca-after-init-hook (lambda () (require 'lenlen-theme))))

(use-package solarized-theme)

(use-package jazz-theme)

(use-package ujelly-theme)

(use-package warm-night-theme)

(use-package flatui-theme)

(use-package labburn-theme)

(use-package tao-theme)

(use-package doom-themes
  :config
  (general-with 'org
    (set-face-attribute 'org-level-1 nil :height 1.0 :weight 'semi-bold
                        :background 'unspecified)
    (set-face-attribute 'org-block nil :background 'unspecified)
    (set-face-attribute 'org-block-begin-line nil :background 'unspecified)
    (set-face-attribute 'org-ellipsis nil :background 'unspecified)))

(use-package kaolin-themes)
;; these are nice:
;; kaolin-eclipse
;; kaolin-valley-dark

(use-package timu-spacegrey-theme)

(use-package shades-of-purple-theme)

;; missing a lot of faces (like dired)
(use-package rose-pine-emacs
  :disabled t
  :no-require t
  :ensure ( :host github
            :repo "thongpv87/rose-pine-emacs"))

;; do I understand why straight is building nord in catppuccin directory? no
;; (use-package catppuccin-theme)
#+end_src

*** Pywal
**** Ewal
#+begin_src emacs-lisp
(use-package ewal)

(use-package ewal-evil-cursors)

(use-package ewal-spacemacs-themes)

(use-package ewal-doom-themes)

(defun noct-ewal-load-spacemacs-theme ()
  "Load ewal's spacemacs theme with some adjustments."
  (interactive)
  (setq spacemacs-theme-org-height nil)
  (load-theme 'ewal-spacemacs-modern t)
  (let (custom--inhibit-theme-enable)
    (custom-theme-set-faces
     'spacemacs-dark
     `(org-block ((t (:background ,(ewal-get-color 'background)))))
     `(org-block-begin-line ((t (:background ,(ewal-get-color 'background)))))
     `(org-block-end-line ((t (:background ,(ewal-get-color 'background)))))
     `(ivy-posframe-border ((t (:weight bold
                                :background
                                ,(ewal-get-color 'foreground)))))
     `(frog-menu-posframe-background-face
       ((t (:background ,(ewal-get-color 'background))))))))

(defun noct-ewal ()
  "Set theme for the current pywal colors."
  (interactive)
  (ewal-evil-cursors-get-colors
   :apply t)
  (setq evil-insert-state-cursor (list (ewal-get-color 'cursor) 'bar))

  (load-theme 'ewal-doom-one t)

  (let (custom--inhibit-theme-enable)
    (custom-theme-set-faces
     'ewal-doom-one
     `(line-number ((t (:foreground ,(ewal-get-color 'blue)))))
     `(ivy-posframe-border ((t (:weight bold
                                :background
                                ,(ewal-get-color 'foreground)))))
     `(frog-menu-posframe-background-face
       ((t (:background ,(ewal-get-color 'background))))))))
#+end_src

**** Xresources
#+begin_src emacs-lisp
(use-package xresources-theme)
#+end_src

*** Circadian
#+begin_src emacs-lisp
(use-package circadian
  :disabled t
  :init
  (gsetq circadian-themes '(
                            ;; ("8:00" . twilight-bright)
                            ;; ("20:00" . nord)
                            ("20:00" . gruvbox-dark-soft)))
  (unless (bound-and-true-p ewal-base-palette)
    (circadian-setup)))
;; can implement something similar enough tocircadian with just `run-at-time'
;; https://old.reddit.com/r/emacs/comments/gdtqov/weekly_tipstricketc_thread/fq9186h/
#+end_src

*** Default Theme
#+begin_src emacs-lisp
(defconst noct-favorite-themes
  '(doom-opera
    doom-spacegry
    doom-zenburn
    doom-nord
    doom-miramare
    doom-lantern
    doom-rouge
    gruvbox-dark-soft
    kaolin-shiva
    kaolin-eclipse
    ;; looks great but too shiny
    ;; twilight-bright
    catppuccin
    rose-pine-mone))

(defun noct-set-default-theme ()
  (interactive)
  (if (and (daemonp)
           (ignore-errors (ewal-load-colors)))
      ;; takes 0.02-0.03 seconds; not that much but only do for daemon
      ;; also happens to be a good way to distinguish the two
      (noct-ewal)
    (unless (featurep 'circadian)
      ;; 0.2 seconds
      ;; (load-theme 'doom-spacegrey t)
      (if (daemonp)
          ;; faster even though it pulls in dash
          (load-theme 'gruvbox-dark-soft t)
        ;; fastest
        ;; (load-theme 'tao-yin t)
        (load-theme 'doom-opera t)))))

(general-add-hook 'elpaca-after-init-hook #'noct-set-default-theme)
#+end_src

** Visual Fill Column
Soft wrap lines at =fill-column=.
#+begin_src emacs-lisp
(use-package visual-fill-column
  :ghook 'text-mode-hook
  :general (noct-toggle-map "V" #'visual-fill-column-mode))
#+end_src

** Visual Line mode
#+begin_src emacs-lisp
;; https://github.com/abo-abo/swiper/issues/925
;; (global-visual-line-mode)
;; soft-wrap lines
(general-add-hook 'text-mode-hook #'visual-line-mode)
(blackout 'visual-line-mode)

;; show right-curly arrow on right of wrapped lines
(gsetq visual-line-fringe-indicators '(nil right-curly-arrow))

(general-def noct-toggle-map "v" #'visual-line-mode)
#+end_src

** Whitespace
#+begin_src emacs-lisp
;; http://ergoemacs.org/emacs/whitespace-mode.html
;; http://www.emacswiki.org/emacs/WhiteSpace
(use-package whitespace
  :ensure nil
  :defer-incrementally t
  :general (noct-toggle-map "w" #'whitespace-mode)
  :blackout t
  :config
  (gsetq whitespace-style
         (list 'face 'trailing 'space-before-tab::tab 'tabs 'tab-mark)
         ;; use `fill-column' value
         whitespace-line-column nil
         whitespace-display-mappings
         ;; would prefer not to use this, but not all themes make the tabs face
         ;; clear
         ;; TODO maybe pick a face
         '((tab-mark ?\t [?› ?\t])
           ;; (newline-mark ?\n [?¬ ?\n])
           ;; (space-mark ?\  [?·] [?.])
           ))

  (defun noct-add-lines-tail ()
    "Add lines-tail to `whitespace-style' and refresh `whitespace-mode'."
    (setq-local whitespace-style (cons 'lines-tail whitespace-style))
    (whitespace-mode))

  (general-add-hook 'prog-mode-hook #'noct-add-lines-tail)

  (global-whitespace-mode))
#+end_src

* Text Editing/Interaction
** =rect-ext.el=
#+begin_src emacs-lisp
;; TODO eventually switch to more generic narrowing solution
(use-package rect-ext
  :disabled t
  :ensure `(rect-ext
            :host github
            :repo "noctuid/rect-ext.el"
            ,@(when noct-personal-computer-p
                (list :repo "~/src/emacs/rectangle-ext/")))
  :general
  ('normal
   [remap evil-ex] #'rect-ext-evil-ex))
#+end_src

** TODO Aggressive Fill Paragraph
Too aggressive, but I like the idea. Will come back to.
#+begin_src emacs-lisp
(use-package aggressive-fill-paragraph
  :disabled t
  :ghook 'prog-mode-hook)
#+end_src

** Alignment (evil-lion and align)
Don't really use.
#+begin_src emacs-lisp
(use-package evil-lion
  :general ('normal
            "gl" #'evil-lion-left
            "gL" #'evil-lion-right))

(general-def 'visual "ta" #'align)
#+end_src

** Commenting
Automatic integration with org source blocks is nice. Evilnc jumps to the beginning of the block currently. Evil-commentary moves the point to the next line and scrolls the window, which is even worse. With polymode, any commenting command should work fine in a source block.

Evilnc also has comment text objects, but they were fairly broken last time I tried them, and I've implemented my own comment text object. Evilnc is definitely more actively maintained and has tests, which is why I'm currently using it.
#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :general
  (general-t 'normal 'override "c" #'evilnc-comment-or-uncomment-lines)
  ("C-/" #'evilnc-comment-or-uncomment-lines)
  ('normal "gc" #'evilnc-comment-operator)
  ('visual "/" #'evilnc-comment-operator))

(use-package evil-commentary
  :disabled t
  :general
  (general-t (normal visual) 'override "c" #'evil-commentary-line)
  ('normal "gc" #'evil-commentary))

;; interesting idea, but it doesn't actually list all comments
;; (defun counsel-imenu-comments ()
;;   (interactive)
;;   (let* ((imenu-create-index-function #'evilnc-imenu-create-index-function))
;;     (unless (featurep 'counsel) (require 'counsel))
;;     (counsel-imenu)))
#+end_src

** Crux
TODO just use evil?
Some extra basic utilities.
#+begin_src emacs-lisp
(use-package crux
  :general
  (general-def 'insert
    [(shift return)] #'crux-smart-open-line
    [(control shift return)] #'crux-smart-open-line-above
    ;; crux-indent-defun
    ))
#+end_src

** File Templates
TODO look into replacing with https://github.com/mineo/yatemplate

*** Doom Helpers
Would be nice if this was a package. Nice over autoinsert.
#+begin_src emacs-lisp
;; https://github.com/hlissner/doom-emacs/blob/b0978a4526cfd78bb18e5279909c19bee97e9878/modules/editor/file-templates/autoload.el
(defun doom-+file-templates--set (pred plist)
  (if (null (car-safe plist))
      (setq doom-+file-templates-alist
            (delq (assoc pred doom-+file-templates-alist)
                  doom-+file-templates-alist))
    (push `(,pred ,@plist) doom-+file-templates-alist)))

(defun doom-set-file-template! (pred &rest plist)
  "Register a file template.
PRED can either be a regexp string or a major mode symbol. PLIST may contain
these properties:
  :when FUNCTION
    Provides a secondary predicate. This function takes no arguments and is
    executed from within the target buffer. If it returns nil, this rule will be
    skipped over.
  :trigger STRING|FUNCTION
    If a string, this is the yasnippet trigger keyword used to trigger the
      target snippet.
    If a function, this function will be run in the context of the buffer to
      insert a file template into. It is given no arguments and must insert text
      into the current buffer manually.
    If omitted, `doom-+file-templates-default-trigger' is used.
  :mode SYMBOL
    What mode to get the yasnippet snippet from. If omitted, either PRED (if
    it's a major-mode symbol) or the mode of the buffer is used.
  :project BOOL
    If non-nil, ignore this template if this buffer isn't in a project.
  :ignore BOOL
    If non-nil, don't expand any template for this file and don't test any other
    file template rule against this buffer.
\(fn PRED &key WHEN TRIGGER MODE PROJECT IGNORE)"
  (declare (indent defun))
  (doom-+file-templates--set pred plist))

(defun doom-set-file-templates! (&rest templates)
  "Like `doom-set-file-template!', but can register multiple file templates at once.
\(fn &rest (PRED &key WHEN TRIGGER MODE PROJECT IGNORE))"
  (dolist (template templates)
    (doom-+file-templates--set (car template) (cdr template))))

;;
;;; Library

(cl-defun doom-+file-templates--expand (pred &key project mode trigger ignore _when)
  "Auto insert a yasnippet snippet into current file and enter insert mode (if
evil is loaded and enabled)."
  (when (and pred (not ignore))
    (when (if project (projectile-project-p) t)
      (unless mode
        (setq mode (if (symbolp pred) pred major-mode)))
      (unless mode
        (user-error "Couldn't determine mode for %s file template" pred))
      (unless trigger
        (setq trigger doom-+file-templates-default-trigger))
      (if (functionp trigger)
          (funcall trigger)
        (require 'yasnippet)
        (unless yas-minor-mode
          (yas-minor-mode-on))
        (when (and yas-minor-mode
                   (when-let
                       (template (cl-find trigger (yas--all-templates (yas--get-snippet-tables mode))
                                          :key #'yas--template-key :test #'equal))
                     (yas-expand-snippet (yas--template-content template)))
                   (and (featurep 'evil) evil-local-mode)
                   (and yas--active-field-overlay
                        (overlay-buffer yas--active-field-overlay)
                        (overlay-get yas--active-field-overlay 'yas--field)))
          (evil-initialize-state 'insert))))))

(defun doom-+file-templates-get-short-path ()
  "Fetches a short file path for the header in Doom module templates."
  (let ((path (file-truename (or buffer-file-name default-directory))))
    (save-match-data
      (cond ((string-match "/modules/\\(.+\\)$" path)
             (match-string 1 path))
            ((file-in-directory-p path user-emacs-directory)
             (file-relative-name path user-emacs-directory))
            ((abbreviate-file-name path))))))

;;
;;; Commands

(defun doom-+file-templates/insert-license ()
  "Insert a license file template into the current file."
  (interactive)
  (require 'yasnippet)
  (let ((templates
         (let (yas-choose-tables-first ; avoid prompts
               yas-choose-keys-first)
           (cl-loop for tpl in (yas--all-templates (yas--get-snippet-tables 'text-mode))
                    for uuid = (yas--template-uuid tpl)
                    if (string-prefix-p "__license-" uuid)
                    collect (cons (string-remove-prefix "__license-" uuid) tpl)))))
    (when-let (uuid (yas-choose-value (mapcar #'car templates)))
      (yas-expand-snippet (cdr (assoc uuid templates))))))

(defun doom+file-templates/debug ()
  "Tests the current buffer and outputs the file template rule most appropriate
for it. This is used for testing."
  (interactive)
  (message "Found %s" (cl-find-if #'+file-template-p +file-templates-alist)))


;; https://github.com/hlissner/doom-emacs/blob/b0978a4526cfd78bb18e5279909c19bee97e9878/modules/editor/file-templates/config.el
(defvar doom-+file-templates-dir
  (expand-file-name "etc/yasnippet/templates/" user-emacs-directory)
  "The path to a directory of yasnippet folders to use for file templates.")

(defvar doom-+file-templates-default-trigger "__"
  "The default yasnippet trigger key (a string) for file template rules that
don't have a :trigger property in `doom-+file-templates-alist'.")

(defvar doom-+file-templates-alist nil
  "An alist of file template rules. The CAR of each rule is either a major mode
symbol or regexp string. The CDR is a plist. See `doom-set-file-template!' for more
information.")

;;
;;; Library

(defun doom-+file-template-p (rule)
  "Return t if RULE applies to the current buffer."
  (let ((pred (car rule))
        (plist (cdr rule)))
    (and (or (and (symbolp pred)
                  (eq major-mode pred))
             (and (stringp pred)
                  (stringp buffer-file-name)
                  (string-match-p pred buffer-file-name)
                  (or (not (plist-member plist :when))
                      (funcall (plist-get plist :when)
                               buffer-file-name))))
         rule)))

(defun doom-+file-templates-check-h ()
  "Check if the current buffer is a candidate for file template expansion. It
must be non-read-only, empty, and there must be a rule in
`doom-+file-templates-alist' that applies to it."
  (and buffer-file-name
       (not buffer-read-only)
       (bobp) (eobp)
       (not (member (substring (buffer-name) 0 1) '("*" " ")))
       (not (file-exists-p buffer-file-name))
       ;; Prevent file-templates from breaking org-capture when target file
       ;; doesn't exist and has a file template.
       (or (not (fboundp 'org-capture-get))
           (not (org-capture-get :new-buffer)))
       (when-let (rule (cl-find-if #'doom-+file-template-p doom-+file-templates-alist))
         (apply #'doom-+file-templates--expand rule))))


;;
;;; Bootstrap

(general-with 'yasnippet
  (general-pushnew doom-+file-templates-dir yas-snippet-dirs)
  ;; Ensure file templates in `+file-templates-dir' are visible
  (yas-reload-all))

;;
(general-add-hook 'find-file-hook #'doom-+file-templates-check-h)
#+end_src

*** Templates
#+begin_src emacs-lisp
(gsetq doom-+file-templates-alist
       `((,(rx ".org" eol)
          :when noct-blog-dir-p
          :trigger "__post"
          :mode org-mode)
         (emacs-lisp-mode :trigger "__package")
         (python-mode)))
#+end_src

** Hungry Delete
Have =C-w= and =C-<backspace>= delete whitespace before deleting words when there is more than one space.
 #+begin_src emacs-lisp
(use-package hungry-delete
  :general
  ('override
   [remap backward-kill-word]
   (general-predicate-dispatch #'backward-kill-word
     (looking-back (rx (or (1+ space)
                           bol))
                   (line-beginning-position))
     #'hungry-delete-backward
     (bound-and-true-p lispyville-mode)
     #'lispyville-delete-backward-word
     (bound-and-true-p puni-mode)
     #'puni-backward-kill-word)))
#+end_src

** Smart Parens
[[https://github.com/Fuco1/smartparens/wiki/Permissions#filters][Info on filters]]

[[https://github.com/Fuco1/smartparens/wiki/Permissions#pre-and-post-action-hooks][Info on pre and post action hooks]]

#+begin_src emacs-lisp
(use-package smartparens
  ;; after updating it causes major input lag
  ;; https://github.com/Fuco1/smartparens/issues/1209
  :disabled t
  :init
  ;; NOTE could also do evil-insert-entry-hook, but this is okay since I'm not
  ;; using smartparens in the scratch buffer
  (noct-after-buffer
    (smartparens-global-mode))
  :blackout " ⦅⦆"
  :config
  ;; typing closing delimiter always jumps out of expression even if not right
  ;; before closing; causes Emacs to hang in this file
  ;; (gsetq sp-autoskip-closing-pair 'always)

  ;; this also makes Emacs hang in this file
  ;; (show-smartparens-global-mode)

  (require 'smartparens-config)

  (sp-with-modes '(java-mode c-mode sh-mode web-mode typescript-mode)
    (sp-local-pair "{" nil
                   ;; don't currently have any global handlers; still use :add
                   :post-handlers '(:add ("||\n[i]" "RET"))))

  ;; TODO this won't work with `electric-slash' in c-mode
  (sp-with-modes '(java-mode c-mode web-mode typescript-mode)
    (sp-local-pair "/*" "*/"
                   :post-handlers '(:add ("* ||\n[i]" "RET")
                                    ("\n * ||\n[i]" "*")))))
#+end_src

** Puni
#+begin_src emacs-lisp
(noct-use puni
  ;; `puni-global-mode' already handles autoloading so it's only loaded after a
  ;; key that calls; for now only use in prog mode though
  ;; puni commands
  ;; M-d - kill forward word
  ;; C-k - kill line
  ;; C-S-k - backward kill line
  ;; (puni-global-mode)
  (general-add-hook 'prog-mode-hook #'puni-mode))
#+end_src

** Electric Quote/Pair Mode

#+begin_src emacs-lisp
(setup electric
  (general-add-hook 'text-mode-hook #'electric-quote-local-mode))

(setup elec-pair
  (defun noct-inhibit-pair (_char)
    "Inhibit pairing in text modes when after or before a word character."
    (and (derived-mode-p 'text-mode)
         (or
          (memq (char-syntax (char-before (- (point) 1))) '(?w ?.))
          (memq (char-syntax (following-char)) '(?w)))))

  ;; good riddance
  (setq electric-pair-preserve-balance nil
        electric-pair-inhibit-predicate #'noct-inhibit-pair
        ;; don't jump to closing over whitespace
        electric-pair-skip-whitespace nil)

  (electric-pair-mode)

  (general-add-hook '(minibuffer-setup-hook
                      minibuffer-inactive-mode-hook)
                    (noct-disable electric-pair-local-mode)))


;; https://old.reddit.com/r/emacs/comments/144n5ht/how_can_i_get_proper_electricpairmode_pairing_for/
;; NOTE: had issues trying to modify syntax table (inhibit doesn't work
;; correctly with nesting)
(setup org

  ;; https://emacs.stackexchange.com/questions/2538/how-to-define-additional-mode-specific-pairs-for-electric-pair-mode
  (defun itsjeyd-add-org-pairs ()
    (gsetq-local electric-pair-pairs
                 (append electric-pair-pairs
                         '((?/ . ?/)
                           (?* . ?*)
                           (?+ . ?+)
                           (?~ . ?~)
                           (?= . ?=))))
    (gsetq-local electric-pair-text-pairs electric-pair-pairs))

  ;; make my inhibit function apply to the above variables
  (defun noct-no-unconditional-pairing (orig-fun &rest args)
    "Return ORIG-FUN's result but with 3rd element set to nil."
    (let ((result (apply orig-fun args)))
      (list (car result) (cadr result) nil (cadddr result))))
  (general-add-advice 'electric-pair-syntax-info :around
                      #'noct-no-unconditional-pairing)

  (:fhooks #'itsjeyd-add-org-pairs))
#+end_src

** Snippets
*** auto-yasnippet
TODO broken basically
TODO fix tab
TODO bind both in insert only
TODO number incrementing
#+begin_src emacs-lisp
(use-package auto-yasnippet
  :general
  (general-s
    "c" #'aya-create
    "x" #'aya-expand)
  (general-def 'insert
    "<C-tab>" #'aya-expand))
#+end_src

*** Yasnippet
**** Setup
#+begin_src emacs-lisp
(use-package yasnippet
  :defer-incrementally (eldoc easymenu help-mode)
  :general
  ;; no mnemonic but next to C-n and default keybinding already on extend layer
  ;; using `consult-yasnippet' instead
  ;; (general-def 'insert "C-e" #'yas-insert-snippet)
  (general-s "Y" #'yas-new-snippet)
  (general-def help-map
    ;; unbound by default
    "y" #'yas-describe-tables)
  :blackout yas-minor-mode
  :config
  ;; never expand snippets in normal state
  (general-def 'normal yas-minor-mode-map
    [remap yas-expand] #'ignore)

  (general-def 'insert yas-minor-mode-map
    "<C-i>" #'yas-expand)

  ;; TODO extra checks may be necessary to prevent re-expanding the snippet in
  ;; undesirable situations
  (defun noct-space-should-expand-snippet-p ()
    "Check if a snippet whose condition is 'space-expand-code is at the point.
Only return non-nil if not in a string or comment."
    (let ((yas-buffer-local-condition
           ''(require-snippet-condition . space-expand-code)))
      (and (yas--templates-for-key-at-point)
           (null (nth 8 (syntax-ppss))))))

  (general-def 'insert yas-minor-mode-map
    "SPC" (list #'yas-expand :predicate '(noct-space-should-expand-snippet-p)))

  (general-def 'normal snippet-mode-map
    "RET" #'yas-load-snippet-buffer-and-close
    "mt" #'yas-tryout-snippet)

  (yas-global-mode)

  (defun yas-try-expand-first (orig-func &rest args)
    "Expand a snippet before the point or call ORIG-FUNC."
    (let ((yas-fallback-behavior nil))
      (unless (and (called-interactively-p 'interactive)
                   (yas-expand))
        (apply orig-func args))))
  (general-add-advice 'noct-org-tab-insert :around #'yas-try-expand-first)

  ;; https://github.com/joaotavora/yasnippet/blob/master/doc/faq.org#why-doesnt-tab-navigation-work-with-flyspell
  (general-add-hook 'flyspell-incorrect-hook
                    (lambda (_0 _1 _2)
                      (and (bound-and-true-p yas-active-field-overlay)
                           (overlay-buffer yas-active-field-overlay)))))
#+end_src

**** Extra Snippets
#+begin_src emacs-lisp
(use-package yasnippet-snippets
  :after yasnippet
  :demand t
  :config
  ;; for some reason this is necessary for my personal snippets to override some
  ;; of these
  (yas-reload-all))
#+end_src

**** Consult Yasnippet
Very useful to learn snippets or for less-often used snippets.  A better ~yas-insert-snippet~.
#+begin_src emacs-lisp
(use-package consult-yasnippet
  :general ('insert "C-<tab>" #'consult-yasnippet))
#+end_src

*** Auto-activating Snippets (Auto-capitalization)
Automatic two-spacing and capitalization.
#+begin_src emacs-lisp
(use-package aas
  :ghook
  ;; don't want in yaml-mode
  ;; ('text-mode-hook #'aas-activate-for-major-mode)
  ('org-mode-hook #'aas-activate-for-major-mode)
  :config
  (defun noct-before-possible-sentence-end-p ()
    "Return whether before a possible sentence end position."
    (looking-back "[^\\.\\?!\"[:space:]]"
                  (line-beginning-position)))

  (aas-set-snippets 'text-mode
    :cond #'noct-before-possible-sentence-end-p
    "  " ".  "
    "? " "?  "
    "! " "!  ")

  (defun noct-before-quote-sentence-end-p ()
    "Return whether after punctuation and optionally single quotes."
    (looking-back "[\\.\\?!]'?"
                  (line-beginning-position)))

  (aas-set-snippets 'text-mode
    :cond #'noct-before-quote-sentence-end-p
    "\" " "\"  ")

  (defun noct-after-sentence-end-p ()
    "Return whether after a two-spaced sentence end or at the bol."
    (and (looking-back (rx (or (and (not space) "  "
                                    (0+ "\"")
                                    (0+ "'"))
                               bol))
                       (line-beginning-position))
         ;; condition will take place with point before snippet
         (looking-at (rx (and alpha (or eol "\"" "'" "  "))))))

  ;; auto-capitalize
  (let ((char ?a))
    (dotimes (_ 26)
      (aas-set-snippets 'text-mode
        :cond #'noct-after-sentence-end-p
        (char-to-string char)
        (capitalize (char-to-string char)))
      (cl-incf char))))
#+end_src

** Undo
*** Undohist
Make Emacs undo persistent.
#+begin_src emacs-lisp
(use-package undohist
  :disabled t
  :init (undohist-initialize))
#+end_src

*** Undo Fu
Linear undo while maintaining all history. Not as nice as being able to navigate a tree of undo history (which is sometimes useful), but it works.
#+begin_src emacs-lisp
(use-package undo-fu
  :general
  ('normal
   "u" #'undo-fu-only-undo
   "U" #'undo-fu-only-redo
   "C-r" #'undo-fu-only-redo))

;; ignores encrypted files by default
(use-package undo-fu-session
  :init (undo-fu-session-global-mode))
#+end_src

*** Undo Tree
Undo tree is a great package but is unmaintained and extremely buggy. Even after the corruption improvements, I had issues, so I am sticking with undo-fu.

[[https://github.com/syl20bnr/spacemacs/issues/774][Issue on spacemacs related to corruption]]

[[https://github.com/emacs-evil/evil/issues/1074][Issue on evil related to corruption]]

#+begin_src emacs-lisp
;; http://ergoemacs.org/emacs/emacs_undo_cult_problem.html
;; "Goddamn motherf�cking emacs undo."
(use-package undo-tree
  :disabled t
  :blackout " 🌴"
  :init (global-undo-tree-mode)
  :config
  (gsetq undo-tree-visualizer-timestamps t
         undo-tree-visualizer-diff t
         ;; buggy
         undo-tree-enable-undo-in-region nil
         ;; don't store undo history in same directory as file
         undo-tree-history-directory-alist '((".*" . "~/ag-sys/.emacs_undo"))
         ;; don't autosave history (corruption)
         undo-tree-history-autosave t)

  (general-def noct-toggle-map "u" #'undo-tree-mode)

  (general-def 'normal
    "u" #'undo-tree-undo
    "U" #'undo-tree-redo)

  (general-t "u" #'undo-tree-visualize))
#+end_src

*** Vundo
#+begin_src emacs-lisp
(use-package vundo
  :ensure (:host github :repo "casouri/vundo")
  :general (general-t "u" #'vundo)
  :config
  (gsetq vundo-glyph-alist vundo-unicode-symbols
         vundo--window-max-height 10)

  ;; vundo forces emacs state
  (general-def '(normal nil) vundo-mode-map
    "q" #'vundo-quit
    "h" #'vundo-backward
    "i" #'vundo-forward
    "n" #'vundo-next
    "e" #'vundo-previous
    "u" #'vundo-stem-root
    "y" #'vundo-stem-end
    "RET" #'vundo-confirm))
#+end_src

*** Undo HL
Currently trying with vundo only.
#+begin_src emacs-lisp
(use-package undo-hl
  :ensure (:host github :repo "casouri/undo-hl")
  :init
  ;; https://github.com/casouri/vundo/pull/44#issuecomment-1139127706
  (defvar ideasman42-real-vundo-buf nil)
  (defun ideasman42-vundo-forward-pre-command-hook ()
    (let ((buf (current-buffer)))
      (when (bound-and-true-p ideasman42-real-vundo-buf)
        (unless (eq buf ideasman42-real-vundo-buf)
          (with-current-buffer ideasman42-real-vundo-buf
            (run-hooks 'pre-command-hook))))))

  (general-add-hook 'vundo-pre-enter-hook
                    (lambda ()
                      (setq ideasman42-real-vundo-buf (current-buffer))
                      (add-hook 'pre-command-hook
                                #'ideasman42-vundo-forward-pre-command-hook)
                      (undo-hl-mode 1)))
  (general-add-hook 'vundo-post-exit-hook
                    (lambda ()
                      (remove-hook 'pre-command-hook
                                   #'ideasman42-vundo-forward-pre-command-hook)
                      (undo-hl-mode -1)
                      (makunbound 'ideasman42-real-vundo-buf)))
  :config
  (gsetq undo-hl-undo-commands
         (list
          ;; defaults, though I'm currently only using with vundo
          #'undo
          #'undo-only
          #'undo-redo
          #'undo-fu-only-undo
          #'undo-fu-only-redo
          #'evil-undo
          #'evil-redo
          ;; vundo
          #'vundo-backward
          #'vundo-forward
          #'vundo-next
          #'vundo-previous
          #'vundo-stem-root
          #'vundo-stem-end)
         undo-hl-flash-duration 0.1))
#+end_src

** Evil Motions and Text objects
*** Builtin
#+begin_src emacs-lisp
(general-def '(operator visual)
  "p" #'evil-inner-paragraph)
#+end_src

*** Things
Still experimental.
#+begin_src emacs-lisp
(use-package things
  :ensure `(things
            :host github
            :repo "noctuid/things.el"
            ,@(when noct-personal-computer-p
                (list :repo "~/src/emacs/things"))))

(use-package things-evil
  :ensure nil
  :ghook
  ('(evil-operator-state-entry-hook
     evil-visual-state-entry-hook)
   (lambda ()
     (require 'things-evil))
   nil
   nil
   t)
  :config
  (general-def '(visual operator) "RET" #'things-evil-last-text-object)

  (general-def '(inner outer) "p" nil)
  ;; temporary
  (general-def '(visual operator) "I" nil "A" nil)
  ;; keep I and A with visual block selection
  (general-def 'visual 'override
    :predicate '(eq (evil-visual-type) 'block)
    "I" #'evil-insert
    "A" #'evil-append)

  (things-evil-define aggregated-comment things-aggregated-comment :last-key "p" :keys "c")

  (things-evil-define string things-string :last-key "p" :keys "S")

  (evil-define-text-object evil-a-buffer (count &optional beg end type)
    "Select the entire buffer."
    (evil-range (point-min) (point-max)))

  (general-def '(inner outer) "e" #'evil-a-buffer)

  (things-evil-define line things-line :last-key "p" :keys "l")

  (things-evil-define paragraph paragraph :last-key "p" :keys "g")

  (things-evil-define function things-function :last-key "p" :keys "f")

  (things-define-pair 'things-paren "(" ")")
  (things-evil-define paren things-paren :last-key "p" :keys "(")

  (things-define-pair 'things-bracket "[" "]")
  (things-evil-define bracket things-bracket :last-key "p" :keys "[")

  (things-define-pair 'things-curly "{" "}")
  (things-evil-define curly things-curly :last-key "p" :keys "{")

  (things-define-pair 'things-angle "<" ">")
  (things-evil-define angle things-angle :last-key "p" :keys "<")

  (things-define-separator 'things-comma ",")
  (things-evil-define comma things-comma :last-key "p" :keys ",")

  (things-evil-define anyblock (things-paren
                                things-bracket
                                things-angle
                                things-curly)
                      :last-key "p" :keys "d"))
#+end_src

*** Evil Snipe and Easy Motion
Make these bindings:
- =h= - ~avy-goto-word-or-subword-1~
- =f= in normal - directionless 2-char sneak (avy)
- =F= - avy lines (though normally just use relative line numbers)
- =r[fFtT]= in normal/visual/operator - 2-char sneak (avy)
- =r*= - other easymotion keys
- =s[fFtT]= in normal and =[fFtT]= in visual/operator - default f/t with snipe improvements (no avy)
- =[xXzZ]= in visual/operator - 2-char seek (no avy)

The logic behind these bindings is that I already don't have =t= in normal state and use 2-char seeks much more often than I would 1-char seeks in normal state. However, when using operators, I generally am not looking far ahead (deletion, for example, is normally used with a text object for larger selections and not with a motion to some arbitrary character), so it makes sense to keep the default behavior of =[fFtT]= in the visual and operator states (but with snipe's improvements, e.g. scope increased to visible buffer). If I did want a 2-char non-avy seek, I could use =[xXzZ]= (the default snipe keys for this purpose). =r[fFtT]= keys are consistent with other =r= keys (i.e. they remotely move somewhere using avy).

**** Evil Snipe
#+begin_src emacs-lisp
(use-package evil-snipe
  :commands (noct-snipe-2-f noct-snipe-2-F noct-snipe-2-t noct-snipe-2-T)
  :general
  ;; move some default keys to s that I override with more used commands
  (general-def 'normal
    :prefix "s"
    "t" #'evil-snipe-t
    "T" #'evil-snipe-T
    "f" #'evil-snipe-f
    "F" #'evil-snipe-F
    "n" #'evil-next-line
    "e" #'evil-previous-line
    "/" #'evil-ex-search-forward
    "?" #'evil-ex-search-backward
    ";" #'evil-snipe-repeat
    "," #'evil-snipe-repeat-reverse)
  (general-def '(operator visual)
    "f" #'evil-snipe-f
    "F" #'evil-snipe-F
    "t" #'evil-snipe-t
    "T" #'evil-snipe-T
    "z" #'evil-snipe-z
    "Z" #'evil-snipe-Z)
  ;; to keep `lispyville-delete-char-or-splice' in visual for now
  (general-def 'operator
    "x" #'evil-snipe-x
    "X" #'evil-snipe-X)
  :blackout t
  :blackout evil-snipe-override-mode
  :blackout evil-snipe-override-local-mode
  :config
  (gsetq evil-snipe-smart-case t
         ;; search visible part of buffer
         evil-snipe-scope 'visible
         ;; include matches behind cursor for repeating
         evil-snipe-repeat-scope 'whole-visible
         ;; tab to refine search (add another char)
         evil-snipe-tab-increment t
         ;; don't automatically bind s and S
         evil-snipe-auto-disable-substitute nil
         ;; don't automatically bind ; and ,
         evil-snipe-override-evil-repeat-keys nil
         ;; the incremental highlight is good enough
         evil-snipe-enable-highlight nil)

  ;; define evil-snipe-(z|Z)
  (evil-snipe-def 2 'inclusive "z" "Z")

  (evil-snipe-def 2 'inclusive "f" "F"
                  :forward-fn noct-snipe-2-f
                  :backward-fn noct-snipe-2-F)

  (evil-snipe-def 2 'exclusive "t" "T"
                  :forward-fn noct-snipe-2-t
                  :backward-fn noct-snipe-2-T)

  (general-add-hook 'evil-snipe-local-mode-hook
                    (lambda () (blackout 'evil-snipe-local-mode)))

  ;; not using evil-snipe-mode, but highlight cleanup depends on it
  ;; remove check
  (defun noct-evil-snipe--cleanup ()
    "Disables overlays and cleans up after evil-snipe."
    (remove-overlays nil nil 'category 'evil-snipe)
    (remove-hook 'pre-command-hook #'evil-snipe--cleanup))

  (general-add-advice 'evil-snipe--cleanup :override #'noct-evil-snipe--cleanup))
#+end_src

**** Evil Easymotion
TODO Use things.el instead.
#+begin_src emacs-lisp
(use-package evil-easymotion
  :general
  (general-def 'motion
    "h" #'evil-avy-goto-word-or-subword-1
    ;;"f" #'noct-sneak-forward-f
    "f" #'evil-avy-goto-char-2
    ;; "F" #'noct-sneak-backward-F
    ;; not sure what to bind this to
    "F" #'evil-avy-goto-line)

  ;; (general-def 'normal "?" #'evil-avy-goto-char-timer)

  (general-r
    "f" #'noct-sneak-forward-f
    "F" #'noct-sneak-backward-F
    "t" #'noct-sneak-forward-exclusive-t
    "T" #'noct-sneak-backward-exclusive-T)

  (general-r
    "n" #'evilem-next-line
    "e" #'evilem-prev-line
    ;; too many candidates to be that useful
    ;; "w" #'evilem-forward-word-begin
    ;; "b" #'evilem-backward-word-begin
    "w" #'evilem-forward-WORD-begin
    "b" #'evilem-backward-WORD-begin
    ;; NOTE: this IS different from `avy-goto-word-or-subword-1' with
    ;; `global-subword-mode' enabled; the subword one works with CamelCase
    "h" #'evil-avy-goto-word-1
    ;; "s" #'evilem-sentence-nav-forward
    ;; "S" #'evilem-sentence-nav-backward
    ;; "s" #'evilem-sentence-forward-begin
    ;; "S" #'evilem-sentence-backward-begin
    "s" #'evilem-any-sentence-begin
    ;; "p" #'evilem-forward-paragraph
    ;; "P" #'evilem-backward-paragraph
    "p" #'evilem-any-paragraph)

  ;; can't use control since can't distinguish certain keys (can rebind in
  ;; `input-decode' map to get working, though will only work for GUI)
  (general-def '(insert emacs)
    ;; "M-n" #'evilem-next-line
    ;; "M-e" #'evilem-prev-line
    "M-w" #'evilem-forward-WORD-begin
    ;; "M-W" #'evilem-forward-WORD-begin
    ;; NOTE: don't override backward word
    ;; "M-b" #'evilem-backward-word-begin
    "M-B" #'evilem-backward-WORD-begin
    ;; "M-s" #'evilem-sentence-nav-forward
    ;; "M-S" #'evilem-sentence-nav-backward
    ;; NOTE: interferes with completion selection keybinding
    ;; "M-s" #'evilem-sentence-forward-begin
    ;; "M-S" #'evilem-sentence-backward-begin
    "M-p" #'evilem-any-paragraph
    ;; "M-P" #'evilem-backward-paragraph
    )

  :config
  (evilem-make-motion noct-sneak-forward-f #'evil-snipe-repeat
                      :pre-hook (save-excursion
                                  ;; TODO :bind doesn't work anymore?
                                  (let (evil-snipe-enable-highlight
                                        evil-snipe-enable-incremental-highlight)
                                    (call-interactively #'noct-snipe-2-f))))
  (evilem-make-motion noct-sneak-backward-F #'evil-snipe-repeat
                      :pre-hook (save-excursion
                                  (let (evil-snipe-enable-highlight
                                        evil-snipe-enable-incremental-highlight)
                                    (call-interactively #'noct-snipe-2-F))))
  (evilem-make-motion noct-sneak-forward-exclusive-t #'evil-snipe-repeat
                      :pre-hook (save-excursion
                                  (let (evil-snipe-enable-highlight
                                        evil-snipe-enable-incremental-highlight)
                                    (call-interactively #'noct-snipe-2-t))))
  (evilem-make-motion noct-sneak-backward-exclusive-T #'evil-snipe-repeat
                      :pre-hook (save-excursion
                                  (let (evil-snipe-enable-highlight
                                        evil-snipe-enable-incremental-highlight)
                                    (call-interactively #'noct-snipe-2-T))))

  (defun noct-next-line ()
    (interactive)
    (evil-next-line)
    (beginning-of-line))

  (defun noct-prev-line ()
    (interactive)
    (evil-previous-line)
    (beginning-of-line))

  (evilem-make-motion evilem-next-line
                      #'noct-next-line
                      :pre-hook (setq evil-this-type 'line)
                      :bind ((temporary-goal-column (current-column))
                             (line-move-visual t)))

  (evilem-make-motion evilem-prev-line
                      #'noct-prev-line
                      :pre-hook (setq evil-this-type 'line)
                      :bind ((temporary-goal-column (current-column))
                             (line-move-visual t)))

  (evilem-make-motion evilem-forward-word-begin
                      #'evil-forward-word-begin)
  (evilem-make-motion evilem-forward-WORD-begin
                      #'evil-forward-WORD-begin)
  (evilem-make-motion evilem-backward-word-begin
                      #'evil-backward-word-begin)
  (evilem-make-motion evilem-backward-WORD-begin
                      #'evil-backward-WORD-begin)

  (evilem-make-motion evilem-any-sentence-begin
                      #'evil-forward-sentence-begin
                      :initial-point #'window-start)

  (evilem-make-motion evilem-any-paragraph
                      #'evil-forward-paragraph
                      :initial-point #'window-start)

  (evilem-make-motion evilem-forward-paragraph
                      #'evil-forward-paragraph)
  (evilem-make-motion evilem-backward-paragraph
                      #'evil-backward-paragraph))
#+end_src

*** Sentence Navigation
Needs to be updated to use =things.el= and needs to have more tests.  And I write two-spaced sentences now.
#+begin_src emacs-lisp
(use-package sentence-navigation
  :disabled t
  :general
  ;; TODO different keybinding?
  ('normal
   ")" #'sentence-nav-evil-forward
   "(" #'sentence-nav-evil-backward
   "g)" #'sentence-nav-evil-forward-end
   "g(" #'sentence-nav-evil-backward-end)
  ('inner "s" #'sentence-nav-evil-inner-sentence)
  ('a "s" #'sentence-nav-evil-a-sentence)
  :config
  ;; set # as comment character for org mode; TODO shouldn't have to do this
  (modify-syntax-entry ?# "<" text-mode-syntax-table)
  (with-eval-after-load 'org
    (modify-syntax-entry ?# "<" org-mode-syntax-table)))
#+end_src

*** Column Text Object
Needs to be updated to use =things.el= and needs to have more tests.
#+begin_src emacs-lisp
(use-package evil-textobj-column
  :ensure `( :host github
             :repo "noctuid/evil-textobj-column"
             ,@(when noct-personal-computer-p
                 (list :repo "~/src/emacs/evil-textobj-column")))
  :general ('inner
            "k" #'evil-textobj-column-word
            "K" #'evil-textobj-column-WORD))
#+end_src

** Evil Matchit
#+begin_src emacs-lisp
(use-package evil-matchit
  :general
  ('normal "ro" #'evilmi-jump-items))
#+end_src

** Evil Numbers
TODO now default on melpa
This package is unfortunately unmaintained.
#+begin_src emacs-lisp
(use-package evil-numbers
  ;; use version that supports g C-a
  ;; https://github.com/janpath/evil-numbers/issues/3
  :ensure (:host github :repo "janpath/evil-numbers")
  :general ('normal
            "C-a" #'evil-numbers/inc-at-pt
            "C-x" #'evil-numbers/dec-at-pt
            "g C-a" #'evil-numbers/inc-at-pt-incremental
            "g C-x" #'evil-numbers/dec-at-pt-incremental))
#+end_src

** Evil Surround
#+begin_src emacs-lisp
(use-package evil-surround
  :ghook
  ('(evil-operator-state-entry-hook
     evil-visual-state-entry-hook)
   ;; TODO this currently HAS to be a lambda; need to be able to remove for all
   ;; hooks/advice at once
   (lambda ()
     (global-evil-surround-mode))
   nil
   nil
   t)
  ;; https://github.com/timcharper/evil-surround/pull/48
  :config
  (general-def 'visual
    "s" #'evil-surround-region))
#+end_src

** Evil Exchange
#+begin_src emacs-lisp
(use-package evil-exchange
  :general (noct-c-map "x" #'evil-exchange))
#+end_src

** Evil Replace with Register
#+begin_src emacs-lisp
(use-package evil-replace-with-register
  :general
  (general-defs
    'normal
    "gr" #'evil-replace-with-register
    'visual
    "p" #'evil-replace-with-register))
#+end_src

** Link Hint
#+begin_src emacs-lisp
(use-package link-hint
  :ensure `( :host github
             :repo "noctuid/link-hint.el"
             ,@(when noct-personal-computer-p
                 (list :repo "~/src/emacs/link-hint")))
  :general
  (general-t
    "f" #'link-hint-open-link
    "F" #'link-hint-open-multiple-links)
  (general-r
    "y" #'link-hint-copy-link
    "Y" #'link-hint-copy-multiple-links)
  ('normal "gf" #'link-hint-open-link-at-point
           "RET" #'link-hint-open-link-at-point)
  :config
  (defun noct-terminal-link-hint-file (file)
    (find-file file)
    (goto-address-mode)
    (unwind-protect (link-hint-open-link)
      (kill-buffer)
      (start-process-shell-command "xdotool getactivewindow windowunmap")
      ;; (delete-frame)
      ))

  (defun noct-open ()
    "Open the thing at point.
Try with lsp or smart jump (if in a prog-mode buffer) then with hyperbole."
    (interactive)
    (or (when (derived-mode-p 'prog-mode)
          (cond ((bound-and-true-p lsp-mode)
                 (not (stringp (lsp-find-definition))))
                ((fboundp 'smart-jump-go)
                 ;; return nil instead of prompting when there is no definition
                 ;; at point
                 (cl-letf (((symbol-function 'xref--prompt-p) #'ignore))
                   (smart-jump-go)))))
        (when (fboundp 'action-key)
          (action-key))))

  (gsetq link-hint-action-fallback-commands (list :open #'noct-open)))

(use-package browse-url
  :ensure nil
  :config
  (gsetq browse-url-generic-program (getenv "BROWSER")
         browse-url-browser-function #'browse-url-generic))
#+end_src

* Version Control
[[https://github.com/tarsius/git-elisp-overview][List of git related packages]]
** Git Major Modes
#+begin_src emacs-lisp
;; https://github.com/magit/git-modes
(use-package git-modes)

(use-package gitignore-mode
  :ensure nil
  :mode "/.dockerignore\\'")
#+end_src

** Browse at Remote
#+begin_src emacs-lisp
(use-package browse-at-remote
  :general (general-t "RET" #'browse-at-remote))
#+end_src

** Git Link
#+begin_src emacs-lisp
(use-package git-link
  :general ('normal "gy" #'git-link))
#+end_src

** Git Gutter
This is the only package that allows in-buffer hunk staging that I'm aware of. It slows Emacs to a crawl in large files with a lot of unstaged changes (like this one).

Update: Git gutter seems to be faster than previously, but diff-hl is much faster and now supports not just staged faces but staging.
#+begin_src emacs-lisp
(use-package git-gutter
  :disabled t
  :ghook ('find-file-hook #'noct-maybe-enable-git-gutter)
  :general
  (general-t
    "gn" (list #'git-gutter:next-hunk :jump t)
    "ge" (list #'git-gutter:previous-hunk :jump t)
    "gh" #'git-gutter:stage-hunk
    "gi" #'git-gutter:revert-hunk)
  :blackout t
  :config
  (gsetq git-gutter:modified-sign "~"
         git-gutter:handled-backends '(git hg)
         ;; hide when no changes
         git-gutter:hide-gutter t
         git-gutter:update-interval 2)

  (gsetq git-gutter:modified-sign " "
         git-gutter:deleted-sign " "
         git-gutter:added-sign " ")

  ;; if switch to diff-hl and only use for hunk commands
  ;; (setq git-gutter:display-p nil)

  ;; stole colors from orderless
  (set-face-background 'git-gutter:modified "#72a4ff")
  (set-face-background 'git-gutter:added "#90d800")
  (set-face-background 'git-gutter:deleted "#ed92f8")

  (general-def noct-toggle-map "g" #'git-gutter-mode)

  (defun noct-maybe-enable-git-gutter ()
    "Enable git gutter except for in org init file."
    (unless (and buffer-file-name
                 (string= (file-name-nondirectory buffer-file-name)
                          "awaken.org"))
      (git-gutter-mode)))

  (noct-handle-popup (rx "*git-gutter:diff*")))
#+end_src

** Diff HL
Diff-hl also has a dired mode that seems to be faster than dired k.
#+begin_src emacs-lisp
(use-package diff-hl
  :blackout t
  ;; TODO defer, e.g. `find-file-hook'
  ;; :ghook ('dired-mode-hook #'diff-hl-dired-mode)
  :init
  (global-diff-hl-mode)
  (diff-hl-flydiff-mode)
  :config
  (gsetq diff-hl-show-staged-changes nil
         ;; do not want repeat map
         diff-hl-command-map nil)

  (general-def noct-toggle-map "D" #'diff-hl-mode)

  (general-def 'normal
    "gn" (list #'diff-hl-next-hunk :jump t)
    "ge" (list #'diff-hl-previous-hunk :jump t))

  (general-def 'operator
    "h" '(menu-item
          ""
          nil
          :filter
          (lambda (&optional _)
            (when (or (memq evil-this-operator
                            (list (key-binding [remap evil-delete])
                                  #'evil-delete)))
              (setq evil-inhibit-operator t)
              #'diff-hl-stage-current-hunk)))
    "o" '(menu-item
          ""
          nil
          :filter
          (lambda (&optional _)
            (when (or (memq evil-this-operator
                            (list (key-binding [remap evil-delete])
                                  #'evil-delete)))
              (setq evil-inhibit-operator t)
              #'diff-hl-revert-hunk))))
  (once-with 'magit
    (general-add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
    (general-add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh))

  (noct-handle-popup-same-window (rx "*diff-hl*"))

  ;; stole colors from orderless
  ;; (set-face-background 'diff-hl-change "#72a4ff")
  ;; (set-face-background 'diff-hl-insert "#90d800")
  ;; (set-face-background 'diff-hl-delete "#ed92f8")

  ;; TODO need a better solution than this
  ;; (defun noct-change-diff-location ()
  ;;   "Put diff markers in the margin or fringe based on (display-graphic-p)."
  ;;   (if (display-graphic-p)
  ;;       (when diff-hl-margin-mode
  ;;         (diff-hl-margin-mode -1))
  ;;     (diff-hl-margin-mode)))

  ;; (general-add-hook 'focus-in-hook #'noct-change-diff-location)
  )
#+end_src

** Magit
*** Setup
#+begin_src emacs-lisp
(use-package magit
  :defer-incrementally
  (dash f s with-editor git-commit package eieio transient)
  :general
  ('normal "S" #'magit-status-here)
  ('normal dired-mode-map "C" #'magit-clone)
  (general-spc
    "." #'magit-find-git-config-file
    "G" #'magit-find-file)
  (general-def 'normal
    :prefix "g"
    "a" #'magit-file-stage
    "b" #'magit-blame)
  (general-t
    "gr" #'magit-rebase-interactive
    "gl" #'magit-log-all
    "gL" #'magit-log-buffer-file
    "gc" #'magit-commit
    "gg" #'magit-clone
    "gp" #'magit-push
    ;; "gf" #'magit-file-dispatch
    "gf" #'magit-pull)
  :config
  (gsetq magit-diff-refine-hunk t
         magit-display-buffer-function #'display-buffer
         magit-blame-echo-style '(lines
                                  (show-lines . t)
                                  (show-message . t)))


  (defun noct-fix-magit-header-line (&rest _)
    (interactive)
    (set-face-background 'magit-header-line (face-background 'mode-line))
    (set-face-attribute 'magit-header-line nil :box nil))
  (noct-fix-magit-header-line)
  ;; TODO this doesn't work
  ;; (general-add-advice 'load-theme :after #'noct-fix-magit-header-line)
  )
#+end_src

*** Section Configuration
**** Status Mode Sections
Show staged changes then unstaged changes then untracked files.
#+begin_src emacs-lisp
(general-with-package 'magit
  (gsetq magit-status-sections-hook
         (cl-loop for section in magit-status-sections-hook
                  unless (memq section '(magit-insert-untracked-files
                                         magit-insert-unstaged-changes))
                  collect section
                  and when (eq section 'magit-insert-staged-changes)
                  append (list 'magit-insert-unstaged-changes
                               'magit-insert-untracked-files))))
#+end_src

**** Revision Mode Sections
Show GPG information when examining a commit (see [[https://github.com/magit/magit/issues/2797][this magit issue]]).
#+begin_src emacs-lisp
(general-with-package 'magit
  ;; https://gist.github.com/fice-t/c84c3bc7007d0d4bcacfeb2c0e42ac27
  (defun magit-rev-format-items (format &optional rev args)
    (with-temp-buffer
      (magit-rev-insert-format format rev args)
      (split-string (buffer-string) "\0")))

  (defun magit-insert-revision-gpg ()
    (let* ((rev magit-buffer-revision)
           (res (magit-rev-format-items "%G?%x00%GS%x00%GK%x00%GG" rev))
           (type (aref (car res) 0)))
      (unless (eq type ?N)
        (let* ((signer (cl-second res))
               (key (cl-third res))
               (raw (string-trim-right (cl-fourth res) "\n+"))
               face
               status)
          (pcase type
            (?G (setq face 'magit-signature-good)
                (setq status "VALID"))
            (?B (setq face 'magit-signature-bad)
                (setq status "BAD"))
            (?U (setq face 'magit-signature-untrusted)
                (setq status "UNKNOWN"))
            (?X (setq face 'magit-signature-expired)
                (setq status "EXPIRED"))
            (?Y (setq face 'magit-signature-expired-key)
                (setq status "EXPIRED KEY"))
            (?R (setq face 'magit-signature-revoked)
                (setq status "REVOKED"))
            (?E (setq face 'magit-signature-error)
                (setq status "ERROR")))
          (magit-insert-section (gpg status (not (eq type ?E)))
            (insert "GPG Status: "
                    (propertize (or status "") 'face face)
                    " (press "
                    (substitute-command-keys "\\[magit-section-toggle]")
                    " to toggle raw output)\n")
            (unless (string= signer "")
              (magit-insert-section (gpg signer)
                (insert "GPG Signer: "
                        (propertize signer 'face face)
                        "\n")))
            (unless (string= key "")
              (magit-insert-section (gpg key)
                (insert "GPG Key:    "
                        (propertize key 'face face)
                        "\n")))
            (insert "\n")
            (magit-insert-heading)
            (magit-insert-section (gpg raw)
              (insert (propertize raw 'face face)
                      "\n\n")))))))

  ;; https://github.com/magit/magit/issues/2797#issuecomment-338388572
  (magit-add-section-hook 'magit-revision-sections-hook
                          #'magit-insert-revision-gpg
                          #'magit-insert-revision-headers
                          t))
#+end_src

*** Window Positioning
#+begin_src emacs-lisp
(noct-handle-popup-same-window magit-status-mode)
(noct-handle-popup-same-window magit-log-mode)
(noct-handle-popup-same-window magit-cherry-mode)
(noct-handle-popup-same-window magit-log-select-mode)
(noct-handle-popup-other-window magit-revision-mode)
(noct-handle-popup-other-window-no-select magit-diff-mode)
(noct-handle-popup-same-window magit-process-mode)
(noct-handle-popup-same-window magit-stash-mode)
#+end_src

*** Keybindings
#+begin_src emacs-lisp
(general-with-package 'magit
  (general-def 'normal magit-mode-map
    "<tab>" #'magit-section-toggle
    "RET" #'magit-visit-thing
    ;; don't override window management keybindings; can just to H then N,E
    ;; "C-n" #'magit-section-forward
    ;; "C-e" #'magit-section-backward
    "N" #'magit-section-forward-sibling
    "E" #'magit-section-backward-sibling
    "H" #'magit-section-up
    "+" #'magit-diff-more-context
    ;; "-" #'magit-diff-less-context
    "=" #'magit-diff-default-context
    "$" #'magit-process-buffer
    "%" #'magit-worktree
    "a" #'magit-cherry-pick
    "b" #'magit-branch
    "B" #'magit-bisect
    "c" #'magit-commit
    "d" #'magit-diff
    "D" #'magit-diff-refresh
    ;; not using ediff commands
    ;; "e" #'magit-ediff-dwim
    ;; "E" #'magit-ediff
    ;; swap fetch and pull
    "f" #'magit-pull
    "F" #'magit-fetch
    "gr" #'magit-refresh
    "gR" #'magit-refresh-all
    ;; "h" #'magit-dispatch
    "?" #'magit-dispatch
    "i" #'magit-gitignore
    ;; e.g. discard
    "k" #'magit-delete-thing
    "K" #'magit-file-untrack
    "l" #'magit-log
    "L" #'magit-log-refresh
    "m" #'magit-merge
    "M" #'magit-remote
    "o" #'magit-submodule
    "O" #'magit-subtree
    "p" #'magit-push
    "q" #'magit-mode-bury-buffer
    "r" #'magit-rebase
    "R" #'magit-file-rename
    "T" #'magit-tag
    ;; "T" #'magit-notes
    "s" #'magit-stage
    "S" #'magit-stage-modified
    "u" #'magit-unstage
    "U" #'magit-unstage-all
    ;; swap revert and revert-no-commit
    "v" #'magit-revert
    "V" #'magit-revert-no-commit
    "w" #'magit-am
    "W" #'magit-patch
    "x" #'magit-reset-quickly
    "X" #'magit-reset
    "y" #'magit-show-refs
    ;; show commits in branch not merged upstream
    "Y" #'magit-cherry
    "z" #'magit-stash
    "Z" #'magit-stash
    ":" #'magit-git-command
    "!" #'magit-run)

  ;; use v for revert in log mode but for line staging in status mode
  (general-def 'normal magit-status-mode-map
    "v" #'evil-visual-line)

  (general-def 'visual magit-mode-map
    "s" #'magit-stage
    "u" #'magit-unstage)

  (general-def 'normal magit-log-mode-map
    "q" #'magit-log-bury-buffer
    "RET" #'magit-show-commit
    "v" #'magit-revert)

  ;; e.g. for c F
  (general-def 'normal magit-log-select-mode-map
    "RET" #'magit-log-select-pick)

  ;; `a' in log buffer; use cherry pick transient instead of apply
  (general-def magit-commit-section-map
    "a" #'magit-cherry-pick)

  (general-def 'normal magit-blame-mode
    :definer 'minor-mode
    ;; SPC G for `magit-find-file' to find files at revision
    "b" #'magit-blame
    "q" #'magit-blame-quit
    "E" #'magit-blame-previous-chunk
    "N" #'magit-blame-next-chunk
    "RET" #'magit-show-commit))
#+end_src

*** With Editor
#+begin_src emacs-lisp
(use-package with-editor
  :config
  (general-def 'normal with-editor-mode-map
    "RET" #'with-editor-finish
    "q" #'with-editor-cancel))
#+end_src

*** Git Commit
#+begin_src emacs-lisp
(general-with 'git-commit
  ;; so `fill-paragraph' works correctly for bullet points
  (gsetq git-commit-major-mode #'org-mode)
  (general-add-hook 'git-commit-mode-hook
                    #'auto-fill-mode))
#+end_src

*** Transient
#+begin_src emacs-lisp
(use-package transient
  :config
  ;; higlight infix arguments that do not have equivalent cli args
  (gsetq transient-highlight-mismatched-keys t
         ;; e.g. will now show since and until on log transient
         transient-default-level 7
         ;; TODO issue with it failing because \.\.\. in history
         transient-save-history nil
         ;; don't use this as it will break some commands
         ;; (e.g. `dirvish-setup-menu') probably because they rely on the buffer
         ;; staying the same and this selects a the transient window
         ;; '(noct-display-buffer-in-side-window-no-header
         ;;   (side . top))
         ;; default except at top
         transient-display-buffer-action
         '(display-buffer-in-side-window
           (side . top)
           (dedicated . t)
           (inhibit-same-window . t)
           (window-parameters
            (no-other-window . t)))
         transient-mode-line-format nil)
  (general-def transient-map
    ;; don't want to accidentally close
    ;; "<escape>" #'transient-quit-one
    "q" #'transient-quit-one))
#+end_src

*** Forge
#+begin_src emacs-lisp
(use-package forge
  :general
  (general-spc "'" #'forge-dispatch)
  ;; TODO would be nice to replace git-link and browse-at-remote entirely
  (general-t "g RET" #'forge-browse-remote)
  :init
  (general-with 'magit
    (require 'forge))
  :config
  (gsetq forge-owned-accounts `((,user-login-name))
         forge-topic-list-columns
         '(("#" 4
            forge-topic-list-sort-by-number
            (:right-align t) number nil)
           ("Title" 35 t nil title  nil)
           ("Milestone" 9 t nil milestone nil)
           ("State" 6 t nil state nil)
           ("Updated" 10 t nill updated nil)))

  (general-t
    :infix "g"
    "'" #'forge-dispatch)
  (general-def 'normal magit-mode-map
    "'" #'forge-dispatch)
  (general-def 'normal forge-topic-mode-map
    "i" #'forge-create-post
    "c" #'forge-edit-post)
  (general-def 'normal forge-post-mode-map
    "q" #'forge-post-cancel)

  ;; TODO bind forge-edit commands or magit-edit-thing

  (noct-handle-popup-same-window forge-topic-mode)
  (noct-handle-popup-same-window forge-post-mode)

  (general-with 'hardhat
    (general-pushnew
     (cons 'forge-post-mode (lambda (&rest _) t))
     hardhat-buffer-editable-functions)))
#+end_src

*** Magit delta
#+begin_src emacs-lisp
(use-package magit-delta
  ;; seems too slow
  :disabled t
  :ghook 'magit-mode-hook)
#+end_src

** Git Commit Insert Issue
Currently broken for github, but it’s no longer needed since forge supports it.
#+begin_src emacs-lisp
(use-package git-commit-insert-issue
  ;; depends on bitbucket which is no longer in melpa?
  :disabled t
  :ghook 'git-commit-mode-hook)
#+end_src

** Git Time Machine
#+begin_src emacs-lisp
(use-package git-timemachine
  :general (general-t "gt" #'git-timemachine)
  :config
  (general-def 'normal git-timemachine-mode-map
    "h" #'git-timemachine-show-previous-revision
    "i" #'git-timemachine-show-next-revision
    "a" #'git-timemachine-kill-abbreviated-revision
    "b" #'git-timemachine-blame
    "c" #'git-timemachine-show-commit
    "q" #'git-timemachine-quit))
#+end_src

** Smerge
#+begin_src emacs-lisp
(general-with-package 'smerge-mode
  ;; use `evil-define-minor-mode-key' because at least in some cases the
  ;; `evil-normalize-keymaps' workaround has been necessary and to give higher
  ;; priority than conflicting lsp-mode keybindings
  (general-def 'normal smerge-mode
    :definer 'minor-mode
    "RET" #'smerge-keep-current)

  ;; can temporarily override m bindings until conflicts resolved
  (general-m smerge-mode
    :definer 'minor-mode
    "k" #'smerge-vc-next-conflict
    "n" #'smerge-next
    "e" #'smerge-prev
    "u" #'smerge-keep-upper
    "l" #'smerge-keep-lower
    "a" #'smerge-keep-all))
#+end_src

** Vdiff
*** Setup
TODO
- should be able to handle visual line mode like vimdiff can (just more blank lines on one side); minor
- do something like this: https://oremacs.com/2017/03/18/dired-ediff/
- hydra

#+begin_src emacs-lisp
(defvar noct-no-truncate-lines-p nil)
(defvar noct-vdiff-disabled-zoom nil)
(defvar noct-vdiff-disabled-visual-lines nil)
(defvar noct-vdiff-enabled-truncation nil)

(defun noct-vdiff-setup ()
  "Alter modes/settings for proper hunk alignment with `vdiff-mode'.
Restore previous settings after disabling `vdiff-mode'."
  (cond ((bound-and-true-p vdiff-mode)
         (when (bound-and-true-p zoom-mode)
           (setq noct-vdiff-disabled-zoom t)
           (zoom-mode -1))
         (when visual-line-mode
           (setq noct-vdiff-disabled-visual-lines t)
           (visual-line-mode -1))
         (when (not truncate-lines)
           (setq noct-vdiff-enabled-truncation t)
           (toggle-truncate-lines +1)))
        (t
         (when noct-vdiff-disabled-zoom
           (setq noct-vdiff-disabled-zoom nil)
           (zoom-mode))
         (when noct-vdiff-disabled-visual-lines
           (setq noct-vdiff-disabled-visual-lines nil)
           (visual-line-mode))
         (when noct-vdiff-enabled-truncation
           (setq noct-vdiff-enabled-truncation nil)
           (toggle-truncate-lines -1)))))

(declare-function vdiff-merge-conflict "vdiff")
(defun noct-vdiff-resolve-conflicts ()
  "Run `vdiff-merge-conflict' on the current file."
  (interactive)
  (vdiff-merge-conflict buffer-file-name))

(use-package vdiff
  :general
  ;; resolve [m]erge conflicts
  (general-t "gm" #'noct-vdiff-resolve-conflicts)
  :gfhook #'noct-vdiff-setup
  :config
  ;; automatically highlight word differences
  (gsetq vdiff-auto-refine t)

  ;; bind dp and do
  ;; ~/src/forks/evil-collection/evil-collection-vdiff.el
  (evil-collection-init 'vdiff)

  (general-def 'visual (vdiff-mode vdiff-3way-mode)
    :definer 'minor-mode
    "p" #'vdiff-send-changes
    "o" #'vdiff-receive-changes)

  (general-def 'normal (vdiff-mode vdiff-3way-mode)
    :definer 'minor-mode
    "<tab>" #'vdiff-toggle-fold
    "mn" #'vdiff-next-hunk
    "me" #'vdiff-previous-hunk
    "mw" #'vdiff-toggle-whitespace
    "RET" #'vdiff-quit
    "gr" #'vdiff-refresh
    "q" #'vdiff-quit)

  ;; TODO would be preferable to have a setting for this
  ;; for example, stay on working directory buffer when running
  ;; `vdiff-magit-stage'
  (defun noct-vdiff-switch-to-b (&rest args)
    "Select the window containing buffer b.
Meant to be called after `vdiff-buffers' with its args."
    (select-window (get-buffer-window (cadr args))))

  (general-add-advice 'vdiff-buffers :after #'noct-vdiff-switch-to-b))
#+end_src

*** Magit Vdiff
#+begin_src emacs-lisp
(declare-function vdiff-magit-stage "vdiff-magit")
(defun noct-vdiff-stage ()
  "Run `vdiff-magit-stage' on the current file."
  (interactive)
  (vdiff-magit-stage buffer-file-name))

(use-package vdiff-magit
  :general
  (magit-mode-map
   "e" #'vdiff-magit-dwim
   "E" #'vdiff-magit)
  (general-t
    "gd" #'noct-vdiff-stage)
  :config
  (gsetq vdiff-magit-stage-is-2way t)

  (transient-replace-suffix 'magit-dispatch "e"
    '("e" "Vdiff (dwim)" vdiff-magit-dwim))
  (transient-replace-suffix 'magit-dispatch "E"
    '("E" "Vdiff transient" vdiff-magit)))
#+end_src

** Magit Todos
#+begin_src emacs-lisp
(use-package magit-todos
  :after magit
  :demand t
  :config (magit-todos-mode))
#+end_src

* Writing/Prose/Input
There is also artbollocks, which highlight certain weasel words like "very" and can give a readability score, but it's not nearly as sophisticated as other software like languagetool. I'm currently using vale over write-good and proselint, but I haven't tried anything extensively. I need to try proselint more (flycheck has integration with by default). Some of the warnings/errors these packages give can be annoying.

** Clipetty
Clipetty gives clipboard integration in terminal frames. Unlike xclip, it works fine even if enabled for a server that has both graphical and terminal frames. Currently only copying is supported (see [[https://github.com/spudlyo/clipetty/issues/10][issue 10]]).
#+begin_src emacs-lisp
(use-package clipetty
  :init
  (general-after-tty
    (global-clipetty-mode))
  :blackout t)
#+end_src

** Langtool
Quite slow in larger buffers and not integrated with flycheck. Languagetool itself is a pretty impressive piece of software though with ~30k commits currently.
#+begin_src emacs-lisp
;; grammar checking
(use-package langtool
  :config
  (gsetq langtool-default-language "en-US"
         langtool-java-classpath
         "/usr/share/languagetool:/usr/share/java/languagetool/*"))
#+end_src

** Powerthesaurus
#+begin_src emacs-lisp
(noct-use ( :elpaca powerthesaurus
            :host github
            ;; https://github.com/SavchenkoValeriy/emacs-powerthesaurus/issues/40
            ;; https://github.com/doomelpa/powerthesaurus/pull/1
            :repo "doomelpa/powerthesaurus")
  (general-def 'normal text-mode-map "N" #'powerthesaurus-lookup-dwim)
  (noct-handle-popup-same-window (rx "*Powerthesaurus")))
#+end_src

** Typo
For typographical editing (not fixing typos).
#+begin_src emacs-lisp
(use-package typo
  :general (noct-toggle-map "\"" #'typo-mode))
#+end_src

** Vale
[[https://github.com/errata-ai/vale][Value]] supports proselint and write-good styles with configuration.
#+begin_src emacs-lisp
(use-package flycheck-vale
  :disabled t
  :after flycheck
  :demand t
  :config (flycheck-vale-setup))
#+end_src

** Fcitx
#+begin_src emacs-lisp
(use-package fcitx
  ;; doesn't work with fcitx5
  :disabled t
  ;; :when (executable-find "fcitx")
  :init
  (general-add-hook
   'evil-insert-state-entry-hook
   (noct-defun noct-maybe-require-fcitx ()
     "Require fcitx if the buffer is writable and not derived from prog-mode."
     (unless (or buffer-read-only
                 (derived-mode-p 'prog-mode))
       (require 'fcitx)))
   nil
   nil
   #'identity)
  :config
  (fcitx-aggressive-setup))
#+end_src

** Spelling
*** Flyspell
**** Setup
#+begin_src emacs-lisp
;; it's way too slow; not using for highlighting
(use-package flyspell
  :disabled t
  :ensure nil
  ;; :ghook
  ;; ('text-mode-hook #'turn-on-flyspell)
  ;; ;; will check just comments and strings
  ;; ('prog-mode-hook #'flyspell-prog-mode)
  :blackout t)
#+end_src

**** Flyspell Lazy
This makes things less convenient (there are some cases where mispellings aren't detected), but flyspell is usually the issue when I'm having input lag and profile.
#+begin_src emacs-lisp
(use-package flyspell-lazy
  :disabled t
  :after flyspell
  :init (flyspell-lazy-mode 1))
#+end_src

**** Flyspell Visible Mode
=flyspell-visible-mode= seems like it might be a better alternative to =flyspell-lazy=, but =spell-fu= is working well enough for me at the moment.

**** Flyspell Correct
#+begin_src emacs-lisp
(use-package flyspell-correct
  :disabled t
  :config
  ;; https://github.com/clemera/frog-menu#example
  (defun frog-menu-flyspell-correct (candidates word)
    "Run `frog-menu-read' for the given CANDIDATES.

List of CANDIDATES is given by flyspell for the WORD.

Return selected word to use as a replacement or a tuple
of (command . word) to be used by `flyspell-do-correct'."
    (let* ((corrects (if flyspell-sort-corrections
                         (sort candidates 'string<)
                       candidates))
           (actions `(("."   "Save word"         (save    . ,word))
                      ("C-a" "Accept (session)"  (session . ,word))
                      ("C-b" "Accept (buffer)"   (buffer  . ,word))
                      ("C-c" "Skip"              (skip    . ,word))))
           (prompt   (format "Dictionary: [%s]"  (or ispell-local-dictionary
                                                     ispell-dictionary
                                                     "default")))
           (res      (frog-menu-read prompt corrects actions)))
      (unless res
        (error "Quit"))
      (when (eq (car res) 'save)
        (spell-fu-word-add)
        (error "Handled with spell-fu"))
      res))

  (gsetq flyspell-correct-interface #'frog-menu-flyspell-correct))
#+end_src

**** Ace Flyspell
#+begin_src emacs-lisp
(use-package ace-flyspell
  :disabled t
  :config
  (gsetq ace-flyspell-handler #'flyspell-correct-at-point)

  (defun noct-flyspell-dwim (arg)
    "Correct or save a word.
If there is a misspelled word at point, correct it. With a prefix ARG, save the
word in the dictionary. Otherwise, select a misspelled word using avy. Save when
pressing \".\" before selecting the word. Otherwise, correct it."
    (interactive "P")
    (let ((avy-dispatch-alist '((?\. . spell-fu-word-add))))
      (if (cl-some #'spell-fu-overlay-p (overlays-at (point)))
          (if arg
              (spell-fu-word-add)
            (funcall ace-flyspell-handler))
        ;; doesn't have an autoload
        (ace-flyspell-correct-word)))))
#+end_src

*** Flycheck Hunspell
#+begin_src emacs-lisp
(use-package flycheck-hunspell
  :disabled t
  :ensure ( :host github
            :repo "leotaku/flycheck-hunspell")
  :after flycheck
  :demand t
  :config
  (cl-pushnew 'plain-hunspell-dynamic flycheck-checkers)
  (gsetq ispell-really-hunspell t
         ispell-dictionary "en_US"))
#+end_src

*** Ispell
#+begin_src emacs-lisp
(use-package ispell
  :ensure nil
  :config

  ;; http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html
  ;; https://blog.binchen.org/posts/how-to-spell-check-functionvariable-in-emacs.html
  ;; https://blog.binchen.org/posts/aspell-0-60-8-will-have-direct-support-for-camelcase-words.html
  ;; https://battlepenguin.com/tech/aspell-and-hunspell-a-tale-of-two-spell-checkers/
  ;; Y

  (gsetq ispell-program-name "aspell"
         ispell-local-dictionary "en_US"
         ispell-local-dictionary-alist
         '(("en_US"
            "[[:alpha:]]"
            "[^[:alpha:]]"
            "[']"
            nil
            ("-d" "en_US")
            nil
            utf-8)))

  ;; TODO https://gitlab.com/ideasman42/emacs-spell-fu/-/issues/4
  (gsetq ispell-personal-dictionary "~/.aspell.en.pws")

  ;; https://old.reddit.com/r/emacs/comments/fxs92h/spell_checkers_in_emacs_in_2020/
  ;; aspell works with contractions, camelCase, kebab-case, etc.
  (gsetq ispell-extra-args
         '("--sug-mode=ultra" "--lang=en_US" "--camel-case")))
#+end_src

*** Jinx
Jinx similar to spell-fu, but is using enchant.  It gives a lot fewer false positives than aspell so far.  It's so much better than anything else, I will probably remove all other packages.
 #+begin_src emacs-lisp
;; must be installed through nix to work with Emacs installed through nix
(if noct-emacs-from-nix
    ;; necessary when installed through nix
    (autoload 'global-jinx-mode "jinx")
  (elpaca jinx))
(setup jinx
  (noct-after-buffer (global-jinx-mode))
  (:config
    (defun noct-jinx-overlay-p (overlay)
      (eq (overlay-get overlay 'category) 'jinx-overlay))

    (defun noct-avy-jinx-correct ()
      (interactive)
      (if (cl-some #'noct-jinx-overlay-p (overlays-at (point)))
          (jinx-correct-nearest)
        (let (positions
              prev-pos
              (win-end (window-end))
              (avy-action (lambda (pos)
                            (goto-char pos)
                            (jinx-correct-nearest))))
          (save-excursion
            (goto-char (window-start))
            (setq prev-pos (point))
            (while (progn
                     (ignore-errors (jinx-next 1))
                     (and (> (point) prev-pos)
                          (<= (point) win-end)))
              (setq prev-pos (point))
              (when-let ((jinx-overlay (cl-find-if #'noct-jinx-overlay-p
                                                   (overlays-at (1- (point))))))
                (push (overlay-start jinx-overlay) positions))))
          (when positions
            (avy-process positions)))))
    (general-r "s" #'noct-avy-jinx-correct)))
 #+end_src

*** Spell Fu
#+begin_src emacs-lisp
(use-package spell-fu
  :disabled t
  :when (executable-find "aspell")
  :init
  (defun noct-maybe-enable-spell-fu (orig-fun &rest args)
    (unless buffer-read-only
      (apply orig-fun args)))
  (general-add-advice 'spell-fu-mode-turn-on :around #'noct-maybe-enable-spell-fu)
  (noct-after-buffer (spell-fu-global-mode))
  :config
  (gsetq-default spell-fu-faces-exclude
                 (cl-union '(org-block org-block-begin-line)
                           spell-fu-faces-exclude))
  ;; repurpose ace-flyspell for spell-fu
  (defun spell-fu-overlay-p (o)
    "Return true if O is an overlay used by spell-fu."
    (and (overlayp o) (overlay-get o 'spell-fu-mode)))

  (defun ace-flyspell--has-spell-fu-overlay-p (ovs)
    (let ((r nil))
      (while (and (not r) (consp ovs))
        (if (spell-fu-overlay-p (car ovs))
            (setq r t)
          (setq ovs (cdr ovs))))
      r))

  (defun ace-flyspell--collect-spell-fu-candidates ()
    (save-excursion
      (save-restriction
        (narrow-to-region (window-start) (window-end (selected-window) t))
        (let ((pos (point-min))
              (pos-max (point-max))
              (pos-list nil)
              (word t))
          (goto-char pos)
          (while (and word (< pos pos-max))
            (setq word (flyspell-get-word t))
            (when word
              (setq pos (nth 1 word))
              (let* ((ovs (overlays-at pos))
                     (r (ace-flyspell--has-spell-fu-overlay-p ovs)))
                (when r
                  (push pos pos-list)))
              (setq pos (1+ (nth 2 word)))
              (goto-char pos)))
          (nreverse pos-list)))))

  (advice-add 'ace-flyspell--collect-candidates
              :override #'ace-flyspell--collect-spell-fu-candidates))
#+end_src

* Other Major Mode Configuration
** AHK
#+begin_src emacs-lisp
(use-package ahk-mode)
#+end_src

** Alda
#+begin_src emacs-lisp
(use-package alda-mode
  :config
  (general-m alda-mode-map
    "b" #'alda-play-buffer))
#+end_src

** Apropos
#+begin_src emacs-lisp
(use-package apropos
  :ensure nil
  :init
  ;; TODO can this be put in :config?
  (noct-handle-popup apropos-mode)
  :config
  (gsetq apropos-do-all t)

  (general-def apropos-mode-map "q" #'quit-window))
#+end_src

** TODO AUCTeX
# https://www.emacswiki.org/emacs/AUCTeX
# https://www.gnu.org/software/auctex/manual/auctex/Quick-Start.html
# https://tex.stackexchange.com/questions/20843/useful-shortcuts-or-key-bindings-or-predefined-commands-for-emacsauctex
# http://wiki.contextgarden.net/What_is_ConTeXt
# http://pmrb.free.fr/contextref.pdf

** Conf Mode
#+begin_src emacs-lisp
(use-package conf-mode
  :ensure nil
  :mode ("rc\\'" . conf-unix-mode)
  :gfhook
  ('(conf-unix-mode-hook conf-xdefaults-mode-hook) #'outline-minor-mode))
#+end_src

** Comint
#+begin_src emacs-lisp
(use-package comint
  :ensure nil
  :config
  (general-def 'insert comint-mode-map
    ;; history
    "<up>" #'comint-previous-input
    "<down>" #'comint-next-input))
#+end_src

** Compilation mode
#+begin_src emacs-lisp
(general-with-package 'compile
  (gsetq compilation-always-kill t
         ;; save modified buffers without asking
         compilation-ask-about-save nil
         compilation-scroll-output 'first-error)

  ;; http://stackoverflow.com/a/20788581/2744245
  (defun my-colorize-compilation-buffer ()
    (require 'ansi-color)
    (when (eq major-mode 'compilation-mode)
      (ansi-color-apply-on-region compilation-filter-start (point-max))))

  (general-add-hook 'compilation-filter-hook #'my-colorize-compilation-buffer)

  (noct-handle-popup compilation-mode))
#+end_src

** Crontab
#+begin_src emacs-lisp
(use-package crontab-mode
  ;; kinda works for fcron
  :mode "fcrontab")
#+end_src

** Debugger
#+begin_src emacs-lisp
(general-with 'debug
  (general-def 'normal debugger-mode-map
    "q" #'top-level)

  (general-after 'evil
    (general-add-hook 'debugger-mode-hook #'evil-normalize-keymaps)))
#+end_src

** Diff Mode
#+begin_src emacs-lisp
(use-package diff-mode
  :ensure nil
  :config
  (general-def 'normal diff-mode-map
    "q" #'quit-window))
#+end_src

** Helpful
#+begin_src emacs-lisp
(use-package helpful
  :general
  (general-def help-map
    "RET" #'helpful-at-point
    "f" #'helpful-callable
    "v" #'helpful-variable
    "k" #'helpful-key
    "o" #'helpful-symbol)
  :init
  ;; using this instead of binding them directly allows taking an alternate action
  ;; without also opening the helpful buffer
  (gsetq counsel-describe-function-function #'helpful-callable
         counsel-describe-variable-function #'helpful-variable)
  :config
  (general-def 'normal helpful-mode
    :definer 'minor-mode
    "q" #'quit-window)

  (noct-handle-popup-same-window helpful-mode))
#+end_src

** Info mode
#+begin_src emacs-lisp
(use-package info
  :ensure nil
  :config
  (general-pushnew (expand-file-name "info" user-emacs-directory)
                   Info-additional-directory-list)

  ;; overriding `describe-input-method' (which I don't need bound)
  (general-def help-map "I" #'Info-history)

  ;; keybindings partially overlap with evil collection
  (general-def 'normal Info-mode-map
    "q" #'quit-window
    "RET" #'Info-follow-nearest-node
    ;; "h" #'Info-prev
    ;; "i" #'Info-next
    ;; can go through entire manual with these (will have to use `Info-up' if
    ;; using above keybindings)
    "h" #'Info-backward-node
    "i" #'Info-forward-node
    ;; not every manual has index
    "I" #'Info-index
    "l" #'Info-history
    "<tab>" #'Info-next-reference
    "S-<tab>" #'Info-prev-reference
    "u" #'Info-up
    "U" #'Info-top-node
    "d" #'Info-directory
    "gt" 'Info-toc
    ;; TODO vs `Info-goto-node'? vs `Info-follow-reference'
    [remap consult-imenu] #'Info-menu
    "g?" #'Info-summary))
#+end_src

** Lilypond
#+begin_src emacs-lisp
(use-package lilypond-mode
  ;; TODO from whence does lilypond come?
  :disabled
  :config
  (defun noct-lilypond-generate-midi ()
    "Produce a MIDI for the current lilypond file."
    (interactive)
    (async-shell-command (concat "lilypond " (shell-quote-argument buffer-file-name))))

  (general-m LilyPond-mode-map
    "c" #'noct-lilypond-generate-midi))
#+end_src

** Markdown
#+begin_src emacs-lisp
(use-package vmd-mode)

(use-package markdown-mode
  :config
  (general-m markdown-mode-map
    ;; preview
    "p" #'vmd-mode))
#+end_src

** Message
#+begin_src emacs-lisp
(general-with 'evil
  ;; (evil-set-initial-state 'messages-buffer-mode 'normal)
  ;; this won't work (runs too soon it seems)
  ;; (general-add-hook 'messages-buffer-mode-hook #'evil-normalize-keymaps)
  ;; this doesn't work
  ;; (general-add-advice 'after-find-file
  ;;                     :after (lambda (&rest _)
  ;;                              (when (eq major-mode 'messages-buffer-mode)
  ;;                                (evil-normalize-keymaps)
  ;;                                t))
  ;;                     nil
  ;;                     #'identity)
  ;; this is what fixes things
  ;; (general-add-hook 'post-command-hook
  ;;                   (lambda (&rest _)
  ;;                     (when (eq major-mode 'messages-buffer-mode)
  ;;                       (evil-normalize-keymaps)
  ;;                       t))
  ;;                   nil
  ;;                   nil
  ;;                   #'identity)
  (general-add-hook 'elpaca-after-init-hook
                    (lambda (&rest _)
                      (when-let ((messages-buffer (get-buffer "*Messages*")))
                        (with-current-buffer messages-buffer
                          (evil-normalize-keymaps))))
                    nil
                    nil
                    t))
#+end_src

** Multiple Major Modes/Polymode
#+begin_src emacs-lisp
(use-package poly-org
  :disabled t
  ;; TODO shouldn't be enabled by default
  :general (noct-toggle-map "o" #'poly-org-mode)
  :config
  (general-with 'lispy
    (mapc (lambda (x)
            (advice-add x :around #'pm-execute-narrowed-to-span))
          (append (apropos-internal "^lispy-" #'commandp)
                  (apropos-internal "^special-lispy-" #'commandp))))

  (general-spc poly-org-mode-map
    "'" #'noct-org-edit-special)
  ;; can still be useful in some cases
  (general-m poly-org-mode-map
    "'" #'noct-org-edit-special)

  (general-add-advice '(outline-toggle-children
                        consult-outline
                        consult-org-heading
                        noct-org-edit-special)
                      :around #'polymode-with-current-base-buffer))
#+end_src

** Org Mode
All of my org config is in unclean.org.  I will gradually move it here.

*** Setup
#+begin_src emacs-lisp
(defun noct-org-setup ()
  ;; don't auto indent with o/O (I don't use indentation in org mode)
  (gsetq evil-auto-indent nil))

(use-package org-contrib)
(use-package org
  :defer-incrementally
  calendar find-func format-spec org-macs org-compat org-faces org-entities
  org-list org-pcomplete org-src org-footnote org-macro ob org org-agenda
  org-capture
  :gfhook #'noct-org-setup
  :init
  ;; (cl-pushnew org-modules 'ol-man)

  :config
  (gsetq org-man-command #'woman
         ;; can only mark something as done when subheadings are also done
         ;; don't insert newlines with `org-insert-new-heading'
         org-blank-before-new-entry '((heading)
                                      (plain-list-item . auto))
         ;; don't allow editing of folded/hidden sections
         ;; doesn't actually work that well
         org-catch-invisible-edits 'error
         ;; can't think of a case where I would want to split
         org-M-RET-may-split-line nil
         ;; e.g. refile to top not bottom
         org-reverse-note-order t)

  ;; basic visual settings
  (gsetq org-ellipsis " ▼"
         ;; gray all but last star in heading
         org-hide-leading-stars t
         ;; hide italics/bold/etc. markers
         org-hide-emphasis-markers nil
         ;; show entities as their symbol (e.g. show \euro as €)
         org-pretty-entities t
         ;; require {} for sub/superscript after ^/_
         org-use-sub-superscripts '{}
         ;; until org-appear is fixed
         org-descriptive-links nil
         org-id-link-to-org-use-id t
         ;; never show blank line when folding
         org-cycle-separator-lines 0
         ;; don't indent headings or text below them
         org-adapt-indentation nil)

  ;; TODO there should be a lineage-full
  ;; show heading, ancestors, /and siblings/ by default
  (setf (map-elt org-show-context-detail 'default) 'lineage)
  ;; only hide siblings for sparse trees
  ;; also show contents of matched headings by default
  (setf (map-elt org-show-context-detail 'tags-tree) 'ancestors-full)

  ;; open file links in the same window
  (setf (map-elt org-link-frame-setup 'file) #'find-file))
#+end_src

*** Todo States
#+begin_src emacs-lisp
(general-with 'org
  (gsetq org-enforce-todo-dependencies t
         org-enforce-todo-checkbox-dependencies t)

  (general-m org-mode-map
    "t" #'org-todo
    "o" #'org-insert-todo-heading-respect-content
    "," #'org-priority
    "E" #'org-priority-up
    "N" #'org-priority-down))
#+end_src

*** Basic Navigation, Outline, and Folding
#+begin_src emacs-lisp
(general-with 'org
  ;; affects `org-beggining-of-line' and `org-end-of-line' even though not using
  ;; C-a and C-e for them
  (gsetq org-special-ctrl-a/e t)

  (general-def '(insert normal) org-mode-map
    [remap evil-beginning-of-visual-line] #'org-beginning-of-line
    [remap evil-end-of-visual-line] #'org-end-of-line)

  (defun noct-beginning-of-visible-heading ()
    (interactive)
    (org-back-to-heading)
    (evil-insert-state))

  (defun noct-org-toggle-fold ()
    (interactive)
    (if (invisible-p (point))
        (org-reveal)
      ;; TODO there some issue where `org-folded-p' result can be wrong
      ;; see `outline-toggle-children@fix-for-org-fold'
      ;; (evil-toggle-fold)
      (if (save-excursion
            (unless (org-at-heading-p)
              (org-back-to-heading))
            (invisible-p (line-end-position)))
          (evil-open-fold)
        ;; workaround... doesn't hide immediately unless move point out of tree
        (org-back-to-heading)
        (org-fold-hide-subtree))))

  (general-def 'normal org-mode-map
    "H" #'noct-beginning-of-visible-heading
    "^" #'org-beginning-of-line
    "$" #'org-end-of-line
    "<tab>"  #'noct-org-toggle-fold
    ;; promoting/demoting headings, list items, and deleting/inserting table
    ;; columns
    "<" #'org-shiftmetaleft
    ">" #'org-shiftmetaright)

  (general-def 'normal org-mode-map
    :infix "z"
    ;; unlike zr also shows all drawers
    "R" #'org-fold-show-all
    "M" #'outline-hide-body)

  (general-m org-mode-map
    ;; navigation/ heading alteration
    "<tab>" #'org-cycle
    ;; not necessary if I end up binding something to C-c C-c
    "m" #'org-toggle-checkbox
    ;; convert from list item to heading
    "8" #'org-ctrl-c-star
    ;; convert from heading to list item
    "-" #'org-ctrl-c-minus
    "/" #'org-sparse-tree
    ;; narroW
    "w" #'org-narrow-to-subtree
    "W" #'widen))
#+end_src

*** Tags and Properties
https://orgmode.org/manual/Tag-searches.html#Tag-searches
#+begin_src emacs-lisp
(general-with 'org
  (general-m org-mode-map
    ;; can use C-c C-c on heading
    ";" #'org-set-tags-command
    "P" #'org-set-property))
#+end_src

*** Capturing/Refiling/Archiving
#+begin_src emacs-lisp
(general-with 'org
  (gsetq org-default-notes-file "~/ag-sys/notes/tasks.org"
         org-refile-targets
         '((nil :maxlevel . 5))
         ;; show full paths
         org-refile-use-outline-path t
         ;; show all subheadings immediately
         org-outline-path-complete-in-steps nil)

  ;; universal prefix to visit template; twice to go to last stored capture item
  ;; in its buffer for log day (adding things to log without going there)
  (general-spc "SPC" #'org-capture)

  (general-m org-mode-map
    "r" #'org-refile
    "A" #'org-archive-subtree-default-with-confirmation)

  (general-def 'normal org-capture-mode-map
    "RET" #'org-capture-finalize
    "q" #'org-capture-kill
    "m r" #'org-capture-refile)
  (general-def org-capture-mode-map
    [remap evil-save-and-close] #'org-capture-finalize
    [remap evil-save-modified-and-close] #'org-capture-finalize
    [remap evil-quit] #'org-capture-kill)

  (defun noct-org-capture-reuse-window-advice (fun &rest args)
    (cl-letf (((symbol-function 'switch-to-buffer-other-window)
               #'switch-to-buffer)
              ((symbol-function 'delete-other-windows)
               #'ignore))
      (apply fun args)))
  ;; no longer works
  ;; (general-add-advice 'org-capture
  ;;                     :around #'noct-org-capture-reuse-window-advice)
  (noct-handle-popup-same-window (rx "CAPTURE"))

  ;; TODO doesn't work?
  (noct-handle-popup (rx "*Org Select*"))

  (defun noct-org-capture-setup ()
    (evil-insert-state nil))
  (general-add-hook 'org-capture-mode-hook #'noct-org-capture-setup))
#+end_src

*** Capture Templates
http://orgmode.org/manual/Capture-templates.html#Capture-templates
http://orgmode.org/manual/Template-elements.html#Template-elements
#+begin_src emacs-lisp
(noct-use org-reverse-datetree)

(general-with 'org
  (defconst noct-org-created-property-and-drawer
    ;; %(org-insert-time-stamp (org-read-date nil t \"\") t t)
    ":PROPERTIES:
:CREATED: %U
:ID: %(org-id-new)
:END:"
    "String for capture templates to insert the creation time.
Only used for new headline entries.")

  (defun noct-todo-heading-template (keyword prompt)
    "Return a string template for a heading with the todo KEYWORD.
Prompt for a heading title with the PROMPT string."
    (format "* %s %%?\n%s\n%%i\n"
            keyword
            noct-org-created-property-and-drawer))

  (defun noct-goto-todo-end ()
    "Go to end of current project's todo file."
    (noct-goto-todo)
    (goto-char (point-max)))

  (defvar noct-pre-capture-heading "")
  (defun noct-store-org-heading-name (&rest _)
    (let ((heading (when (eq major-mode 'org-mode)
                     (org-get-heading t))))
      (setq noct-pre-capture-heading
            (if heading
                (substring-no-properties heading)
              ""))))
  (general-add-advice 'org-capture :before #'noct-store-org-heading-name)

  (gsetq org-capture-templates
         ;; I manually set the deadline and/or schedule in the capture buffer
         `(("t" "Actionable Todo" entry
            (file+headline "~/ag-sys/notes/tasks.org" "Tasks")
            ,(noct-todo-heading-template "TODO" "todo description"))
           ("i" "Inbox Todo" entry
            (file+headline "~/ag-sys/notes/tasks.org" "Inbox")
            ,(noct-todo-heading-template "TODO" "todo description"))
           ("p" "Project" entry
            (file+headline "~/ag-sys/notes/tasks.org" "Inbox")
            ,(noct-todo-heading-template "PROJECT" "project name/description"))
           ("e" "Calendar event" entry
            (file+headline "~/ag-sys/notes/tasks.org" "Inbox")
            ,(noct-todo-heading-template "EVENT" "event description"))
           ("h" "Copy as hot list item" entry
            ;; TODO find a way to automatically insert link with org superlinks
            (file+headline "~/ag-sys/notes/tasks.org" "Hot List")
            "* %(symbol-value 'noct-pre-capture-heading)\n%?")
           ("j" "Journal entry" plain
            (file+datetree "~/ag-sys/notes/journal.org")
            "%?")
           ("f" "Feature or bug" entry
            #'noct-goto-todo-end
            ,(noct-todo-heading-template "TODO" "feature/bug description"))
           ("c" "Note for the clocked in task" item
            ;; (clock) doesn't work for this
            (file+function "~/ag-sys/notes/tasks.org"
                           org-clock-jump-to-current-clock)
            "- %?"
            ;; since newest clock is on top, put newest note on top
            ;; TODO could be confusing in org agenda since it's the opposite
            ;; no
            ;; :prepend t
            )
           ("s" "Sleep log" plain
            (file+function "~/ag-sys/else/sleep.org"
                           org-reverse-datetree-goto-date-in-file)
            "%?")
           ;; use %a and %:keywords if start capturing mail
           ;; also %^g
           )))
;; if ever add something specific to mail
;; (setq org-capture-templates-contexts
;;       '(("p" (in-mode . "message-mode"))))
#+end_src

*** Scheduling/Deadlines/Timestamps
#+begin_src emacs-lisp
(general-with 'org
  (defun noct-org-time-stamp ()
    "Insert a timestamp directly after the current heading.
If there is already a timestamp, edit it instead of creating a new one."
    (interactive)
    (save-excursion
      (org-back-to-heading t)
      (forward-line)
      (if (org-at-timestamp-p)
          (org-time-stamp nil)
        (evil-insert-newline-above)
        (org-insert-time-stamp (current-time)))))

  (general-m org-mode-map
    ;; date-based event (e.g. appointment or meeting; only shows up on that day
    ;; in the agenda)
    "." #'noct-org-time-stamp
    ;; to schedule when should start working on a project/task (shows up in
    ;; agenda starting that day and until completed)
    "s" #'org-schedule
    ;; to set a date by which a task/project must be completed (shows up in
    ;; agenda `org-deadline-warning-days' (14) or the specified number of
    ;; warning days in the timestamp before and until completed)
    "d" #'org-deadline))
#+end_src

*** Org Sorting
#+begin_src emacs-lisp
(general-with 'org
  (gsetq org-priority-default (string-to-char "D"))

  ;; TODO don't expand headings
  (defun noct-org-sort-key ()
    "Return value for sorting by priority, breaking ties with todo keyword pos."
    (let* ((todo-keyword (org-entry-get (point) "TODO"))
           (todo (cl-dolist (keywords org-todo-sets 99)
                   (when-let ((index (cl-position todo-keyword keywords
                                                  :test #'equal)))
                     (cl-return-from nil index))))
           (priority (org-entry-get (point) "PRIORITY"))
           (priority (if priority
                         (string-to-char priority)
                       (string-to-char "D"))))
      (format "%03d %02d" priority todo)))

  (defun noct-org-sort ()
    "Sort subheadings of parent heading by priority then todo state."
    (interactive)
    ;; marker doesn't work
    (let ((id (org-id-get-create)))
      (unwind-protect
          (progn
            ;; (ignore-errors
            ;;   (org-sort-entries nil ?f #'noct-org-sort-key))
            (save-excursion
              (outline-up-heading 1)
              (ignore-errors
                (org-sort-entries nil ?f #'noct-org-sort-key))))
        (org-id-goto id))))

  ;; automatically resort after priority/todo state changes

  (general-add-hook 'org-after-todo-state-change-hook
                    #'noct-org-sort)
  ;; (general-remove-hook 'org-after-refile-insert-hook
  ;;                      #'noct-org-sort)
  ;; TODO get refile sorting working
  (general-add-advice 'org-priority :after #'noct-org-sort))
#+end_src

*** Tables
#+begin_src emacs-lisp
(use-package org-table
  :ensure nil
  ;; always show table headers
  ;; massively slows down scrolling etc in awaken
  ;; :ghook ('org-mode-hook #'org-table-header-line-mode)
  ;; org tables in other modes
  :general (noct-toggle-map "T" #'orgtbl-mode))
#+end_src

*** Org Src
#+begin_src emacs-lisp
(defun noct-org-edit-special ()
  "`org-edit-special' but jump to the next source block if not at one."
  (interactive)
  (unless (ignore-errors (org-edit-special))
    ;; broken
    ;; (org-in-src-block-p)
    (org-babel-next-src-block)
    (org-edit-special)))

(defun noct-org-src-exit-save ()
  "To prevent the source buffer from being marked as edited."
  (interactive)
  (org-edit-src-save)
  (org-edit-src-exit))

(general-with 'org
  (general-m org-mode-map
    "'" #'noct-org-edit-special))

(general-with 'org-src
  (blackout 'org-src-mode " λ")

  ;; don't indent my source blocks
  (gsetq org-src-preserve-indentation t
         ;; just switch to the existing buffer
         org-src-ask-before-returning-to-edit-buffer nil
         org-edit-src-content-indentation 0
         org-edit-src-auto-save-idle-delay auto-save-timeout)

  (general-m org-src-mode
    :definer 'minor-mode
    "'" #'noct-org-src-exit-save)

  (general-def org-src-mode-map
    [remap save-buffer] #'org-edit-src-save))
#+end_src

*** Org Export
#+begin_src emacs-lisp
(general-with 'org
  (general-m org-mode-map "x" #'org-export-dispatch))
#+end_src

*** Org Undo Granularity
#+begin_src emacs-lisp
(general-with 'org
  (noct-add-undo-bounds 'org-yank)
  (noct-add-undo-bounds 'org-fill-paragraph))
#+end_src

*** External/Contrib
**** Org Appear
Show invisible things when point is on them in org (e.g. links).  I have currenly disabled it since it constantly flickers when typing for me (see [[https://github.com/awth13/org-appear/issues/34][here]]).
#+begin_src emacs-lisp
(defun noct-org-appear-setup ()
  "Set up org-appear in thecurrent buffer to show when in insert state."
  (general-add-hook 'evil-insert-state-entry-hook
                    #'org-appear-manual-start
                    nil
                    t)
  (general-add-hook 'evil-insert-state-exit-hook
                    #'org-appear-manual-stop
                    nil
                    t))

(use-package org-appear
  :disabled t
  :ghook 'org-mode-hook
  :gfhook #'noct-org-appear-setup
  :config
  (gsetq org-appear-trigger 'manual
         org-appear-autolinks t))
#+end_src

**** Org Block Capf
Use by typing < then ~complete-symbol~.
#+begin_src emacs-lisp
(noct-use ( :elpaca org-block-capf
            :host github
            :repo "xenodium/org-block-capf")
  (gsetq org-block-capf-auto-indent nil)
  (general-add-hook
   'org-mode-hook
   #'org-block-capf-add-to-completion-at-point-functions))
#+end_src

**** Ox Hugo
#+begin_src emacs-lisp
(noct-use ox-hugo
  (general-add-advice 'after-find-file
                      :before
                      (noct-defun noct-maybe-enable-org-hugo-auto-export
                          (&rest _)
                        (when (noct-blog-dir-p buffer-file-name)
                          (org-hugo-auto-export-mode))))
  (:require-once "ox"))
#+end_src

**** Org Cv
#+begin_src emacs-lisp
;; (noct-use (:elpaca org-cv :host gitlab :repo "Titan-C/org-cv")
;;   (:require-once "ox" 'ox-moderncv 'ox-altacv 'ox-awesomecv))
#+end_src

**** Orglink
Make org links work everywhere.
#+begin_src emacs-lisp
(use-package orglink
  :after org
  :demand t
  :config
  (gsetq orglink-activate-in-modes '(text-mode prog-mode))
  (global-orglink-mode))
#+end_src

**** Org Make ToC
 #+begin_src emacs-lisp
(use-package org-make-toc
  :config (gsetq org-make-toc-insert-custom-ids t))
 #+end_src

**** Org Modern
#+begin_src emacs-lisp
(use-package org-modern
  :ghook
  'org-mode-hook
  ('org-agenda-finalize-hook #'org-modern-agenda)
  :config
  ;; this is different from `org-hide-heading-stars', which I prefer
  (gsetq org-modern-hide-stars nil
         org-modern-star
         ["●"
          "◉"
          "○"
          "◆"
          "◈"
          ;; too big
          ;; "🞛"
          "◇"
          "*"
          ;; "▪"
          ;; "▫"
          ]
         org-modern-checkbox
         '((?X . "☑")
           (?- . "▣")
           (?\s . "☐"))
         ;; e.g. for #+title
         org-modern-keyword "‣ "
         org-modern-variable-pitch 'fixed-pitch
         org-modern-table-vertical 1
         org-modern-table-horizontal 1)

  ;; has equally sized bullets and nice checkboxes (that don't change when you
  ;; put the point on them like for a lot of nerd fonts)
  ;; (set-face-attribute 'org-modern-symbol nil :font "Sarasa Mono J-9")
  ;; Delugia looks fine

  ;; TODO make feature request for option for this?
  (defun noct--org-modern-upate-label-face (&rest _)
    "Make org-modern labels less wide."
    (let ((border-reduce (if (eq org-modern-label-border 'auto)
                             (- (/ (frame-char-height) 10))
                           (- org-modern-label-border))))
      (set-face-attribute
       'org-modern-label nil
       :box (list :color (face-attribute 'default :background nil t)
                  :line-width (cons (* 2 border-reduce)
                                    border-reduce)))))
  (general-add-advice 'org-modern--update-label-face
                      :after #'noct--org-modern-upate-label-face))
#+end_src

**** Org Node
 #+begin_src emacs-lisp
(use-package org-node
  :general (general-spc
             "RET" #'org-node-find
             "DEL" #'org-node-insert-link)
  :after org
  :config
  (gsetq org-node-alter-candidates t)
  (org-node-cache-mode))
 #+end_src

**** Org Ql
#+begin_src emacs-lisp
(use-package org-ql
  :general
  (general-spc "q" #'noct-org-ql)
  :config
  (noct-handle-popup "*Org QL")

  (defun noct-org-ql ()
    (interactive)
    (org-ql-search (org-agenda-files)
      (read-string "Query: ")
      :super-groups '((:auto-parent))
      :sort '(priority)))

  ;; TODO make feature request
  ;; TODO why matching against full heading and not stripped?
  ;; this is heading-regxep without the 0+ nonl and adds args to
  ;; `org-get-heading'
  (org-ql-defpred noct-heading-regexp (&rest regexps)
    "Return non-nil if current entry's heading matches all REGEXPS.
Matching is done case-insensitively."
    :coalesce t
    :normalizers ((`(,predicate-names . ,args)
                   `(noct-heading-regexp ,@args)))
    ;; MAYBE: Adjust regexp to avoid matching in tag list.
    :preambles ((`(,predicate-names ,regexp)
                 ;; Only one regexp: match with preamble, then let predicate
                 ;; confirm (because the match could be in e.g. the tags rather
                 ;; than the heading text).
                 (list :regexp (rx-to-string `(seq bol (1+ "*") (1+ blank)
                                                   (? (and "TODO" (1+ blank)))
                                                   (regexp ,regexp))
                                             'no-group)
                       :case-fold t :query query))
                (`(,predicate-names . ,regexps)
                 ;; Multiple regexps: use preamble to match against first
                 ;; regexp, then let the predicate match the rest.
                 (list :regexp (rx-to-string `(seq bol (1+ "*") (1+ blank)
                                                   (? (and "TODO" (1+ blank)))
                                                   (regexp ,(car regexps)))
                                             'no-group)
                       :case-fold t :query query)))
    :body (let ((heading (org-get-heading 'no-tags 'no-todo 'no-priority
                                          'no-comment))
                (case-fold-search t))
            (--all? (string-match it heading) regexps))))
#+end_src

**** Org Reveal
#+begin_src emacs-lisp
(noct-use ox-reveal
  (:require-once "ox"))
#+end_src

**** Org Superlinks
#+begin_src emacs-lisp
(use-package org-super-links
  :ensure
  (org-super-links :type git
                   :host github
                   :repo "toshism/org-super-links"
                   :branch "develop")
  :general
  (general-t "y" #'org-super-links-store-link)
  :init
  (general-with 'org
    ;; org superlinks currently autoloads this...
    (general-advice-add 'org-capture
                        :before #'org-super-links-store-link)
    (general-m org-mode-map "p" #'org-super-links-insert-link)))
#+end_src

**** Worf
Worf mode has nice things over speed commands like being able to prefix directional commands with numbers and having sticky commands.

I don't use it so often for basic commands, but it's good if you actually want to do a bunch of stuff in an "org command mode" (e.g. repeatedly moving through headings and reading, e.g. emacs news).

#+begin_src emacs-lisp
(noct-use ( :elpaca worf
            :repo "noctuid/worf"
            :branch "require-hydra")
  (:hooks 'org-mode-hook)
  (gsetq org-use-speed-commands nil)
  (:config
    (general-def worf-mode-map
      "[" nil
      "]" nil
      "DEL" nil)

    (defun noct-worf-open-below ()
      "Open a new org heading below the point and move to it, exiting special.
Add a newline before the heading."
      (interactive)
      (worf-add 1)
      (unless (save-excursion
                (forward-line -1)
                (looking-at (rx bol eol)))
        (save-excursion
          (end-of-line 0)
          (evil-open-fold)
          (open-line 1))))

    (defun noct-heading-end ()
      "Go to the end of the current heading.
Normalize whitespace between previous text and following heading (one blank
line)."
      (interactive)
      ;; goes to buffer end if no more headings
      (outline-next-heading)
      (while (progn
               (forward-line -1)
               (looking-at (rx bol eol))))
      (delete-blank-lines)
      (end-of-line)
      (open-line 1)
      (forward-line 1))

    (defun noct-worf-toggle ()
      (interactive)
      (if (org-at-heading-p)
          (evil-toggle-fold)
        (org-cycle)))

    (general-def worf-mode-map
      :definer 'worf
      ;; worf definer doesn't support menu items!
      ;; "TAB" (list #'evil-toggle-fold :predicate #'org-at-heading-p)
      ;; "TAB" (general-predicate-dispatch #'org-cycle
      ;;         (org-at-heading-p) #'evil-toggle-fold)
      "TAB" #'noct-worf-toggle
      "e" #'worf-up
      "n" #'worf-down
      "N" #'org-metadown
      "E" #'org-metaup
      "i" #'worf-right
      "I" (list #'noct-heading-end :worf-plist '(:break t))
      "l" #'better-jumper-jump-backward
      "L" #'better-jumper-jump-forward
      ;; worf's ct randomly has extra empty window open up?
      ";" #'org-set-tags-command
      "q" #'org-clock-cancel
      "'" #'org-edit-special
      "t" #'worf-todo
      "d" (list #'org-deadline :worf-plist '(:break t))
      ;; just use refile instead of worf hydra
      "r" #'org-refile
      "w" #'org-narrow-to-subtree    ; lose `worf-keyword'
      "W" #'widen
      ;; no reason to use over `worf-todo' for me (which is bound to t)
      ;; "k" #'worf-keyword
      "a" (list #'end-of-visual-line :worf-plist '(:break t)) ; lose `worf-add'
      ;; lose `worf-ace-link' (don't use)
      "o" (list #'noct-worf-open-below :worf-plist '(:break t))
      "O" (list #'org-meta-return :worf-plist '(:break t))
      ;; will generate an id in a properties section for the current header
      ;; and copy an org link to it to the kill ring
      "Y" #'worf-copy-heading-id
      ;; shift heading and all subheadings
      "<" #'org-shiftmetaleft
      ">" #'org-shiftmetaright
      "/" #'org-sparse-tree)

    (defun noct-open-heading-and-parents (&rest _)
      "Open heading and all its parents."
      (save-excursion
        (outline-show-children)
        (while (ignore-errors (outline-up-heading 1 t))
          (outline-show-children))))

    (general-add-advice '(consult-org-heading consult-outline) :after
                        #'noct-open-heading-and-parents)))

;; ct notes:
;; - tags a-z for quick adding
;; - q to quit without changing if not assigned to a tag
;; - tab for a tag not predefined
;; - ret to accept modified set
;; - spc to clear all tags for line
;; - autoexit after first change - org-fast-tag-selection-single-key
;; - remap c-c to toggle this behaviour
#+end_src

** Pentadactyl
#+begin_src emacs-lisp
(use-package dactyl-mode
  ;; package doesn't add to `auto-mode-alist'
  :mode "\\.pentadactylrc\\'")
#+end_src

** SaltStack
#+begin_src emacs-lisp
(use-package salt-mode)
#+end_src

** Special Mode
Used for =*Warnings*= buffer, for example.
#+begin_src emacs-lisp
(general-def 'normal special-mode-map
  "q" #'quit-window)
#+end_src

** Sxhkdrc Mode
#+begin_src emacs-lisp
(use-package sxhkdrc-mode)
#+end_src

** Systemd
#+begin_src emacs-lisp
(use-package systemd)
#+end_src

** Udev
 #+begin_src emacs-lisp
(use-package udev-mode)
 #+end_src

** Vimrc Mode
#+begin_src emacs-lisp
(use-package vimrc-mode)
#+end_src

** Which Key
#+begin_src emacs-lisp
(use-package which-key
  :defer 1
  :ghook ('pre-command-hook nil nil nil t)
  :general
  (noct-toggle-map "W" #'which-key-mode)
  ;; replace `where-is'; don't need because can show in M-x
  (help-map "w" #'which-key-show-top-level)
  :init
  ;; should be set before loading
  (gsetq which-key-idle-delay 0.3)
  :blackout t
  :config
  (gsetq which-key-side-window-location 'top
         which-key-sort-order 'which-key-prefix-then-key-order
         which-key-sort-uppercase-first nil
         which-key-max-display-columns 5)

  (which-key-mode)

  (defun noct-mode-replacement (kb)
    "More generic version of a which-key example."
    (cons (car kb)
          (let ((mode-name (cdr kb))
                (mode (intern (cdr kb))))
            (cond ((and (boundp mode)
                        (symbol-value mode))
                   (concat "[X] " mode-name))
                  ((boundp mode)
                   (concat "[ ] " mode-name))
                  (t
                   mode-name)))))

  (general-pushnew (cons '(nil . "-mode\\'") #'noct-mode-replacement)
                   which-key-replacement-alist))
#+end_src

** Woman and Man
#+begin_src emacs-lisp
(use-package woman
  :ensure nil
  :general (general-s "w" #'woman)
  :init
  (noct-handle-popup woman-mode))

(use-package man
  :ensure nil
  :init
  ;; TODO doesn't work
  (noct-handle-popup-same-window Man-mode)
  (noct-handle-popup-same-window (rx "*Man")))
#+end_src

** Xmodmap
I'm not really using xmodmap files anymore. Config taken from [[https://www.emacswiki.org/emacs/XModMapMode][here]].
#+begin_src emacs-lisp
(define-generic-mode 'xmodmap-mode
  '(?!)
  '("add" "clear" "keycode" "keysym" "remove" "pointer")
  nil
  '("[xX]modmap\\(rc\\)?\\'")
  nil
  "Simple mode for xmodmap files.")
#+end_src

** YAML mode
#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

** TOML Mode
 #+begin_src emacs-lisp
(use-package toml-ts-mode
  :ensure nil
  :gfhook #'lsp)
 #+end_src

* Programming
** General and Prog Mode
*** Apheleia
#+begin_src emacs-lisp
;; really nice apart from this
;; https://github.com/raxod502/apheleia/issues/2
(use-package apheleia
  :general
  (noct-toggle-map "h" #'apheleia-mode)
  (general-t "=" #'apheleia-format-buffer)
  ;; :init
  ;; this does not load apheleia until file save
  ;; (apheleia-global-mode)
  :config
  (defun noct-pet-ruff-or-black ()
    (let* ((root (when (fboundp 'pet-virtualenv-root)
                   ;; not using `pet-executable-find' because want .venv version
                   ;; over pre-commit venv version
                   (pet-virtualenv-root)))
           (local-ruff (when root (file-name-concat root "bin/ruff")))
           (local-black (when root (file-name-concat root "bin/black"))))
      (cond ((and local-ruff (file-executable-p local-ruff))
             (list local-ruff "format" "--silent" "-"))
            ((and local-black (file-executable-p local-black))
             (list local-black "-"))
            ((executable-find "ruff")
             (list "ruff" "format" "--silent" "-"))
            ((executable-find "black")
             (list "black" "-"))
            (t
             (list "cat")))))
  (setf (alist-get 'noct-ruff-or-black apheleia-formatters)
        '((noct-pet-ruff-or-black)))
  (general-pushnew '(python-ts-mode . noct-ruff-or-black) apheleia-mode-alist))
#+end_src

*** Docker
#+begin_src emacs-lisp
(use-package docker
  :config
  (noct-handle-popup-same-window "*docker")
  (noct-handle-popup-same-window "* docker"))

;; TODO bind
;; docker-container-kill
;; docker-container-restart
;; docker-container-rm
;; docker-container-inspect
;; docker-container-attach
;; docker-container-shells
;; docker-container-logs

(use-package dockerfile-mode)

;; /docker:user@container:/path/to/file
;; /podman:user@container:/path/to/file
;; now builtin
(noct-use (:no-install tramp-container)
  (:require-once "tramp"))
#+end_src

*** Dtrt Indent
#+begin_src emacs-lisp
;; https://github.com/hlissner/doom-emacs/blob/01aadd8900be45f912124d9d815d8790f540d38c/core/core-editor.el#L339
(defvar doom-detect-indentation-excluded-modes '(fundamental-mode so-long-mode)
  "Major modes for which indentation should not be automatically detected.")

(defvar-local doom-inhibit-indent-detection nil
  "A buffer-local flag that indicates whether `dtrt-indent' should be used.
This should be set by editorconfig if it successfully sets
indent_style/indent_size.")

(defun doom-detect-indentation-h ()
  (unless (or (not elpaca-after-init-time)
              doom-inhibit-indent-detection
              doom-large-file-p
              (memq major-mode doom-detect-indentation-excluded-modes)
              (member (substring (buffer-name) 0 1) '(" " "*"))
              (not (derived-mode-p 'prog-mode)))
    (dtrt-indent-mode +1)))

(use-package dtrt-indent
  ;; TODO re-evaluate later (including performance), but would rather rely on
  ;; editorconfig than guessing; check latest doom config if end up using
  :disabled t
  :ghook ('(change-major-mode-after-body-hook read-only-mode-hook)
          'doom-detect-indentation-h)
  :blackout " ›"
  :config
  ;; Enable dtrt-indent even in smie modes so that it can update `tab-width',
  ;; `standard-indent' and `evil-shift-width' there as well.
  (gsetq dtrt-indent-run-after-smie t)
  ;; Reduced from the default of 5000 for slightly faster analysis
  (gsetq dtrt-indent-max-lines 2000)

  ;; always keep tab-width up-to-date
  (push '(t tab-width) dtrt-indent-hook-generic-mapping-list)

  (defvar dtrt-indent-run-after-smie)
  (defun doom--fix-broken-smie-modes-a (orig-fn arg)
    "Some smie modes throw errors when trying to guess their indentation.
One example is `nim-mode'. This prevents them from leaving Emacs in a broken
state."
    (let ((dtrt-indent-run-after-smie dtrt-indent-run-after-smie))
      (cl-letf* ((old-smie-config-guess (symbol-function 'smie-config-guess))
                 (old-smie-config--guess
                  (symbol-function 'symbol-config--guess))
                 ((symbol-function 'symbol-config--guess)
                  (lambda (beg end)
                    (funcall old-smie-config--guess beg (min end 10000))))
                 ((symbol-function 'smie-config-guess)
                  (lambda ()
                    (condition-case e (funcall old-smie-config-guess)
                      (error (setq dtrt-indent-run-after-smie t)
                             (message "[WARNING] Indent detection: %s"
                                      (error-message-string e))
                             (message "")))))) ; warn silently
        (funcall orig-fn arg))))

  (general-add-advice 'dtrt-indent-mode :around #'doom--fix-broken-smie-modes-a))
#+end_src

*** Editorconfig
#+begin_src emacs-lisp
;; https://github.com/hlissner/doom-emacs/blob/bb702acfd06bd55f7726678f0a24d7242fff1c2d/modules/tools/editorconfig/config.el#L55
(defvar doom-+editorconfig-mode-alist
  '((emacs-lisp-mode . "el")
    (enh-ruby-mode   . "rb")
    (js2-mode        . "js")
    (perl-mode       . "pl")
    (php-mode        . "php")
    (python-mode     . "py")
    (ruby-mode       . "rb")
    (sh-mode         . "sh"))
  "An alist mapping major modes to extensions.
Used by `doom--editorconfig-smart-detection-a' to give editorconfig filetype
hints.")

(use-package editorconfig
  :init
  ;; won't work first time if use `find-file-hook'; advise `after-find-file'
  ;; instead like doom does
  (noct-after-buffer (editorconfig-mode))
  :blackout t
  :config
  ;; (gsetq editorconfig-trim-whitespaces-mode 'ws-butler-mode)

  ;; https://github.com/doomemacs/doomemacs/blob/35dc13632b3177b9efedad212f2180f69e756853/modules/tools/editorconfig/config.el#L27
  (general-pushnew
   (rx "."
       (or "zip" (and (or "ppt" "doc" "xls") "x"))
       string-end)
   editorconfig-exclude-regexps)

  (defun doom--editorconfig--smart-detection-a (orig-fn &rest args)
    "Retrieve the properties for the current file.
If it doesn't have an extension, try to guess one."
    (let ((buffer-file-name
           (if (and (not (bound-and-true-p org-src-mode))
                    buffer-file-name
                    (file-name-extension buffer-file-name))
               buffer-file-name
             (format "%s%s" (buffer-file-name (buffer-base-buffer))
                     (if-let* ((ext (cdr (assq major-mode
                                               doom-+editorconfig-mode-alist))))
                         (concat "." ext)
                       "")))))
      (apply orig-fn args)))
  ;; NOTE: this was causing problems
  ;; (general-add-advice '(
  ;;                       ;; editorconfig-get-properties
  ;;                       ;; editorconfig-core-get-properties
  ;;                       editorconfig-call-get-properties-function)
  ;;                     :around #'doom--editorconfig--smart-detection-a)
  ;; extend doom's configuration to also work for org src blocks
  (general-add-hook 'org-src-mode-hook #'editorconfig-apply)

  (defun doom-+editorconfig-disable-indent-detection-h (props)
    "Inhibit `dtrt-indent' if indent_style or indent_size is configured."
    (when (or (gethash 'indent_style props)
              (gethash 'indent_size props))
      (setq doom-inhibit-indent-detection 'editorconfig)))
  (general-add-hook 'editorconfig-after-apply-functions
                    #'doom-+editorconfig-disable-indent-detection-h))
#+end_src

*** Envrc (Direnv Integration)
Envrc has a clear advantage over direnv.el in that it sets environment variables buffer-locally.  For nix, I am just using [[https://github.com/nix-community/nix-direnv][nix-direnv]] for persistence.  If performance ever becomes an issue, I will try [[https://github.com/nix-community/lorri][lorri]] (which uses a daemon), but for now it is fine.
 #+begin_src emacs-lisp
(noct-use (:and (executable-find "direnv")
                (:elpaca envrc))
  (:hooks 'on-first-file-hook #'envrc-global-mode)
  (:mode (rx ".env" string-end) envrc-file-mode)
  (:config
    ;; https://github.com/doomemacs/doomemacs/blob/master/modules/tools/direnv/config.el
    ;; Ensure babel's execution environment matches the host buffer's.
    (general-add-advice 'org-babel-execute-src-block
                        :around #'envrc-propagate-environment)))
 #+end_src

*** Prog Mode Setup
#+begin_src emacs-lisp
(general-add-hook 'after-save-hook
                  #'executable-make-buffer-file-executable-if-script-p)

(defun noct-prog-mode-setup ()
  (setq-local comment-auto-fill-only-comments t))

(general-add-hook 'prog-mode-hook (list #'noct-prog-mode-setup #'auto-fill-mode))
(blackout 'auto-fill-mode)
#+end_src

*** Prog Mode Keybindings
#+begin_src emacs-lisp
(general-with-package 'prog-mode
  (general-m prog-mode-map
    "c" #'compile
    "g" #'first-error))
#+end_src

*** Makefile Executor
#+begin_src emacs-lisp
(use-package makefile-executor
  :general
  (general-t "m" #'makefile-executor-execute-project-target))
#+end_src

*** Semantic
Lispy, for example, relies on semantic.
**** Bug Workaround
See [[https://github.com/company-mode/company-mode/issues/525][this issue]].
#+begin_src emacs-lisp
(general-with-package 'semantic
  ;; updated from:
  ;; https://github.com/company-mode/company-mode/issues/525#issuecomment-348635719
  (defun semantic-completion-advice (adviced-f &rest r)
    "Check if POINT it's inside a string or comment before calling semantic-*"
    (unless (or
             ;; in string
             (nth 3 (syntax-ppss))
             ;; in comment
             (save-excursion
               (unless (eolp)
                 (forward-char 1))
               (nth 4 (syntax-ppss))))
      (apply adviced-f r)))

  (general-add-advice '(semantic-analyze-completion-at-point-function
                        semantic-analyze-notc-completion-at-point-function
                        semantic-analyze-nolongprefix-completion-at-point-function)
                      :around #'semantic-completion-advice))
#+end_src

*** Vagrant Tramp
#+begin_src emacs-lisp
(use-package vagrant-tramp)
#+end_src

*** Visual
**** Rainbow Delimiters
[[https://github.com/istib/rainbow-blocks][rainbow-blocks]] is a fork of rainbow-delimeters that highlights the entire block. There is also [[https://github.com/seanirby/rainbow-blocks-bg][rainbow-blocks-bg]]. I personally find these to be too much color.
#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :ghook
  noct-lisp-mode-hooks
  'c-mode-hook)
#+end_src

**** Highlight Parentheses
#+begin_src emacs-lisp
(use-package highlight-parentheses
  :ghook 'prog-mode-hook
  :blackout t
  :config
  (gsetq hl-paren-colors '("firebrick1"))

  (custom-set-faces '(hl-paren-face ((t :inherit show-paren-match)))))
#+end_src

**** Eldoc
#+begin_src emacs-lisp
;; https://github.com/progfolio/elpaca/issues/236
;; https://github.com/progfolio/elpaca/issues/398
;; Unload built-in eldoc
(unload-feature 'eldoc t)
;; Workaround custom.el initialization for global-eldoc-mode.
;; Not sure about setting this globally.
;; Might want to move it into a custom build step which
;; replaces `elpaca--activate-package` for eldoc.
(setq custom-delayed-init-variables '())
(defvar global-eldoc-mode nil)

;; deferred incrementally by other packages
(noct-use eldoc
  (:blackout)
  (:config
    (gsetq eldoc-idle-delay 0.1)
    (global-eldoc-mode)))
#+end_src

**** Highlight Numbers
#+begin_src emacs-lisp
(use-package highlight-numbers
  :ghook 'prog-mode-hook)
#+end_src

**** TODO Fixmes
***** Fic Mode
Doesn't work well (highlighting doesn't show up for new... goes away if go to line)
#+begin_src emacs-lisp
(use-package fic-mode
  :disabled t
  :ghook 'prog-mode-hook
  :config
  (gsetq fic-highlighted-words '("TODO" "FIXME" "OPTIMIZE" "HACK" "REVIEW" "BUG"))

  ;; remove white background
  (set-face-attribute 'fic-face nil :background 'unspecified)
  (set-face-attribute 'fic-author-face nil :background 'unspecified))
#+end_src
***** Fixmee Mode
Breaks syntax highlighting.
#+begin_src emacs-lisp
(use-package fixmee
  :disabled t
  :init (global-fixmee-mode))
#+end_src

***** Alternate Solution
#+begin_src emacs-lisp
(defun noct-font-lock-todo ()
  (font-lock-add-keywords
   nil
   ;; https://github.com/bbatsov/emacs-lisp-style-guide#comment-annotations
   '(("\\<\\(TODO\\|FIXME\\|OPTIMIZE\\|HACK\\|REVIEW\\|BUG\\)"
      1 font-lock-warning-face prepend))))

(general-add-hook 'prog-mode-hook #'noct-font-lock-todo)
#+end_src

*** Aggressive and Electric Indent
#+begin_src emacs-lisp
(defconst noct-no-electric-mode-hooks
  ;; don't indent after bullet points in org-mode
  '(org-mode-hook)
  "Mode hooks to disable `electric-indent-mode' in.")

(general-add-hook noct-no-electric-mode-hooks
                  (lambda () (electric-indent-local-mode -1)))

(use-package aggressive-indent
  ;; works best in lisp modes; in ALGOL-style languages will get annoying shifts
  ;; when typing if statements for example
  ;; also not great in other people's projects
  :ghook noct-lisp-mode-hooks
  :general
  (general-def noct-toggle-map "a" #'aggressive-indent-mode)
  :blackout t
  :config
  (general-pushnew 'python-mode aggressive-indent-excluded-modes)
  (general-pushnew 'asm-mode aggressive-indent-excluded-modes)
  (general-pushnew 'nix-mode aggressive-indent-excluded-modes))
#+end_src

*** Dumb Jump
#+begin_src emacs-lisp
(use-package dumb-jump
  :general ('normal "gd" #'dumb-jump-go)
  :config
  ;; TODO first check that ivy and rg are installed
  (gsetq dumb-jump-selector 'ivy
         dumb-jump-prefer-searcher 'rg))
#+end_src

*** Smart Jump
#+begin_src emacs-lisp
(use-package smart-jump
  :general
  ('normal "gs" #'smart-jump-go)
  (general-m prog-mode-map "x" #'smart-jump-references)
  ;; TODO consider this
  ;; (general-def prog-mode-map
  ;;   "RET" #'smart-jump-go
  ;;   "<S-Return>" #'smart-jump-back)
  :config
  (smart-jump-setup-default-registers)

  (smart-jump-register :modes '(emacs-lisp-mode lisp-interaction-mode)
                       :jump-fn #'xref-find-definitions
                       :pop-fn #'pop-tag-mark
                       :refs-fn #'xref-find-references
                       :should-jump t
                       :heuristic #'error
                       :async nil))
#+end_src

*** Electric Operator Mode
This is a maintained fork of =electric-spacing=.
#+begin_src emacs-lisp
(use-package electric-operator
  :ghook
  'python-base-mode-hook
  'c-mode-hook)
#+end_src

*** TODO Electric Case
*** Flycheck
**** Setup
#+begin_src emacs-lisp
(use-package flycheck
  :init
  (noct-after-buffer
    (global-flycheck-mode))
  :blackout t
  :config
  (gsetq flycheck-check-syntax-automatically
         ;; remove new-line
         '(idle-change save mode-enabled)
         ;; increase idle delay before linting
         flycheck-idle-change-delay 1
         ;; decrease delay before showing error
         flycheck-display-errors-delay 0.2)

  (general-def noct-toggle-map "f" #'flycheck-mode)

  (general-m
    "F" #'flycheck-list-errors
    "n" #'flycheck-next-error
    "e" #'flycheck-previous-error)

  (noct-handle-popup flycheck-error-list-mode))
#+end_src

**** Flycheck Pos Tip
Compared to other flycheck frontends, pos tip is pretty slow and can cause significant input lag when company mode is enabled.
#+begin_src emacs-lisp
(use-package flycheck-pos-tip
  :disabled t
  :ghook 'flycheck-mode-hook
  :config
  (general-add-hook 'lsp-after-open-hook (noct-disable flycheck-pos-tip-mode)))
#+end_src

**** Flycheck Inline
Will probably remove completely in favor of sideline.

Seems fast but the addition of extra lines is jarring. I've updated the display function to show over the line after the error. It now handles multiple error messages (at the end of the buffer too).
#+begin_src emacs-lisp
(defun noct-maybe-flycheck-inline ()
  "Enable `flycheck-inline-mode' if `lsp-mode' is not enabled."
  (unless (bound-and-true-p lsp-mode)
    (flycheck-inline-mode)))

(use-package flycheck-inline
  ;; having errors on current version
  :disabled t
  :ghook ('flycheck-mode-hook #'noct-maybe-flycheck-inline)
  :config
  ;; NOTE: unicode prefix makes it shift the line down slightly
  ;; (defconst noct-flycheck-prefix "➵ ")
  (defconst noct-flycheck-prefix "~> ")

  ;; disable when using lsp
  (general-add-hook 'lsp-mode-hook (noct-disable flycheck-inline-mode))

  (defvar-local noct-flycheck-inline-last-error-point nil)

  ;; TODO after updating Emacs, popups delete text
  (defun noct-flycheck-inline-phantom-display (msg &optional pos err)
    "Display MSG in a phantom starting at the beginning of the next line.

MSG is a string that will be put in a line-long overlay (phantom) at the line
after POS. If POS is nil, current point is used instead.

ERR is the flycheck error

Return the displayed phantom."
    ;; don't use pos;
    (setq noct-flycheck-inline-last-error-point (point))
    (pcase-let* ((p (or pos (point)))
                 (`(,pos-bol . ,pos-eol)
                  (save-excursion
                    (goto-char p)
                    (while (and (not (= (forward-line) 1))
                                (cl-some (lambda (ov)
                                           (= (point-at-bol)
                                              (overlay-start ov)))
                                         flycheck-inline--phantoms)))
                    (cons (point-at-bol) (point-at-eol))))
                 (str (concat
                       (when (= pos-eol (point-max))
                         "\n")
                       noct-flycheck-prefix
                       msg)))
      ;; don't create duplicate overlays
      (when (not (cl-some (lambda (ov)
                            (member str
                                    (list (overlay-get ov 'after-string)
                                          (overlay-get ov 'display))))
                          flycheck-inline--phantoms))
        (let ((ov (make-overlay
                   (if (= pos-eol (point-max))
                       pos-eol
                     pos-bol)
                   pos-eol)))
          (overlay-put ov 'phantom t)
          (overlay-put ov 'error err)
          (overlay-put ov
                       (if (or (= pos-eol (point-max))
                               (= pos-bol pos-eol))
                           'after-string
                         'display)
                       str)
          (push ov flycheck-inline--phantoms)
          ov))))

  ;; TODO fix
  ;; (gsetq flycheck-inline-display-function
  ;;        #'noct-flycheck-inline-phantom-display)

  (defun general-flycheck-inline-hide-errors ()
    "Hide all inline messages currently being shown if point has changed."
    (when (and noct-flycheck-inline-last-error-point
               (not (= noct-flycheck-inline-last-error-point (point))))
      (funcall flycheck-inline-clear-function)))

  ;; TODO add back if fix `noct-flycheck-inline-phantom-display'
  ;; prevent errors from disappearing unless point moves
  ;; (general-add-advice 'flycheck-inline-hide-errors
  ;;                     :override #'general-flycheck-inline-hide-errors)
  )
#+end_src

**** Flycheck Sideline
5th flycheck frontend is the charm?
#+begin_src emacs-lisp
(noct-use sideline
  (gsetq sideline-backends-right '(sideline-flycheck))
  (:hooks 'flycheck-mode-hook)
  (:hooks 'lsp-mode-hook
          (noct-defun disable-sideline-flycheck ()
            (gsetq-local sideline-backends-right
                         (remove 'sideline-flycheck sideline-backends-right)))))

(noct-use sideline-flycheck
  (:hooks 'flycheck-mode-hook #'sideline-flycheck-setup))
#+end_src

**** TODO Flycheck Posframe
Looks very nice but has various bugs (last character in message sometimes doesn't show, posframe often appears as empty, etc.).
#+begin_src emacs-lisp
(use-package flycheck-posframe
  :disabled t
  :ghook 'flycheck-mode-hook
  :config (flycheck-posframe-configure-pretty-defaults))
#+end_src

*** Xref
#+begin_src emacs-lisp
(general-with 'xref
  (gsetq xref-history-storage 'xref-window-local-history)

  ;; window for selecting between definition and variable
  (noct-handle-popup "*xref*")

  (defun noct-xref-find-definition ()
    "Call `xref-find-definitions' but prompt for identifier.
Don't immediately jump to the symbol at the point."
    (interactive)
    (call-interactively #'xref-find-definitions))

  (general-def help-map "x" #'noct-xref-find-definition))

;; now using consult
;; (use-package ivy-xref
;;   :init
;;   (gsetq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+end_src

*** LSP Mode
NOTE: Have had issues where I've accidentally added a folder (e.g. my home folder), causing freezing and other issues.  Use ~lsp-workspace-folders-remove~ to fix issues like this.
#+begin_src emacs-lisp
(use-package lsp-mode
  ;; https://emacs-lsp.github.io/lsp-mode/page/performance/#use-plists-for-deserialization
  ;; set in ./early-init.el
  :config
  (gsetq
   ;; https://github.com/emacs-lsp/lsp-mode#performance
   lsp-prefer-capf t
   read-process-output-max (* 1024 1024)
   lsp-headerline-breadcrumb-enable nil)

  (noct-handle-popup-other-window (rx "*lsp-help*"))

  (general-def 'normal lsp-mode-map
    "N" #'lsp-describe-thing-at-point
    "RET" #'lsp-find-definition)

  (gsetq lsp-keymap-prefix "mm")
  (general-add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)

  (general-m lsp-mode-map
    "m" lsp-command-map
    "a" #'lsp-execute-code-action
    "v" #'lsp-avy-lens
    "i" #'lsp-goto-implementation
    "D" #'lsp-find-declaration
    "T" #'lsp-find-type-definition
    ;; cross (x) references
    "x" #'lsp-find-references
    "r" #'lsp-rename
    "R" #'lsp-restart-workspace
    "=" #'lsp-format-buffer
    "l" #'lsp-workspace-show-log))

(use-package lsp-ui
  :gfhook
  ('lsp-ui-doc-frame-mode-hook (noct-disable display-line-numbers-mode))
  :config
  (gsetq lsp-ui-sideline-ignore-duplicate t
         ;; annoying, especially in modes where there are always code actions;
         ;; can manually show when want to
         lsp-ui-sideline-show-code-actions nil))

(use-package lsp-ivy
  :disabled t
  :after lsp-mode
  :general
  (general-m lsp-mode-map
    "y" #'lsp-ivy-workspace-symbol))

(use-package consult-lsp
  :after lsp-mode
  :general
  (general-m lsp-mode-map
    "y" #'consult-lsp-symbols
    "E" #'consult-lsp-diagnostics))

;; Chaining checkers to lsp; search for `yyoncho-flycheck-local-cache' for uses
(defvar-local yyoncho-flycheck-local-cache nil)
(defun yyoncho-flycheck-checker-get (fn checker property)
  (or (alist-get property (alist-get checker yyoncho-flycheck-local-cache))
      (funcall fn checker property)))

(advice-add 'flycheck-checker-get :around #'yyoncho-flycheck-checker-get)
#+end_src

*** LSP Booster
 #+begin_src emacs-lisp
(defun noct-try-install-emacs-lsp-booster ()
  (unless (or (executable-find "emacs-lsp-booster")
              (not (executable-find "cargo")))
    (shell-command "cargo install emacs-lsp-booster")))

(noct-try-install-emacs-lsp-booster)

(when (executable-find "emacs-lsp-booster")
  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
     (when (equal (following-char) ?#)
       (let ((bytecode (read (current-buffer))))
         (when (byte-code-function-p bytecode)
           (funcall bytecode))))
     (apply old-fn args)))
  (advice-add (if (progn (require 'json)
                         (fboundp 'json-parse-buffer))
                  'json-parse-buffer
                'json-read)
              :around
              #'lsp-booster--advice-json-parse)

  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?) ;; for check lsp-server-present?
               ;; see lsp-resolve-final-command, it would add extra shell wrapper
               (not (file-remote-p default-directory))
               lsp-use-plists
               (not (functionp 'json-rpc-connection)) ;; native json-rpc
               (executable-find "emacs-lsp-booster"))
          (progn
            ;; resolve command from exec-path (in case not found in $PATH)
            (when-let ((command-from-exec-path (executable-find (car orig-result))))
              (setcar orig-result command-from-exec-path))
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))
  (advice-add 'lsp-resolve-final-command :around
              #'lsp-booster--advice-final-command))
#+end_src

*** Tree Sitter
Tree sitter support is now builtin.  It is interesting to see the difference in approach from [[https://www.youtube.com/watch?v=QHlB6w8HFao][ commercial-emacs']] (which tries to do as little in the major mode files as possible) and the previous [[https://github.com/emacs-tree-sitter/elisp-tree-sitter][elisp-tree-sitter]] (which just provides minor modes).

Now there are new tree sitter major modes like =python-ts-mode=.  Luckily, =python-mode= and and =python-ts-mode= both derive from =python-base-mode=, so =python-base-mode-hook= can be used for both.  Unfortunately, this is not the case for all new major modes.  At the time of writing, a lot of packages (e.g. flycheck and lsp-mode) need to be updated to support some of the new ts modes.

I am using the =treesit-auto= package to automate the process of installing the grammars and activating the tree sitter major modes when possible.
#+begin_src emacs-lisp
(noct-use treesit-auto
  ;; some things that don't work: yasnippet association
  (:demand)
  (:config
    (gsetq treesit-auto-install 'prompt)
    ;; avoid due to performance issues
    ;; https://github.com/renzmann/treesit-auto/issues/84
    ;; (global-treesit-auto-mode)

    ;; (treesit-auto--build-major-mode-remap-alist) - also slow

    ;; INSTEAD manually run `treesit-auto-install-all' once and
    ;; just manually set `major-mode-remap-alist'
    (gsetq major-mode-remap-alist
           '(((yaml-mode . yaml-ts-mode)
              (typescript-mode . typescript-ts-mode)
              (typescript-tsx-mode . tsx-ts-mode)
              (toml-mode . toml-ts-mode)
              (conf-toml-mode . toml-ts-mode)
              ;; (rust-mode . rust-ts-mode)
              (ruby-mode . ruby-ts-mode)
              (python-mode . python-ts-mode)
              (markdown-mode . markdown-ts-mode)
              (poly-markdown-mode . markdown-ts-mode)
              (lua-mode . lua-ts-mode)
              (js-json-mode . json-ts-mode)
              (js2-mode . js-ts-mode)
              (javascript-mode . js-ts-mode)
              (js-mode . js-ts-mode)
              (java-mode . java-ts-mode)
              (sgml-mode . html-ts-mode)
              (mhtml-mode . html-ts-mode)
              (heex-mode . heex-ts-mode)
              (go-mod-mode . go-mod-ts-mode)
              (go-mode . go-ts-mode)
              (elixir-mode . elixir-ts-mode)
              (dockerfile-mode . dockerfile-ts-mode)
              (css-mode . css-ts-mode)
              (c++-mode . c++-ts-mode)
              (cmake-mode . cmake-ts-mode)
              (csharp-mode . csharp-ts-mode)
              (c-mode . c-ts-mode)
              ;; (sh-mode . bash-ts-mode)
              )))

    (defun noct-maybe-enable-bash-ts-mode ()
      (when (and (eq major-mode 'sh-mode)
                 (eq sh-shell 'bash))
        (unless (treesit-ready-p 'bash t)
          (treesit-auto--prompt-to-install-package 'bash))
        (bash-ts-mode)))
    (general-add-hook 'sh-mode-hook #'noct-maybe-enable-bash-ts-mode)))
#+end_src

*** Restclient
#+begin_src emacs-lisp
(noct-use restclient
  (:mode "\\.http\\'"))
#+end_src

** Lisps (General)
*** Lispy
TODO
- Use c-8 and c-9 and c-ret more
- probably split this section up

#+begin_src emacs-lisp
;; TODO why is hydra/lv loaded?! (even if never load lispy)
(use-package lispy
  :ensure `(lispy
            :host github
            :repo "abo-abo/lispy"
            ,@(when noct-personal-computer-p
                (list :repo "~/src/forks/lispy")))
  :defer-incrementally
  (mode-local
   lispy-tags
   help-fns
   edebug
   etags
   outline
   avy
   newcomment
   lispy-inline
   delsel
   swiper
   pcase
   hydra)
  :ghook
  noct-lisp-mode-hooks
  ;; TODO RET doesn't work first time run `eval-expression'
  'eval-expression-minibuffer-setup-hook
  ;; use shortcake as lighter!
  :blackout " 🍰"
  :config
  ;; for insertion; some looking at checks too though
  ;; (gsetq-default lispy-outline-header ";; ")
  (gsetq lispy-avy-keys avy-keys
         lispy-avy-style-paren 'at-full
         ;; lispy-avy-style-char 'at-full
         ;; lispy-avy-style-symbol 'at-full
         ;; lispy-eval-display-style 'overlay
         lispy-safe-delete t
         lispy-safe-copy t
         lispy-safe-paste t
         lispy-safe-actions-no-pull-delimiters-into-comments t
         lispy-delete-sexp-from-within t
         lispy-parens-only-left-in-string-or-comment nil
         ;; TODO see how performant is at larger thresholds and optimize
         lispy-safe-threshold 5000
         lispy-use-sly t
         ;; allow space before asterisk for headings (e.g. ";; *")
         lispy-outline (rx (and bol ";;" (or (and ";" (not (any "#")))
                                             (and (0+ space) (1+ "*"))))))

  (noct-handle-popup-other-window "*lispy-message*")

  (general-def noct-toggle-map "l" #'lispy-mode)

  (general-def 'normal lispy-mode-map
    "SPC y" #'lispy-goto)

  (defun noct-lispy-tab (arg)
    "`outline-toggle-children' if at a heading or `lispy-indent-adjust-parens'."
    (interactive "p")
    (if (looking-at lispy-outline)
        (outline-toggle-children)
      (lispy-indent-adjust-parens arg)))

  (general-def lispy-mode-map-lispy
    "]" nil
    "[" nil
    ":" nil
    ;; exit quotes with "
    "\"" #'lispy-doublequote
    "(" #'lispy-parens-auto-wrap
    "[" #'lispy-brackets-auto-wrap
    "{" #'lispy-braces-auto-wrap
    "]" #'lispy-right-nostring
    "}" #'lispy-right-nostring

    "TAB" #'noct-lispy-tab
    "<backtab>" #'lispy-dedent-adjust-parens
    "M-h" #'lispy-beginning-of-defun
    ;; "<C-return>" #'lispy-alt-line
    "<C-return>" #'lispy-parens-down
    ;; TODO maybe also bind key to do ret then ()
    "M-d" #'lispy-kill-at-point)
  ;; 'lispy-close-round-and-newline

  ;; override lh-knight for colemak keys
  (defhydra lh-knight ()
    "knight"
    ("n" lispy-knight-down)
    ("e" lispy-knight-up)
    ("z" nil))

  ;; TODO this needs a lot of work
  (defun noct-lispy-delete (arg)
    "Copy and delete current sexp.
Passes ARG to `lispy-delete' or `lispy-delete-backward'."
    (interactive "p")
    (let ((regionp (region-active-p)))
      (cond ((or (lispy-left-p)
                 regionp)
             (lispy-new-copy)
             (lispy-delete arg)
             (unless regionp
               (lispy--indent-for-tab)
               ;; (when (and (looking-at "[[:space:]]*$")
               ;;            (lispy-looking-back "^[[:space:]]*"))
               ;;   (delete-region (line-beginning-position)
               ;;                  (1+ (line-end-position))))
               (cond ((ignore-errors (forward-list))
                      (backward-list)
                      ;; (lispy-delete-backward 1)
                      )
                     ((ignore-errors (backward-list))
                      (forward-list)
                      ;; (lispy-delete 1)
                      (backward-list)
                      )
                     (t))))
            ((lispy-right-p)
             (lispy-new-copy)
             (lispy-delete-backward arg)))))


  (defun noct-lispy-eval ()
    "Call `cider-eval-last-sexp' where possible otherwise call `lispy-eval'.
This ensures that cider's evaluations fringe indicators are up-to-date."
    (interactive)
    (cond ((or (region-active-p)
               (not (derived-mode-p 'clojure-mode)))
           (call-interactively #'lispy-eval))
          ((lispyville--at-left-p)
           (lispy-different)
           (cider-eval-last-sexp)
           (lispy-different))
          ((lispyville--at-right-p)
           (cider-eval-last-sexp))
          (t
           (call-interactively #'lispy-eval))))

  (general-def lispy-mode-map
    :definer 'lispy
    "n" #'lispy-down                    ; lose lispy-new-copy -> y
    "e" #'lispy-up                      ; lose lispy-eval -> l
    "i" #'lispy-right                   ; lose lispy-tab -> t
    ;; N and E instead of s and w
    "N" #'lispy-move-down               ; lose lispy-narrow -> w
    "E" #'lispy-move-up                 ; lose lispy-eval-and-insert -> L
    "l" #'noct-lispy-eval               ; (freed by i)
    "L" #'lispy-eval-and-insert         ; (unbound)
    "y" #'lispy-new-copy                ; lose lispy-occur -> /
    "/" #'lispy-occur                   ; lose lispy-splice -> x
    "w" #'lispy-narrow                  ; lose lispy-move-up -> f
    "x" #'lispy-splice                  ; lose lispy-x -> c
    "c" #'lispy-x                       ; lose lispy-clone -> q
    "f" #'lispy-ace-paren               ; lose lispy-flow -> k
    "F" #'lispy-ace-char                ; lose lispy-follow
    "q" #'lispy-clone                   ; (freed by f)
    "t" #'lispy-tab                     ; lose lispy-teleport -> j
    "j" #'lispy-teleport                ; (freed by n)
    "d" #'noct-lispy-delete             ; lose lispy-different -> o
    ;; like in visual state
    "o" #'lispy-different               ; lose lispy-other-mode (don't use)
    "J" #'lispy-goto-mode               ; from lispy-other-mode (freed by N)
    "k" #'lispy-flow                    ; (freed by e)
    ;; swap p and P
    "p" #'lispy-paste
    "P" #'lispy-eval-other-window
    ;; swap m and v
    "v" #'lispy-mark-list
    "m" #'lispy-view
    ;; swap H and A; makes more sense given h and a
    "H" #'lispy-beginning-of-defun
    "A" #'lispy-ace-symbol-replace
    ;;  make slurp/barf behavior directional (as opposed to grow/shrink)
    ">" #'lispy-slurp-or-barf-right
    "<" #'lispy-slurp-or-barf-left
    ;; useful for writing tests
    "s" #'lispy-stringify-oneline       ; (freed by N)
    "S" #'lispy-string-oneline)

  (defun noct-paren-advice (&rest _)
    (unless (lispy--in-string-or-comment-p)
      (let ((map (make-sparse-keymap)))
        ;; easy way to undo unwanted wrap on reaction
        ;; instead of planning with a prefix arg
        (define-key map ")"
                    (lambda ()
                      (interactive)
                      (call-interactively #'lispy-barf-to-point)
                      (backward-char)))
        (set-transient-map map))))

  (general-add-advice 'lispy-parens-auto-wrap :after #'noct-paren-advice)

  (noct-add-undo-bounds 'lispy-yank)
  (noct-add-undo-bounds 'lispy-fill))
#+end_src

*** Lispyville
#+begin_src emacs-lisp
(use-package lispyville
  :ensure `(lispyville
            :host github
            :repo "noctuid/lispyville"
            ,@(when noct-personal-computer-p
                (list :repo "~/src/emacs/lispyville/")))
  :ghook 'lispy-mode-hook
  :blackout ((lispyville-mode . (lispyville-mode-line-string " 🍙" " 🍙")))
  :config
  (gsetq lispyville-motions-put-into-special t)

  (general-def noct-toggle-map "y" #'lispyville-mode)

  (lispyville-set-key-theme
   '(operators c-w c-u prettify slurp/barf-cp insert mark-toggle))

  (general-def lispy-mode-map
    :definer 'lispy
    "v" #'lispyville-toggle-mark-type)

  (general-def 'normal lispyville-mode-map
    "H" #'lispyville-beginning-of-defun
    "(" #'lispyville-left
    ")" #'lispyville-right))
#+end_src

*** Highlight Quoted
#+begin_src emacs-lisp
(use-package highlight-quoted
  :ghook noct-lisp-mode-hooks)
#+end_src

*** Highlight Stages (Macros)
For quasi-quoted expressions.
#+begin_src emacs-lisp
(use-package highlight-stages
  :ghook noct-lisp-mode-hooks
  :blackout t
  :config
  (gsetq highlight-stages-highlight-real-quote nil))
#+end_src

** AppleScript Mode
#+begin_src emacs-lisp
(use-package applescript-mode)
#+end_src

** C
#+begin_src emacs-lisp
(use-package cc-mode
  :ensure nil
  :config
  (gsetq-default c-basic-offset 4)
  (setf (alist-get 'other c-default-style) "linux")

  (general-def 'insert c-mode-map
    "RET" #'c-indent-new-comment-line))
#+end_src

** cc-mode
** Clojure
Other packages to investigate
- sayid - debugger and profiler
- dap-mode for clojurescript
- kaocha-runner - to run kaocha tests

*** Setup
TODO bind
- clojure-sort-ns
- clojure-thread* and clojure-unwind*
- clojure-cycle-privacy
- clojure*let
- clojure-add-arity

#+begin_src emacs-lisp
;; `lsp-mode' with clojure-lsp will already use clj-condo
;; older alternavites are squiggly-clojure and flycheck-joker
;; (use-package flycheck-clj-kondo)

(use-package clojure-mode
  :magic
  "#!/usr/bin/env bb"
  "#!/usr/bin/env -S bb"
  :gfhook
  #'lsp
  ('clojurescript-mode-hook #'lsp)
  ('clojurec-mode-hook #'lsp)
  :config
  (gsetq clojure-align-forms-automatically t))
#+end_src

*** Cider
Nice functionality
- shows marker in fringe for top-level forms that have not changed since being evaluated
- shows result in overlay when eval
- failing tests highlighted

Useful but not enough to bind at this point:
- cider-brows-ns
- cider-browse-spec
- cider-undef
- cider-apropos-*

TODO eventually
- bind stacktrace keys
- bind cider toggle trace ns or trace var
- set cider-repl-buffer-size-limit if it becomes necessary

- TODO some lsp stuff does not work with babashka

#+begin_src emacs-lisp
(defun noct-cider-setup ()
  "Setup cider mode, configuring lsp and cider to play nicely."
  ;; because `cider-mode' does not load cider and my :config will not run
  ;; otherwise
  (require 'cider)

  ;; use cider's eldoc
  ;; lsp's eldoc can only show qualified function name or everything; cider can
  ;; show qualified function name and signature
  (gsetq-local lsp-eldoc-enable-hover nil)

  ;; use `clojure-mode's formatting
  ;; - makes more sense for editor not server to handle
  ;; - lsp does not fully support aligning
  ;; - `agressive-indent-mode' conflicts with lsp formatting
  (gsetq-local lsp-enable-on-type-formatting nil)
  ;; also makes more sense for editor to handle
  ;; - don't think lsp can handle macro's {style/indent}
  ;; TODO would be slightly better to change only once jacked in
  (gsetq-local lsp-enable-indentation nil)

  ;; use cider completion
  ;; - formatting is slightly different
  ;;   - cider - macro-name (namespace name) <m>
  ;;   - lsp - var-name ns/var-name (Variable)
  ;; - lsp completion seems to have some issues (2022-03-04) - e.g. not offering
  ;;   completion for macro defined in a dependency with regular clojure, does
  ;;   not work with babashka (e.g. if import fs, get no fs/ completions)
  ;; - lsp's doc popup looks better
  ;; - downside is of course have to eval before get completions for
  ;; NOTE needs to be set before calling `lsp'; TODO some way to disable later?
  (gsetq-local lsp-completion-enable nil)

  ;; use cider for syntax highlighting; don't use lsp's semantic highlight
  ;; functionality
  ;; use font/var lock faces for defined vars and functions
  (gsetq cider-font-lock-dynamically '(macro core deprecated var function)))

(use-package cider
  :ghook
  'clojure-mode-hook
  :gfhook #'noct-cider-setup
  :config
  ;; cider-preferred-build-tool
  (gsetq cider-default-cljs-repl 'shadow
         ;; save file when evaluating buffer without prompting
         ;; cider-save-file-on-load t
         cider-eldoc-display-context-dependent-info t)

  ;; NOTE: clojure-mode-map keybindings should be useable in clojurescript-mode
  ;; (it is a derived mode)
  (general-m cider-mode-map
    "j" #'cider-jack-in
    ";" #'noct-cider-switch-to-repl-creating
    "l" #'cider-eval-last-sexp
    "b" #'cider-load-buffer
    "d" #'cider-eval-defun-at-point
    ;; "Reload modified and unloaded namespaces on the classpath."
    "R" #'cider-ns-refresh
    ;; debug defun - just use C-u with above
    "p" #'cider-macroexpand-1
    "P" #'cider-macroexpand-all
    "t" #'cider-test-run-project-tests
    "I" #'cider-inspect-last-result
    ;; find file containing ns
    "/" #'cider-find-ns
    ;; don't think I will need compile for anything
    "c" #'lsp-clojure-clean-ns)

  (general-def 'normal cider-mode-map
    ;; `lsp-find-definition' often works just as well without repl connection,
    ;; but in some cases it won't work until a file containing a definition has
    ;; been visited (e.g. my bb.util file for babashka scripts)
    "RET" (general-predicate-dispatch nil
            (and (fboundp 'cider-current-connection)
                 (cider-current-connection))
            #'cider-find-dwim)

    ;; `lsp-describe-thing-at-point' is a prettier `cider-clojuredocs'; however,
    ;; it works for fewer things (e.g. it shows nothing for "try" for me)
    ;; cider's doc commands also have the advantage of showing "see also" as
    ;; buttons/links
    ;; "N" #'cider-doc
    "N" #'cider-clojuredocs)

  ;; Use `lsp-find-references' for references
  ;; - Cider limitations: https://docs.cider.mx/cider/usage/misc_features.html
  ;; - Cider won't show references for functions not defined in the ns (only
  ;;   shows for loaded namespaces); lsp can show all references to e.g. =
  ;; TODO try clj-refactor find usages

  (general-m (cider-mode-map cider-repl-mode-map)
    "s" #'cider-repl-set-ns)

  ;; repl maps
  (general-m cider-repl-mode-map
    ";" #'cider-switch-to-last-clojure-buffer
    "o" #'cider-repl-switch-to-other
    "e" #'cider-repl-previous-prompt
    "n" #'cider-repl-next-prompt)

  (general-def 'insert cider-repl-mode-map
    "<up>" #'cider-repl-backward-input
    "<down>" #'cider-repl-forward-input)

  (noct-handle-popup-other-window "*cider-doc*")
  (noct-handle-popup-other-window "*cider-clojuredocs*")
  (noct-handle-popup-other-window "*cider-error*")
  (noct-handle-popup-other-window "*cider-ns-browser*")
  (noct-handle-popup-other-window "*cider-spec-browser*")
  (noct-handle-popup-other-window cider-repl-mode)

  (defun noct--bb-nrepl-filter (proc string)
    "Wait for bb nrepl to start then connect to it with cider."
    ;; insert text (default example)
    (when (buffer-live-p (process-buffer proc))
      (with-current-buffer (process-buffer proc)
        (let ((moving (= (point) (process-mark proc))))

          (save-excursion
            (goto-char (process-mark proc))
            (insert string)
            (set-marker (process-mark proc) (point)))
          (if moving (goto-char (process-mark proc))))))
    ;; connect once up
    (save-match-data
      (when (string-match (rx (and "Started nREPL server at "
                                   (group (1+ (or digit ".")))
                                   ":"
                                   (group (1+ digit))))
                          string)
        (cider-connect-clj (list :host (match-string 1 string)
                                 :port (match-string 2 string))))))

  (defun noct-cider-jack-in-babashka ()
    "Start a babashka nrepl and connect to it.
NOTE: Starting with CIDER 1.2, cider-jack-in-clj works with Babashka projects
that are using bb.edn, so this is no longer normally necessary."
    (interactive)
    (set-process-filter
     (start-process "bb nrepl" "*bb-nrepl*" "bb" "--nrepl-server")
     #'noct--bb-nrepl-filter))

  (defun noct-cider-switch-to-repl-creating ()
    "Switch to cider repl, creating it if necessary.
Set namespace of repl buffer to current namespace"
    (interactive)
    (condition-case e
        (cider-switch-to-repl-buffer t)
      (error
       (cl-case major-mode
         (clojure-mode
          (if (save-excursion
                (goto-char (point-min))
                (looking-at (rx bol "#!/usr/bin/env bb" eol)))
              (noct-cider-jack-in-babashka)
            (cider-jack-in '())))
         (clojurescript-mode (cider-jack-in-cljs '())))))))
#+end_src

*** TODO Clj-Refactor
TODO look at what provides and bind useful keys; see how find usages compares
#+begin_src emacs-lisp
;; TODO bind hydra
(use-package clj-refactor)

;; clojure-lsp already supports
;; (setq cljr-add-ns-to-blank-clj-files nil) ; disable clj-refactor adding ns to blank files
#+end_src

** Csv
#+begin_src emacs-lisp
(noct-use csv-mode
  (:fhooks 'csv-mode-hook #'csv-align-mode)
  (:fhooks 'csv-mode-hook #'csv-header-line)
  (:fhooks 'csv-mode-hook (noct-disable visual-line-mode))
  (:fhooks 'csv-mode-hook (noct-disable visual-fill-column-mode)))
#+end_src

** Emacs Lisp
*** Setup
#+begin_src emacs-lisp
(use-package elisp-mode
  :ensure nil
  :config
  ;; increase docstring fill column
  (gsetq emacs-lisp-docstring-fill-column 80)

  (defun noctuid:byte-compile ()
    "Byte compile the current file."
    (interactive)
    (byte-compile-file (buffer-file-name)))

  (general-m emacs-lisp-mode-map
    "b" #'eval-buffer
    "d" #'eval-defun
    "c" #'noctuid:byte-compile)

  (general-def 'normal emacs-lisp-mode-map
    "RET" #'xref-find-definitions
    ;; just use M-, (using S-return for hkey-either)
    ;; "<S-return>" #'pop-tag-mark
    "N" #'helpful-at-point))
#+end_src

*** TODO Indentation Setup
Builtin indentation should be better...
#+begin_src emacs-lisp
;; https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned
;; https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94
;; (defun fuco1/lisp-indent-function (indent-point state)
;;   "This function is the normal value of the variable `lisp-indent-function'.
;; The function `calculate-lisp-indent' calls this to determine
;; if the arguments of a Lisp function call should be indented specially.

;; INDENT-POINT is the position at which the line being indented begins.
;; Point is located at the point to indent under (for default indentation);
;; STATE is the `parse-partial-sexp' state for that position.

;; If the current line is in a call to a Lisp function that has a non-nil
;; property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
;; it specifies how to indent.  The property value can be:

;; - `defun', meaning indent `defun'-style
;;   \(this is also the case if there is no property and the function
;;   has a name that begins with \"def\", and three or more arguments);

;; - an integer N, meaning indent the first N arguments specially
;;   (like ordinary function arguments), and then indent any further
;;   arguments like a body;

;; - a function to call that returns the indentation (or nil).
;;   `lisp-indent-function' calls this function with the same two arguments
;;   that it itself received.

;; This function returns either the indentation to use, or nil if the
;; Lisp function does not specify a special indentation."
;;   (let ((normal-indent (current-column))
;;         (orig-point (point)))
;;     (goto-char (1+ (elt state 1)))
;;     (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
;;     (cond
;;      ;; car of form doesn't seem to be a symbol, or is a keyword
;;      ((and (elt state 2)
;;            (or (not (looking-at "\\sw\\|\\s_"))
;;                (looking-at ":")))
;;       (if (not (> (save-excursion (forward-line 1) (point))
;;                   calculate-lisp-indent-last-sexp))
;;           (progn (goto-char calculate-lisp-indent-last-sexp)
;;                  (beginning-of-line)
;;                  (parse-partial-sexp (point)
;;                                      calculate-lisp-indent-last-sexp 0 t)))
;;       ;; Indent under the list or under the first sexp on the same
;;       ;; line as calculate-lisp-indent-last-sexp.  Note that first
;;       ;; thing on that line has to be complete sexp since we are
;;       ;; inside the innermost containing sexp.
;;       (backward-prefix-chars)
;;       (current-column))
;;      ((and (save-excursion
;;              (goto-char indent-point)
;;              (skip-syntax-forward " ")
;;              (not (looking-at ":")))
;;            (save-excursion
;;              (goto-char orig-point)
;;              (looking-at ":")))
;;       (save-excursion
;;         (goto-char (+ 2 (elt state 1)))
;;         (current-column)))
;;      (t
;;       (let ((function (buffer-substring (point)
;;                                         (progn (forward-sexp 1) (point))))
;;             method)
;;         (setq method (or (function-get (intern-soft function)
;;                                        'lisp-indent-function)
;;                          (get (intern-soft function) 'lisp-indent-hook)))
;;         (cond ((or (eq method 'defun)
;;                    (and (null method)
;;                         (> (length function) 3)
;;                         (string-match "\\`def" function)))
;;                (lisp-indent-defform state indent-point))
;;               ((integerp method)
;;                (lisp-indent-specform method state
;;                                      indent-point normal-indent))
;;               (method
;;                (funcall method indent-point state))))))))


(defun noct-lispy-indent-setup ()
  "Make indentation settings compliant with lispy's."
  (interactive)
  ;; https://github.com/abo-abo/oremacs/blob/github/modes/ora-elisp-style-guide.el
  (require 'cl-indent)
  (setq-local lisp-indent-function #'common-lisp-indent-function)
  ;; TODO this is bad for actual common lisp (and not buffer-local)
  (put 'if 'common-lisp-indent-function 2)
  (put 'defface 'common-lisp-indent-function 1)
  (put 'define-minor-mode 'common-lisp-indent-function 1)
  (put 'define-derived-mode 'common-lisp-indent-function 3)
  (put 'cl-flet 'common-lisp-indent-function
       (get 'flet 'common-lisp-indent-function))
  (put 'cl-labels 'common-lisp-indent-function
       (get 'labels 'common-lisp-indent-function))
  ;; additional
  (put 'cl-macrolet 'common-lisp-indent-function
       (get 'flet 'common-lisp-indent-function))
  (aggressive-indent-mode -1))

(defun noct-elisp-indent-setup ()
  (when (and (eq major-mode 'emacs-lisp-mode)
             (buffer-file-name)
             (string-match
              ".*lispy/"
              (file-name-directory (buffer-file-name))))
    (noct-lispy-indent-setup)))

(general-add-hook '(find-file-hook emacs-lisp-mode-hook)
                  #'noct-elisp-indent-setup)
#+end_src

*** Highlight Defined
Highlight defined elisp symbols.
#+begin_src emacs-lisp
(use-package highlight-defined
  :ghook 'emacs-lisp-mode-hook)
#+end_src

*** Macrostep
#+begin_src emacs-lisp
(use-package macrostep
  :general
  (lispy-mode-map
   :definer 'lispy
   ;; don't really use `lispy-view' (I've swapped v and m)
   "m" #'macrostep-expand)
  :blackout " 🍔"
  :config
  ;; ~/src/forks/evil-collection/evil-collection-macrostep.el
  (evil-collection-init 'macrostep))
#+end_src

*** Buttercup
#+begin_src emacs-lisp
(use-package buttercup)
#+end_src

*** Cask
#+begin_src emacs-lisp
(use-package cask-mode)
#+end_src

*** IELM
#+begin_src emacs-lisp
(general-with-package 'ielm
  (general-def 'normal ielm-map
    "mb" #'eval-buffer
    "md" #'eval-defun
    "RET" #'xref-find-definitions
    ;; just use M-, (using S-return for hkey-either)
    ;; "<S-Return>" #'pop-tag-mark
    "N" #'helpful-at-point)

  (with-eval-after-load 'lispy
    (defun noct-ielm-newline-or-return ()
      "An alternative to setting `ielm-dynamic-return' to nil.
This will only run `ielm-return' when at the end of the buffer."
      (interactive)
      (if (looking-at "\\'")
          (ielm-return)
        (lispy-newline-and-indent)))

    (general-def 'insert ielm-map
      "RET" #'noct-ielm-newline-or-return)))
#+end_src

*** Flycheck Package
#+begin_src emacs-lisp
(use-package flycheck-package
  :after elisp-mode
  :after flycheck
  :demand t
  :config
  (flycheck-package-setup)

  (defun noct-disable-flycheck-emacs-lisp-checkdoc ()
    "Disable the emacs lisp package and checkdoc checkers."
    (when (featurep 'flycheck)
      (cl-pushnew 'emacs-lisp-checkdoc flycheck-disabled-checkers)))
  (general-add-hook 'org-src-mode-hook #'noct-disable-flycheck-emacs-lisp-checkdoc)

  (defun noct-maybe-disable-flycheck-emacs-lisp-checkdoc ()
    (when (and buffer-file-name
               (member (file-name-nondirectory buffer-file-name)
                       (list "init.el" "early-init.el" "awaken.el" "local.el")))
      (noct-disable-flycheck-emacs-lisp-checkdoc)))
  (general-add-hook 'emacs-lisp-mode-hook
                    #'noct-maybe-disable-flycheck-emacs-lisp-checkdoc))
#+end_src

** Fennel
#+begin_src emacs-lisp
(use-package fennel-mode
  :config
  (general-def 'normal fennel-mode-map
    "RET" #'fennel-find-definition)
  (general-m fennel-mode-map
    "c" #'fennel-view-compilation
    "d" #'lisp-eval-defun
    ";" #'fennel-repl
    "=" #'fennel-format)

  ;; https://gitlab.com/technomancy/fennel-mode/-/issues/11
  ;; fennel-mode incorrectly inherits from lisp-mode; TODO need to make more
  ;; changes than this to fix
  (defun noct-unless-fennel (fun &rest args)
    "Don't run FUN with ARGS if `fennel-mode'."
    (unless (memq major-mode '(fennel-mode fennel-repl-mode))
      (apply fun args)))

  (general-add-advice '(sly-mode sly-editing-mode)
                      :around #'noct-unless-fennel)

  (noct-handle-popup inferior-lisp-mode))

#+end_src

** Groovy/Gradle
#+begin_src emacs-lisp
(use-package groovy-mode)
#+end_src

** Haskell
TODO
- Try [[http://chrisdone.github.io/intero/][Intero]] and [[https://github.com/jyp/dante][Dantle]] and HIE/LSP; [[http://haroldcarr.com/posts/2017-10-24-emacs-haskell-dev-env.html][Relevant article]]; https://www.reddit.com/r/haskell/comments/9bxbwp/which_ide_are_you_using_for_hakell/

*** Setup
#+begin_src emacs-lisp
;; https://github.com/haskell/haskell-mode/wiki
(use-package haskell-mode
  :config
  (general-m haskell-mode-map
    "N" #'haskell-navigate-imports
    "i" #'haskell-mode-format-imports
    "c" #'haskell-compile
    ;; #'haskell-debug
    "b" #'haskell-process-load-file
    "f" #'haskell-mode-stylish-buffer))
#+end_src

*** GHC
#+begin_src emacs-lisp
(use-package ghc
  :disabled t
  :ghook ('haskell-mode-hook #'ghc-init)
  :config
  (general-m haskell-mode-map
    "n" #'ghc-goto-next-error
    "e" #'ghc-goto-prev-error
    "?" #'ghc-display-errors))
#+end_src

*** Company GHC
#+begin_src emacs-lisp
(use-package company-ghc
  :disabled t
  :after (company haskell-mode)
  :config
  (general-pushnew '(company-ghc :with company-yasnippet) company-backends))
#+end_src

*** Flycheck Haskell
#+begin_src emacs-lisp
(use-package flycheck-haskell
  :disabled t
  :ghook ('flycheck-mode-hook #'flycheck-haskell-setup))
#+end_src

*** Hindent
[[https://github.com/chrisdone/hindent][Hindent - Haskell pretty print er]]. There are an unholy number of pretty printers (also stylish-haskell and brittany); [[https://github.com/quchen/prettyprinter][prettyprinter]] seems to be the most recommended at the moment.
#+begin_src emacs-lisp
(use-package hindent
  :ghook 'haskell-mode-hook
  :config
  (general-m haskell-mode-map
    "q" #'hindent-reformat-decl-or-fill))
#+end_src

*** TODO HaRe
*** TODO SHM
*** TODO Hasktags

** Hyprlang
#+begin_src emacs-lisp
(noct-use hyprlang-ts-mode
  ;; it doesn't have autoload cookie
  (:autoload 'hyprlang-ts-mode)
  (:mode "hypr/.*\\.conf\\'")
  (:fhooks (noct-defun noct-hyprlang-setup ()
             (indent-tabs-mode -1)))
  (once-with 'treesit
    (general-pushnew
     '(hyprlang "https://github.com/tree-sitter-grammars/tree-sitter-hyprlang")
     treesit-language-source-alist)))
#+end_src

** JSON
#+begin_src emacs-lisp
(noct-use json-mode
  (:mode "\\.jsonc\\'" jsonc-mode))
#+end_src

** KDL
#+begin_src emacs-lisp
(noct-use (:elpaca kdl-ts-mode :host github :repo "merrickluo/kdl-ts-mode")
  (once-with 'treesit
    (general-pushnew
     '(kdl "https://github.com/tree-sitter-grammars/tree-sitter-kdl")
     treesit-language-source-alist)))
#+end_src

** Kmonad
#+begin_src emacs-lisp
(use-package kbd-mode
  :ensure (:host github :repo "kmonad/kbd-mode")
  :config
  (put 'deflayer 'lisp-indent-function 'defun))
#+end_src

** Lua
#+begin_src emacs-lisp
(use-package lua-mode)
#+end_src

** Nix
#+begin_src emacs-lisp
(use-package nix-mode)
#+end_src

** PKGBUILD mode
#+begin_src emacs-lisp
(use-package pkgbuild-mode)
#+end_src

** Powershell
#+begin_src emacs-lisp
(use-package powershell)
#+end_src

** Python
TODO:
- look at https://github.com/python-rope/ropemacs
- look at https://github.com/millejoh/emacs-ipython-notebook
- look at https://github.com/anachronic/importmagic.el
  - TODO pyright supports auto-import but only as completion, not as code action
- dap-mode

*** Pyright/LSP Setup
- Issue with multi-root and multiple projects/virtual environments: https://github.com/emacs-lsp/lsp-pyright/issues/66
- Issue with plists: https://github.com/emacs-lsp/lsp-pyright/issues/75
#+begin_src emacs-lisp
(use-package lsp-pyright
  :init
  ;; default; not necessary
  ;; (gsetq lsp-pyright-venv-directory ".venv")
  (gsetq lsp-pyright-multi-root nil))

(noct-defun noct-lsp-pyright ()
  "Require lsp-pyright and run `lsp'."
  (require 'lsp-pyright)
  (require 'lsp-ruff)
  ;; (setq yyoncho-flycheck-local-cache
  ;;       '((lsp . ((next-checkers
  ;;                  .
  ;;                  (python-pylint python-mypy))))))
  (lsp))

(use-package python
  :init
  (noct-handle-popup-other-window inferior-python-mode)
  :gfhook ('python-base-mode-hook #'noct-lsp-pyright))
#+end_src

*** Ruff LSP
[[https://github.com/charliermarsh/ruff][Ruff]] does replace black now.  It is not a type checker (using with pyright, not mypy anymore).

Ruff does not replaces these (at least not as of [2023-03-08 Wed]):
- [[https://github.com/PyCQA/pylint][pylint]] (see [[https://github.com/charliermarsh/ruff/issues/970][issue 970]])
- others in [[https://github.com/PyCQA/prospector][prospector]]
  - [[https://github.com/landscapeio/dodgy][dodgy]]
  - [[https://github.com/jendrikseipp/vulture][vulture]]
  - [[https://github.com/regebro/pyroma][pyroma]]
- [[https://github.com/MichaelKim0407/flake8-use-fstring][flake8-use-fstring]]
- [[https://github.com/peterjc/flake8-rst-docstrings][flake8-rst-docstrings]]
- [[https://github.com/PyCQA/flake8-import-order][flake8-import-order]]
- [[https://github.com/tyleryep/flake8-future-annotations][flake8-future-annotations]]
- [[https://github.com/rubik/radon][radon]] (which [[https://github.com/klen/pylama][pylama]] supports, though I don't really need it)

Example configuration:
 #+begin_src toml
[tool.ruff]
# increase line length to 100
line-length = 100
# support Python 3.11+
target-version = "py311"
# allow imports relative to the "src" and "test" directories
src = ["src", "test"]
# add additional rules
select = [
  # defaults
  "E",   # pycodestyle, omits stylistic checks covered by black
  "F",   # pyflakes
  "I",   # isort
  "N",   # pep8-naming
  "D",   # pydocstyle
  # ...
]
# github actions annotations
# format = "github"
 #+end_src

See ~noct-lsp-pyright~.

*** LPY
#+begin_src emacs-lisp
(use-package function-args)

(use-package lpy
  :disabled t
  :ghook 'python-base-mode-hook
  :config
  (general-def lpy-mode-map
    :definer 'lpy
    ;; basic Colemak navigation
    "n" #'lpy-down                      ; lose lispy-new-copy -> y
    "e" #'lpy-up                        ; lose lispy-eval -> l
    "i" #'lpy-right                     ; lose lpy-tab -> t
    ;; s and w don't exist
    "l" #'lispy-eval                    ; (freed by i)
    "L" #'lispy-eval-and-insert         ; (unbound)
    "y" #'lispy-new-copy                ; lose lpy-occur -> /
    "/" #'lpy-occur                     ; lose lpy-contents
    "w" #'lispy-narrow                  ; (unbound)
    ;; "W" #'lispy-widen
    ;; lispy-x
    "t" #'lpy-tab       ; lose lpy-teleport -> j
    "j" #'lpy-teleport  ; (freed by n)
    ;; d
    "o" #'lispy-different ; lose lpy-open (weird currently; requires active region)
    "k" #'lispy-flow      ; (freed by e)
    ;; swap m and v
    "v" #'lpy-mark
    "m" #'lpy-view
    ;; unbound
    "H" #'lispy-beginning-of-defun))
#+end_src

*** REPL
#+begin_src emacs-lisp
(general-with-package 'python
  ;; just let pet set; ipython doesn't support older python versions either
  ;; (gsetq python-shell-interpreter "ipython"
  ;;        python-shell-interpreter-args "-i --simple-prompt --no-color-info")
  (when (eq system-type 'darwin)
    ;; breaks things on OSX
    (gsetq python-shell-completion-native-enable nil))
  ;; doesn't work
  ;; (gsetq python-shell-interpreter "ptpython"
  ;;        python-shell-interpreter-args "")

  (general-m python-base-mode-map
    "b" #'python-shell-send-buffer
    "d" #'python-shell-send-defun
    ;; "l" 'python-shell-send-line
    ;; "m" #'python-shell-switch-to-shell
    ";" #'python-shell-switch-to-shell)

  (general-def 'visual python-base-mode-map
    ;; eva[l]
    "l" #'python-shell-send-region)

  ;; automatically start shell for commands that use it
  (defun noct-python-shell-get-process (&rest _)
    "Return the python process, starting it if necessary."
    (or (python-shell-get-process)
        (progn (run-python)
               (python-shell-get-process))))

  (general-add-advice 'python-shell-get-process-or-error
                      :override #'noct-python-shell-get-process))
#+end_src

*** Pydoc
Better than default LSP equivalent.
#+begin_src emacs-lisp
(noct-use pydoc
  (once-with 'python
    (general-m python-base-mode-map
      "h" #'pydoc-at-point
      "/" #'pydoc)))
#+end_src

*** Docstrings
#+begin_src emacs-lisp
;; adds syntax highlighting for reST (and epydoc) docstrings and makes filling
;; work as expected.(for all multi-line strings)
(use-package python-docstring
  :ghook 'python-base-mode-hook
  :blackout t
  :config
  ;; doesn't indent correctly... but fill-paragraph is worse?
  ;; (general-def python-docstring-mode-map "M-q" nil)
  )

;; allows inserting reST docstring skeleton
(use-package sphinx-doc
  ;; TODO switch to generic docstr package
  :disabled t
  :ghook 'python-base-mode-hook
  :blackout t
  :config
  (once-with 'python
    (general-m python-base-mode-map
      "s" #'sphinx-doc)))
#+end_src

*** Formatting
TODO see python-isort
#+begin_src emacs-lisp
(use-package py-isort)
;; (general-add-hook 'before-save-hook 'py-isort-before-save)

;; using black with lsp instead now
;; (use-package py-yapf)
;; (use-package py-autopep8)

(general-with-package 'python
  ;;  https://gist.github.com/kracekumar/77d29c7410199fd2cda4
  (defun python-remove-unused-imports ()
    "Use Autoflake to remove unused function.
$ autoflake --remove-all-unused-imports -i unused_imports.py"
    (interactive)
    (when (eq major-mode 'python-mode)
      (shell-command (concat "autoflake --remove-all-unused-imports -i "
			                 (shell-quote-argument (buffer-file-name))))
      (revert-buffer t t t))
    nil)

  ;; isort alone is already too slow to add to before-save-hook
  ;; (benchmarks at almost a second)
  (defun noct-python-format-buffer ()
    (interactive)
    (python-remove-unused-imports)
    (py-isort-buffer)
    (lsp-format-buffer))

  (general-def 'normal python-base-mode-map
    "m=" #'noct-python-format-buffer))
#+end_src

*** TODO Debugger

*** TODO Pycoverage
Needs extra setup (need to pip install cov2emacs that is in source directory).
#+begin_src emacs-lisp
(use-package pycoverage
  :disabled t
  :ghook 'python-base-mode-hook)
#+end_src

*** Requirements Mode
#+begin_src emacs-lisp
(use-package pip-requirements)
#+end_src

*** Poetry
#+begin_src emacs-lisp
(use-package poetry)
#+end_src

*** Jupyter (Ein)
- The easiest way to use jupyter when using hatch to manage the virtual environment/dependencies is to add jupyter as a dependency in the pyproject.toml rather than use a globally installed jupyter (which would require [[https://www.geeksforgeeks.org/using-jupyter-notebook-in-virtual-environment/][manually compiling and selecting a new kernel inside the environment]])
- To have ein use hatch, create a .dir-locals.el file with ~((nil . ((ein:jupyter-server-command . "hatch-jupyter"))))~ (where hatch-jupyter is a script in the path to run ~hatch run jupyter "$@"~) then =M-x ein:run=
#+begin_src emacs-lisp
(use-package ein
  :init
  (general-pushnew '(ein:jupyter-server-command . "hatch-jupyter")
                   safe-local-variable-values)
  ;; :config
  ;; (general-def 'normal ein:notebook-mode-map
  ;;   "RET" #'ein:worksheet-execute-cell-km)

  ;; (general-def 'normal poly-ein-mode-map
  ;;   "RET" #'ein:worksheet-execute-cell-km)
  )
#+end_src

*** Hatch
Setup
- ~hatch new --init~ (--init for existing project)
  - ensure ==__about__.py= file with something like =__version__ = 0.1.0=
  - ensure readme exists
- ~hatch env create~ (~hatch env prune~ if errors then recreate)
- ~hatch run x~

*** Pyenv and Auto-Virtualenv and Emacs Pet
Have ~export HATCH_ENV_TYPE_VIRTUAL_PATH=.venv~ in =.profile= and =in_project = true= in the poetry config.toml so autoenv and pyright can easily use virtual environments created by hatch.

[[https://github.com/wyuenho/emacs-pet][emacs-pet]] makes this unnecessary (automatically handling a lot of different project types).  I prefer pet's default precedence order, so I switched.  Detection by <root>/.venv seems to work fine without external dependencies, but I've also installed =dasel=.

#+begin_src emacs-lisp
(noct-use pyvenv
  (once-with 'python
    (general-m python-base-mode-map
      "v" #'pyvenv-workon
      "V" #'pyvenv-deactivate)))

;; tries name from .python-version and <project root>/(\.venv|\.virtualenv|venv)
;; see also https://github.com/robert-zaremba/auto-virtualenvwrapper.el
;; I am already using pyenv (elpy is not needed as a dependency for
;; auto-virtualenv)
(use-package auto-virtualenv
  ;; using pet instead now
  :disabled t
  :gfhook ('python-base-mode-hook #'auto-virtualenv-set-virtualenv))

;; avoid `pet-executable-find', which is slower and because don't want
;; executables from pre-commit venv normally
(defun noct-py-executable-find (venv executable)
  (let ((path (file-name-concat venv "bin" executable)))
    (if (file-executable-p path)
        path
      executable)))

;; prefers .venv over pyenv from .python-version unlike auto-virtualenv
(use-package pet
  :gfhook
  ('python-base-mode-hook
   ;; only set needed variables
   (noct-defun noct-pet-setup ()
	 ;; TODO need to fix for mise
     (let* ((venv (pet-virtualenv-root))
            (python-path (noct-py-executable-find venv "python")))
       (gsetq-local python-shell-virtualenv-root venv)
       (gsetq-local python-shell-interpreter python-path)
       (gsetq-local dap-python-executable python-path)

       (gsetq-local lsp-pyright-python-executable-cmd python-path)
       (gsetq-local lsp-pyright-venv-path venv)

       (gsetq-local lsp-ruff-python-path python-path)
       (gsetq-local lsp-ruff-server-command
                    (list (noct-py-executable-find venv "ruff")
                          "server"))))
   -10))
#+end_src

** R (ESS)
#+begin_src emacs-lisp
;; TODO having issues with this
;; (use-package ess)
#+end_src

** Scheme and Racket
*** Geiser
#+begin_src emacs-lisp
(use-package geiser
  :config
  (gsetq geiser-active-implementations '(chicken guile racket))

  (general-m (scheme-mode-map racket-mode-map)
    "b" #'geiser-eval-buffer
    "d" #'geiser-eval-definition
    "s" #'geiser-eval-last-sexp))
#+end_src

*** Racket
#+begin_src emacs-lisp
(use-package racket-mode)
#+end_src

** Shell Mode (Bash, Zsh)
#+begin_src emacs-lisp
(defun noct-sh-mode-setup ()
  (when (eq sh-shell 'bash)
    ;; also use shellcheck even though using lsp
    (setq yyoncho-flycheck-local-cache
          '((lsp . ((next-checkers . (sh-shellcheck sh-bash))))))
    (lsp)))

(use-package sh-script
  :ensure nil
  :gfhook ('sh-base-mode-hook #'noct-sh-mode-setup)
  :config
  ;; TODO make issues
  (general-with 'lsp-mode
    (general-add-advice
     'lsp-bash-check-sh-shell
     :override
     (noct-defun noct-lsp-bash-check-sh-shell (&rest _)
       (and (memq major-mode '(sh-mode bash-ts-mode))
            (memq sh-shell '(sh bash)))))
    (general-pushnew (cons 'bash-ts-mode "shellscript")
                     lsp-language-id-configuration))
  (general-with 'flycheck
    (put 'sh-bash 'flycheck-modes (list 'sh-mode 'bash-ts-mode))
    (general-pushnew 'zsh flycheck-shellcheck-supported-shells)))

(use-package company-shell
  :after company
  :init
  (general-pushnew '(company-shell company-shell-env) company-backends))
#+end_src

** Shen
#+begin_src emacs-lisp
(use-package shen-mode)
#+end_src

** TXR
#+begin_src emacs-lisp
(use-package txr-mode
  ;; it requires user local file
  :disabled t
  :ensure ( :host github
            :repo "piotrklibert/txr-mode"))
#+end_src

** Web, JavaScript, TypeScript
TODO
- https://github.com/skeeto/skewer-mode
- https://www.reddit.com/r/emacs/comments/9tr2vn/web_development_with_emacs_tips_and_tricks/
- https://github.com/NateEag/skewer-reload-stylesheets
- emmet

*** Eslint
#+begin_src emacs-lisp
;; make use .gitignore mode
;; https://www.reddit.com/r/emacs/comments/cem6h7/overwhelemed_js_jsjsx_rjsx_js2_js3_js2jsx_webmode/eu3zf70/
;; potentially useful
;; use eslint from node modules directory
;; (defun my/use-eslint-from-node-modules ()
;;   (let* ((root (locate-dominating-file
;;                 (or (buffer-file-name) default-directory)
;;                 "node_modules"))
;;          (eslint (and root
;;                       (expand-file-name "node_modules/eslint/bin/eslint.js"
;;                                         root))))
;;     (when (and eslint (file-executable-p eslint))
;;       (setq-local flycheck-javascript-eslint-executable eslint))))
;; (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
#+end_src

*** Web
#+begin_src emacs-lisp
(use-package web-mode
  ;; web-mode gives better syntax highlighting than just typescript-mode (and
  ;; supports jsx and tsx)
  :disabled t
  :mode ("\\.[tj]sx\\'" . web-mode)
  :gfhook
  #'lsp
  :config
  (gsetq
   ;; auto-close on >
   web-mode-auto-close-style 2
   ;; doesn't work well for ts:
   ;; - may want ={} OR =""
   ;; - incorrectly affects === inside {}
   web-mode-enable-auto-quoting nil))
#+end_src

*** TypeScript
#+begin_src emacs-lisp
(use-package typescript-ts-mode
  :ensure nil
  :gfhook #'lsp)

;; some extra functionality; main just using for auto-close
(use-package jtsx
  :mode (("\\.jsx?\\'" . jtsx-jsx-mode)
         ("\\.tsx?\\'" . jtsx-tsx-mode))
  :gfhook
  ('jtsx-jsx-mode-hook #'lsp)
  ('jtsx-tsx-mode-hook #'lsp))
#+end_src

*** Tailwind CSS
May need to manually ~lsp-install-server~ first.
 #+begin_src emacs-lisp
(noct-use lsp-tailwindcss
  (gsetq lsp-tailwindcss-add-on-mode t
         lsp-tailwindcss-major-modes
         '(typescript-ts-mode jtsx-jsx-mode jtsx-tsx-mode))
  (:require-once "lsp-mode"))
 #+end_src

* Miscellaneous
** Backup Each Save
Backup files on every save to prevent ever losing work.
#+begin_src emacs-lisp
(use-package backup-each-save
  :ghook ('after-save-hook #'backup-each-save)
  :config
  (gsetq backup-each-save-mirror-location "~/.emacs-backups"
         ;; backup TRAMP files
         backup-each-save-remote-files t
         ;; increase to cover largest text files?
         ;; backup-each-save-size-limit 1500000
         ))
#+end_src

** Benchmark Init
This is installed here and manually (and temporarily) enabled in my =init.el=.
#+begin_src emacs-lisp
(use-package benchmark-init)

(defun noct-end-benchmarking ()
  (interactive)
  (when noct-record-requires
    (advice-remove 'require #'noct-require-advice)
    (when (not noct-benchmark-init)
      (describe-variable 'noct-requires)))
  (when noct-benchmark-init
    (benchmark-init/deactivate)
    (benchmark-init/show-durations-tree)))

(general-t "b" #'noct-end-benchmarking)
#+end_src

** Hyperbole
Implicit links are occasionally useful.  For the most part, I'd rather use explicit org links.  In my case, implicit links are generally more useful for automatic cross referencing in cases where some text was not actually written with the intention of being a link.  The particularly nice ones I'm using are:
- Any elisp library in load path (e.g. subr.el; builtin)
- Jumping from a word/name/phrase/variable/function/etc. to a heading in a "wiki" org file (kind of like radio targets except multifile and automatic; defined below)

I might add this eventually:
- Variable, function, or key sequence in literal org syntax (jump to definition or execute key sequence)

How useful is this compared to embark given that I'm only using one of the builtin implicit links?  I'm not sure, but since I only need one action for these links, less code is needed with hyperbole than with embark, and I get some builtin implicit links out-of-the-box.  If I don't end up using any other builtin hyperbole features, I may switch to using embark.

#+begin_src emacs-lisp
(use-package hyperbole
  :defer-incrementally t
  :general
  ('normal "<S-return>" #'hkey-either)
  :init
  (autoload 'action-key "hyperbole")
  :config
  ;; technically unnecessary since hyperbole does this when you require it...
  (hyperbole-mode)

  ;; hyperbole rebinds C-h h...
  (general-def help-map "h" #'find-function)

  (defun noct--minify-heading-link (link)
    "Return a minified heading link.
- Strip the target
- Greedily strip around | or / (in case heading has multiple equivalent names)

Try stripping before the last | or after the first | and return the shorter
match."
    (let* ((no-target-link
            (s-replace-regexp (rx bol "[" (*? any) "]") "" link))
           (min-link-1
            (s-replace-regexp (rx (or "|" "/")
                                  (0+ any))
                              ""
                              no-target-link))
           (min-link-2
            (s-replace-regexp (rx (0+ any)
                                  (or "|" "/"))
                              ""
                              no-target-link)))
      (if (< (length min-link-1) (length min-link-2))
          min-link-1
        min-link-2)))

  (defun noct--find-matching-heading (bounds files &optional relaxed)
    "Look up org headings for text from BOUNDS in FILES.
Return a list of a link to the heading, the text at BOUNDS, and BOUNDS if a
match is found or nil otherwise.  By default try to match the text directly
after the heading start but with some leniency:

- Optionally after anything then \"|\" or \"/\" (the heading has equivalent
  names/aliases)
- Optionally after \"the\"
- Optionally after some org markup syntax

If RELAXED is non-nil, match the heading if the text appears anywhere in the
heading."
    (when (require 'org-ql nil t)
      (when-let (
                 ;; allow one of bounds to be nil (abort)
                 (beg (car bounds))
                 (end (cdr bounds))
                 (search-text (buffer-substring-no-properties beg end))
                 (link
                  (car-safe
                   (org-ql-query
                     ;; won't touch `org-stored-links' when not called
                     ;; interactively
                     :select '(org-store-link nil)
                     :from files
                     :where (list 'noct-heading-regexp
                                  (rx-to-string
                                   (if relaxed
                                       `(and (0+ any) ,search-text)
                                     `(and (? (0+ any)
                                              (or "|" "/")
                                              (0+ space))
                                           (? "the ")
                                           ;; basic org syntax
                                           (? (or "=" "~" "*"))
                                           ,search-text))))
                     ;; shortest matches first
                     :order-by
                     (lambda (a b)
                       (let ((a (noct--minify-heading-link a))
                             (b (noct--minify-heading-link b)))
                         (< (length a) (length b))))))))
        (list link search-text bounds))))

  (defun noct--find-matching-heading-at-point (&rest files)
    "Lookup org heading for word(s) at point in FILES in the current project.
Return a list of a link to the heading, the text at BOUNDS, and BOUNDS if a
match is found or nil otherwise.  Try finding a match the word at point and the
following word, the previous word and the word at point, or just the word at
point (in that order)."
    (when-let ((word-bounds (bounds-of-thing-at-point 'word))
               (2-words-bounds
                (save-excursion
                  (goto-char (cdr word-bounds))
                  (forward-word)
                  (cons (car word-bounds)
                        (cdr (bounds-of-thing-at-point 'word)))))
               (last-2-words-bounds
                (save-excursion
                  (goto-char (car word-bounds))
                  (backward-word)
                  (cons (car (bounds-of-thing-at-point 'word))
                        (cdr word-bounds)))))
      (or (noct--find-matching-heading 2-words-bounds files)
          (noct--find-matching-heading last-2-words-bounds files)
          (noct--find-matching-heading word-bounds files)
          (noct--find-matching-heading 2-words-bounds files t)
          (noct--find-matching-heading last-2-words-bounds files t)
          (noct--find-matching-heading word-bounds files t))))

  (defun noct-wiki-lookup-at-point ()
    "Lookup the words at point in the \"wiki\" file in the current project."
    (interactive)
    (when-let ((root (or (when (require 'projectile nil t)
                           (projectile-project-root))
                         default-directory))
               (files (or (file-expand-wildcards (concat root "*wiki*.org"))
                          (file-expand-wildcards (concat root "README.org")))))
      (apply #'noct--find-matching-heading-at-point files)))

  ;; define new implicit link type
  (defib noct-wiki-entry ()
    "A link to a wiki entry for a name at the point."
    (when-let ((match (noct-wiki-lookup-at-point))
               (link (car match))
               (word (cadr match))
               (bounds (caddr match)))
      (ibut:label-set word (car bounds) (cdr bounds))
      (hact 'org-link link))))
#+end_src

** Profile Dotemacs
This is installed here and manually (and temporarily) enabled in my =init.el=.
#+begin_src emacs-lisp
(noct-use ( :elpaca profile-dotemacs
            :host github :repo "raxod502/profile-dotemacs"))
#+end_src

** Memory Usage
I don't use this often, but it can be useful for profiling.
#+begin_src emacs-lisp
(use-package memory-usage)
#+end_src

** Free Keys
I really use this but keep it around just in case.
#+begin_src emacs-lisp
(use-package free-keys)
#+end_src

** Hardhat Mode
For making certain files read-only automatically.
#+begin_src emacs-lisp
(use-package hardhat
  ;; TODO nice idea needs some work; uses (require 'cl)
  :disabled t
  :init
  ;; https://github.com/rolandwalker/hardhat/issues/13
  (defvar ert--running-tests nil)

  (general-add-advice 'after-find-file :before #'global-hardhat-mode nil t)
  :blackout global-hardhat-mode)
#+end_src

* Applications/Other
** Calc
#+begin_quote
Like abacus experts, emacs experts continue to leave the mousers in the dust.  But we all know what became of abacus experts.  -- dickmao
#+end_quote

[[https://florian.adamsky.it/2016/03/31/emacs-calc-for-programmers-and-cs.html][Nice article on calc]]

#+begin_src emacs-lisp
(general-after 'evil
  (evil-set-initial-state 'calc-mode 'insert))

(use-package calc
  :ensure nil
  :general
  (general-s "k" #'calc)
  :config
  (general-def 'normal calc-mode-map
    "q" #'calc-quit))
#+end_src

** Dired
Performance notes:
- dired-k slows loading larger directories to a crawl (e.g. 0.08 -> 1 second; with all the icons -> 4 seconds; 450 items)
- all-the-icons-dired also slows loading larger directories (e.g. 0.08 -> 0.5 seconds; 450 items)

Dired-k isn't that useful, and while I really like all-the-icons-dired, I'd rather opening dired be fast.  Luckily, we now have dirvish, which is fast.  diff-hl's dired mode also seems fast, but I like dirvish's version for now.

*** TODO Setup
Notable packages not currently using:
- dired-du
- dired-xattr

TODO ls alternative that does correct sorting

#+begin_src emacs-lisp
(use-package dired
  :ensure nil
  :general ('normal "-" #'dired-jump)
  :gfhook
  ;; automatically refresh
  (nil #'auto-revert-mode)
  ;; by default only show filename
  ('dired-initial-position-hook #'dired-hide-details-mode)
  :config
  (gsetq dired-recursive-copies 'always
         dired-clean-confirm-killing-deleted-buffers nil
         ;; new in Emacs 28.1
         dired-kill-when-opening-new-dired-buffer t)

  (defvar noct-dired-listing-switches
    ;; -v - natural sort numbers
    ;; --almost-all - all except . and ..
    (concat "-l -v --human-readable --almost-all --group-directories-first "
            "--time-style=long-iso"))

  ;; neither supports dired
  ;; (cond ((executable-find "lsd")
  ;;        (gsetq insert-directory-program "lsd"
  ;;               dired-listing-switches
  ;;               "--classic --almost-all -l --human-readable --group-dirs first"))
  ;;       ((executable-find "exa")
  ;;        (gsetq insert-directory-program "exa"
  ;;               dired-listing-switches
  ;;               "--color never --oneline --all -l")))

  (let ((darwin (eq system-type 'darwin))
        (gls (executable-find "gls"))
        (nix-ls (string-match-p "\\.nix-profile/bin" (executable-find "ls"))))
    (when (or (eq system-type 'gnu/linux)
              (and darwin (or gls nix-ls)))
      (gsetq dired-listing-switches noct-dired-listing-switches)
      (when (and darwin (not nix-ls))
        (gsetq insert-directory-program "gls")))))
#+end_src

*** Basic Keybindings
#+begin_src emacs-lisp
(general-with 'dired
  (put 'dired-find-alternate-file 'disabled nil)

  (defun noct-dired-toggle-mark ()
    "Toggle marking the file at point.
If a region is active, toggle marking all files in the region."
    (interactive)
    (save-restriction
      (unless (region-active-p)
        (narrow-to-region (point-at-bol) (point-at-eol)))
      (dired-toggle-marks))
    (call-interactively #'dired-next-line))

  (general-def 'normal dired-mode-map
    "q" #'quit-window
    "gr" #'revert-buffer

    ;; navigation
    "gg" (general-l (goto-char 0))
    "h" #'dired-up-directory
    "n" #'dired-next-line
    "e" #'dired-previous-line
    "i" #'dired-find-alternate-file
    "f" #'find-file
    "F" #'noct-consult-find-fd

    ;; marking
    "," #'noct-dired-toggle-mark
    ;; this is actually very useful
    "\"" #'dired-mark-files-regexp
    "v" #'dired-toggle-marks
    "um" #'dired-unmark
    "uv" #'dired-unmark-all-marks

    "cn" #'dired-create-empty-file
    ;; make directory
    "cd" #'dired-create-directory

    ;; renaming/changing
    "cc" #'dired-do-rename
    "cm" #'dired-do-chmod
    "ch" #'dired-do-chown
    "cg" #'dired-do-chgrp

    "di" #'dired-do-delete
    "ud" #'trashed

    ;; encryption and decryption (epa-dired)
    "Ed" #'epa-dired-do-decrypt
    "Ev" #'epa-dired-do-verify
    "Es" #'epa-dired-do-sign
    "Ee" #'epa-dired-do-encrypt

    "RET" #'dired-do-shell-command

    ;; toggle details
    "TAB" #'dired-hide-details-mode)

  (general-m dired-mode-map
    "d" #'epa-dired-do-decrypt
    "v" #'epa-dired-do-verify
    "s" #'epa-dired-do-sign
    "e" #'epa-dired-do-encrypt)

  (general-def 'visual dired-mode-map
    "," #'noct-dired-toggle-mark
    "um" #'dired-unmark))
#+end_src

*** Quickmarks
#+begin_src emacs-lisp
(general-with 'dired
  (defmacro noct-dired-alt-file (filename)
    "Create a named function to visit FILENAME.
  The created function will act like `dired-find-alternate-file'."
    `(noct-defun ,(intern (format "noct-dired-alt-find-%s"
                                  (if (stringp filename)
                                      filename
                                    (cl-gensym)))) ()
       ,(format "Call `dired-find-alternate-file' on %s." filename)
       (interactive)
       (set-buffer-modified-p nil)
       ;; dired-jump will maintain pane-layout when using dirvish unlike `find-alternate-file'
       (if (featurep 'dirvish)
           (dired-jump nil ,filename)
         (find-alternate-file ,filename))))

  (general-def 'normal dired-mode-map
    :prefix "g"
    "/" (noct-dired-alt-file "/")
    "b" (noct-dired-alt-file "/bin/")
    "e" (noct-dired-alt-file "/etc/")
    "h" (noct-dired-alt-file "~/")
    "m" (noct-dired-alt-file "/media/")
    "t" (noct-dired-alt-file "/tmp/")
    "u" (noct-dired-alt-file "/usr/")
    "v" (noct-dired-alt-file "/var/")
    "V" (noct-dired-alt-file "/Volumes/"))

  (general-def 'normal dired-mode-map
    :prefix "'"
    "a" (noct-dired-alt-file "~/ag-sys")
    "b" (noct-dired-alt-file "~/dotfiles/scripts/bin/")
    "B" (noct-dired-alt-file "~/src/blog/pir-hana/")
    "c" (noct-dired-alt-file "~/src/")
    "d" (noct-dired-alt-file "~/database/")
    "e" (noct-dired-alt-file user-emacs-directory)
    "E" (noct-dired-alt-file "~/ag-sys/else/")
    "f" (noct-dired-alt-file "~/dotfiles/")
    "l" (noct-dired-alt-file "~/database/library/")
    "m" (noct-dired-alt-file "~/move/")
    "p" (noct-dired-alt-file "~/ag-sys/else/scrawl/prose/pots/")
    "P" (noct-dired-alt-file "~/ag-sys/prog/")
    "s" (noct-dired-alt-file "~/.emacs.d/elpaca/")
    "S" (noct-dired-alt-file "~/move/Screenshots/")
    "w" (noct-dired-alt-file "~/wallpaper/")))
#+end_src

*** Shell Commands
#+begin_src emacs-lisp
(general-with 'dired
  (defun noct-dired-async-run (command)
    "Run `dired-do-async-shell-command' with COMMAND and the marked files."
    (dired-do-async-shell-command command nil (dired-get-marked-files)))

  (defun noct-dired-unoconv-to-txt ()
    "Convert selected file(s) to txt with unoconv."
    (interactive)
    (noct-dired-async-run "unoconv -f txt"))

  (defun noct-dired-unoconv-to-pdf ()
    "Convert selected file(s) to pdf with unoconv."
    (interactive)
    (noct-dired-async-run "unoconv -f pdf"))

  (defun noct-dired-pandoc (extension)
    "Convert selected file(s) to end in EXTENSION."
    (interactive "sConvert to extension: ")
    (dolist (file (dired-get-marked-files))
      (let ((basename (noct-basename file)))
        (dired-do-async-shell-command
         (format "pandoc -o %s.%s" basename extension)
         nil
         (list file)))))

  (defun noct-dired-walset ()
    "Set wallpaper and update pywal colors."
    (interactive)
    (noct-dired-async-run "walset --zoom"))

  (defun noct-dired-bgset ()
    "Set wallpaper."
    (interactive)
    (noct-dired-async-run "bgset"))

  (defun noct-dired-upscale-2 ()
    "Upscale selected images or image at point 2x."
    (interactive)
    (noct-dired-async-run "upscale"))

  (defun noct-dired-upscale-10 ()
    "Upscale selected images or image at point 10x."
    (interactive)
    (noct-dired-async-run "upscale ? 10"))

  (defun noct-dired-upscale-20 ()
    "Upscale selected images or image at point 20x."
    (interactive)
    (noct-dired-async-run "upscale ? 20"))

  (defun noct-oxipng ()
    "Compress selected pngs or png at point with oxipng in-place (lossless)."
    (interactive)
    ;; higher than opt 4 not recommended (barely more compression)
    (noct-dired-async-run "oxipng --opt 4 --strip safe"))

  (defun noct-pngquant ()
    "Compress selected pngs or png at point to new <name>-fs.png (lossy)."
    (interactive)
    ;; higher than opt 4 not recommended (barely more compression)
    (noct-dired-async-run "pngquant"))

  (defun noct-to-high-quality-webp ()
    "Convert selected images or image at point to a quality 100 webp."
    (interactive)
    (noct-dired-async-run "cwebp_autoname -mt -q 100"))

  (defun noct-to-near-lossless-webp ()
    "Convert selected images or image at point to a -near_lossless 60 webp."
    (interactive)
    (noct-dired-async-run "cwebp_autoname -mt -near_lossless 60"))

  (defun noct-mat2 ()
    "Convert selected images or image at point to a -near_lossless 60 webp."
    (interactive)
    (noct-dired-async-run "mat2"))

  (general-def 'normal dired-mode-map
    "cM" #'noct-mat2
    "ct" #'noct-dired-unoconv-to-txt
    "cP" #'noct-dired-unoconv-to-pdf
    "cp" #'noct-dired-pandoc
    "cw" #'noct-dired-walset
    "cb" #'noct-dired-bgset
    "cu" #'noct-dired-upscale-2
    "cU" #'noct-dired-upscale-10
    "cX" #'noct-dired-upscale-20)

  (general-def 'normal dired-mode-map
    :infix "ci"
    "p" #'noct-oxipng
    "P" #'noct-pngquant
    "w" #'noct-to-high-quality-webp
    "W" #'noct-to-near-lossless-webp)

  (defun noct-dropmpgo ()
    (interactive)
    (noct-dired-async-run "dropmpgo"))

  (general-def 'normal dired-mode-map
    "O" #'noct-dropmpgo)

  (defun noct-dired-udiskie-umount ()
    "Unmount selected drive(s) with udiskie."
    (interactive)
    (noct-dired-async-run "udiskie-umount"))

  (defun noct-udiskie-umount-all ()
    "Unmount all drives with udiskie."
    (interactive)
    (call-process-shell-command "udiskie-umount --all &"))

  ;; TODO don't have a tray anymore; does this work with external cd reader?
  (defun noct-eject-tray ()
    "Eject tray."
    (interactive)
    (let ((default-directory "/sudo::")
          ;; don't try to get root password from auth sources
          auth-sources)
      (shell-command "eject /dev/sr0")))

  (general-def 'normal dired-mode-map
    "un" #'noct-dired-udiskie-umount
    "uN" #'noct-udiskie-umount-all
    "ue" #'noct-eject-tray)

  (defun noct-dired-sanitize ()
    "Sanitize permission of selected path(s)."
    (interactive)
    (noct-dired-async-run (format "sudo chmod -R u=rwX,go=rX"))
    (noct-dired-async-run (format "sudo chown -R \"%s\" " (getenv "USER"))))

  (general-def 'normal dired-mode-map
    "cs" #'noct-dired-sanitize)

  ;; TODO untested
  (defun noct-dired-beet-import ()
    "Call beet import on the selected path(s)."
    (interactive)
    (dired-do-shell-command "beet import"))

  (general-def 'normal dired-mode-map
    "cB" #'noct-dired-beet-import))
#+end_src

*** All the Icons Dired
Replaced in favor of dirvish which lazily adds icons instead of [[https://github.com/jtbm37/all-the-icons-dired/issues/41][always adding icons for everything in the directory]].

*** Dired Atool
#+begin_src emacs-lisp
(use-package dired-atool
  :general
  ('normal
   dired-mode-map
   "ux" #'dired-atool-do-unpack-with-subdirectory
   "uX" #'dired-atool-do-unpack
   "ca" #'dired-atool-do-pack)
  :config
  (cl-pushnew
   (list (rx "*dired-atool:" (0+ any)) #'display-buffer-no-window)
   display-buffer-alist))
#+end_src

*** Diredfl
Extra font lock rules (especially with details shown, e.g. colored persmissions, file sizes, etc.)
#+begin_src emacs-lisp
(use-package diredfl
  :ghook 'dired-mode-hook)
#+end_src

*** Dired Git Info
Dirvish replaces.
#+begin_src emacs-lisp
(use-package dired-git-info
  :disabled t
  :general ('normal dired-mode-map ")" #'dired-git-info-mode))
#+end_src

*** Dired K
Dirvish replaces (though not as pretty).
#+begin_src emacs-lisp
(use-package dired-k
  :disabled t
  :ghook
  ('dired-initial-position-hook #'dired-k)
  ('dired-after-readin-hook #'dired-k-no-revert))
#+end_src

*** TODO Dired Toggle Sudo
Change current user to root.  Is this really necessary with my =sd= keybinding?
#+begin_src emacs-lisp
(use-package dired-toggle-sudo
  :after dired
  ;; TODO broken?
  :general ('normal dired-mode-map "zs" #'dired-toggle-sudo))
#+end_src

*** TODO File Opening (External)
https://github.com/Vifon/dired-rifle.el
- Only supports rifle
https://github.com/thomp/dired-launch
- Allows setting a default launcher (e.g. xdg-open, open, rifle, etc.; has sane default based on system)
- Allows using custom commands for specific extensions
https://github.com/garberw/openwith
- Can match full filename (unlike dired-launch I think)
- Disowns process so closing Emacs doesn't affect it
- Affects all file finding
https://github.com/thamer/runner/
- Weird (provides commands for configuring its runner-alist but there's no harm in that; redefines dired commands without using override advice)
https://github.com/DamienCassou/unify-opening
- Uses dired-guess-shell-command for opening with other packages (e.g. org and mu4e)
https://github.com/sfllaw/emacs-launch/blob/master/launch.el
- Uses system launcher
https://github.com/Fuco1/dired-hacks/blob/master/dired-open.el
- Uses nohup (optionally)
- Modifies ~~dired-find-file~ directly instead of adding a new opening command

For now instead of modifying ~dired-find-file~ for specific extensions, I'm just using my own command.

TODO support automatically opening images in sorted order
TODO support passing list of marked files as argument instead of opening program for every marked file
#+begin_src emacs-lisp
(general-with 'dired
  (defun noct-dired-open-external ()
    "Open selected path(s) with external opener."
    (interactive)
    (let ((opener (cond ((executable-find "rifle")
                         "rifle")
                        ((executable-find "open")
                         "open"))))
      (when opener
        (dolist (file (dired-get-marked-files))
          (start-process "noct-dired-open" nil
                         opener (file-truename file))))))

  (general-def 'normal dired-mode-map "I" #'noct-dired-open-external))
#+end_src

*** Wdired
#+begin_src emacs-lisp
(use-package wdired
  :ensure nil
  :after dired
  :general ('normal dired-mode-map "w" #'wdired-change-to-wdired-mode)
  :config
  (gsetq wdired-create-parent-directories t
         wdired-allow-to-change-permissions t)

  (general-def 'normal wdired-mode-map
    "x" #'wdired-toggle-bit
    "RET" #'wdired-finish-edit))
#+end_src

*** Dired Hacks
**** Dired AVFS
Allows browsing archives.
#+begin_src emacs-lisp
(use-package dired-avfs
  :when (executable-find "avfs")
  :after dired
  :demand t)
#+end_src

**** Dired Collapse Mode
Show entire path for a directory (or chain of directories) that only contains a single file/directory (like on GitHub).
#+begin_src emacs-lisp
(use-package dired-collapse
  :general
  ('normal
   dired-mode-map
   "zc" #'dired-collapse-mode))
#+end_src

**** TODO Dired Filter
**** Dired Narrow
#+begin_src emacs-lisp
(use-package dired-narrow
  :general ('normal dired-mode-map "cf" #'dired-narrow-completion-styles)
  :config
  (general-def dired-narrow-map "ESC" #'keyboard-escape-quit)

  ;; https://github.com/Fuco1/dired-hacks/pull/169
  (defun dired-narrow--completion-styles-filter (filter)
    "Return whether `completion-styles' FILTER matches the current dired file."
    (completion-all-completions filter (list (dired-utils-get-filename 'no-dir))
                                nil (length filter)))

  (defun dired-narrow-completion-styles ()
    "Narrow a dired buffer to the files matching a `completion-styles' query."
    (interactive)
    (dired-narrow--internal #'dired-narrow--completion-styles-filter)))
#+end_src

*** Trashed
#+begin_src emacs-lisp
;; bound in dired
(use-package trashed
  :config
  (evil-collection-init 'trashed)

  (general-def 'normal trashed-mode-map
    ;; "RET" #'trashed-view-file
    ;; "RET" #'trashed-display-file
    ;; "RET" #'trashed-find-file
    "n" #'trashed-next-line
    "e" #'trashed-previous-line
    "TAB" #'trashed-mark
    "," #'trashed-mark
    "u" #'trashed-do-restore)

  (noct-handle-popup-same-window "Trash Can"))
#+end_src

*** Dirvish
Dirvish is a work of art.  It is fast.  It is unobtrusive.  It is elegant.  It is all this, and it still is dired.  It is exactly what a file manager in Emacs should be.  I thought ranger was still light-years ahead of dired, but dirvish has proved me wrong.

Dirvish solves these issues for me:
- It provides file copying/movement that is *both* multi-stage and asynchronous (unlike existing packages).  This is a game changer.
- Image preview is actually fast and usable.  I had stopped using all packages for image preview before because they didn't work well.  With dirvish, once an image is cached, it's as fast as any preview method that ranger has, and there is no flicker (unlike some ranger preview methods).  This is also a game changer.
- File preview in general works flawlessly out of the box and is customizable.
- Dirvish is gorgeous, more so than ranger, but it doesn't sacrifice speed.
  - The mode line is simple, customizable, and easy on the eyes.
  - Icon display is fast/lazy unlike dired-all-the-icons, which is unusably slow.
  - It can also replace the functionality of dired-k (very slow) and dired-git-info.
  - I only had to customize one face to get it to look great with my theme
- It provides a 3-pane layout that just works (parent directory, current directory, preview).  I never used ranger.el's 3-pane layout, but I will use dirvish's.  You can choose the number of panes (1, 2, or more than 3) and customize their sizes.
- It provides various other helpful commands/features like bookmarks
- It is a minimal layer on top of dired and requires minimal configuration.  I had to make many more keybindings for ranger.el since it creates alternatives for a lot of existing dired commands, and I had a bunch of ugly configuration because it was comparably invasive (as both a dired user and as an evil user).

Dirvish replaces multiple packages:
- Replaces ranger.el (though not a ranger clone)
- Replaces dired-async, tmtxt-dired-async, dired-ranger, etc.
- Replaces dired-all-the-icons with a much more performant implementation
- Can replace dired-k, dired-git-info, and diff-hl-dired-mode (though my experience with diff-hl was much better than dired-k)

#+begin_src emacs-lisp
(noct-use dirvish
  (general-s "r" #'dirvish)
  ;; (:fhooks (noct-disable display-line-numbers-mode))
  ;; truncate long file names instead of wrapping
  ;; (:fhooks 'dirvish-find-entry-hook
  ;;          (lambda (&rest _) (gsetq-local truncate-lines t)))
  ;; (:fhooks 'dirvish-preview-setup-hook
  ;;          (noct-defun noct-dirvish-preview-setup ()
  ;;            (display-line-numbers-mode -1)
  ;;            (gsetq-local mode-line-format nil
  ;;                         truncate-lines t)))
  (:require-once "dired")
  (:config
    (require 'dirvish-extras)

    ;; (gsetq dirvish-bookmarks-alist)

    ;; TODO fix symlink-arrow or don't, do I really need inline?
    ;; (dirvish-define-attribute symlink-arrow
    ;;   "Show -> on symlinks but not full target."
    ;;   :when (and dired-hide-details-mode
    ;;              (default-value 'dired-hide-details-hide-symlink-targets))
    ;;   (when (< (+ f-end 4) l-end)
    ;;     (let ((ov (make-overlay (+ f-end 4) l-end)))
    ;;       (overlay-put ov 'invisible t) ov)))

    (gsetq dirvish-yank-overwrite-existing-files 'never
           dirvish-attributes '(all-the-icons file-size vc-state)
           ;; dirvish-attributes '(all-the-icons file-size vc-state symlink-arrow)

           ;; not 'append-to-ext
           dirvish-yank-new-name-style 'append-to-filename
           dirvish-mode-line-position 'global
           dirvish-mode-line-format
           '(:left
             (" " file-modes " " file-link-number " " file-user ":" file-group " "
              symlink omit vc-info)
             :right
             (sort yank index))
           dirvish-header-line-format
           '(:left
             (path symlink)
             :right
             (free-space))
           dirvish-layout-recipes
           (list '(0 0 0.8)
                 '(0 0 0.4)
                 dirvish-default-layout))

    ;; TODO once-gui
    (general-after-gui
      (gsetq dirvish-header-line-height
             (cons (noct-mode-line-height)
                   (noct-mode-line-height))
             dirvish-mode-line-height
             (cons (noct-smaller-mode-line-height)
                   (noct-smaller-mode-line-height))))

    (when (ignore-errors (ewal-load-colors))
      (set-face-attribute 'dirvish-hl-line nil
                          :background (ewal-get-color 'green -5)))

    (general-def 'normal dired-mode-map
      "q" #'dirvish-quit

      ;; https://github.com/alexluigit/dirvish/issues/186
      "i" #'dired-find-file

      "a" #'dirvish-dispatch

      "l" #'dirvish-history-go-backward
      "L" #'dirvish-history-go-forward
      "b" #'dirvish-history-jump

	  "M" #'dirvish-layout-switch

      "z" #'dirvish-setup-menu

      "yp" #'dirvish-copy-file-path
      "yn" #'dirvish-copy-file-name
      "yd" #'dirvish-copy-file-directory

      "pp" #'dirvish-yank
      "pm" #'dirvish-move
      "pl" #'dirvish-symlink
      "pL" #'dirvish-relative-symlink
      "ph" #'dirvish-hardlink

      "o" #'dirvish-quicksort

      "du" #'dirvish-total-file-size)

    (dirvish-override-dired-mode)
    ;; find-file preview
    (dirvish-peek-mode)))
#+end_src

**** Dirvish Tabs
#+begin_src emacs-lisp
(defun noct-dirvish-frame ()
  "Setup an Emacs frame dedicated to dirvish."
  (dirvish)

  ;; # TODO preview never shows when daemon just started; dired-find-file and dired-jump open new window
  ;; # TODO need to run dired-jump first for subsequent runs to fix this...
  ;; # can run dirvish manually to fix... should work from first launch
  ;; TODO completely messed up first time
  (noct-elpaca-after-init
    (dirvish)
    (tab-bar-mode))
  (defun noct-goto-dirvish-tab (num)
    ;; tabs are 1-indexed
    (let* ((tabs (funcall tab-bar-tabs-function))
           (tab-count (length tabs)))
      (if (<= num tab-count)
          (tab-select num)
        (tab-new-to num)
        (dirvish))))
  (general-def 'normal dired-mode-map
    :prefix "m"
    "a" (noct-c (noct-goto-dirvish-tab 1))
    "r" (noct-c (noct-goto-dirvish-tab 2))
    "s" (noct-c (noct-goto-dirvish-tab 3))
    "t" (noct-c (noct-goto-dirvish-tab 4))
    "d" (noct-c (noct-goto-dirvish-tab 5))
    "h" (noct-c (noct-goto-dirvish-tab 6))
    "n" (noct-c (noct-goto-dirvish-tab 7))
    "e" (noct-c (noct-goto-dirvish-tab 8))
    "i" (noct-c (noct-goto-dirvish-tab 9))
    "o" (noct-c (noct-goto-dirvish-tab 10))))
#+end_src

** Epa
The EasyPG assistant.
#+begin_src emacs-lisp
(use-package epa
  :ensure nil
  :general (general-s "E" #'epa-list-keys)
  :config
  (noct-handle-popup-same-window epa-key-list-mode)
  (noct-handle-popup-same-window epa-key-mode)
  (general-def 'normal epa-key-list-mode-map
    "gr" #'revert-buffer
    "q" #'epa-exit-buffer
    "f" #'link-hint-open-link
    "RET" #'epa-show-key
    "," #'epa-mark-key))

(noct-use (:no-install epa)
  (general-s "E" #'epa-list-keys)
  (:config
   (noct-handle-popup-same-window epa-key-list-mode)
   (noct-handle-popup-same-window epa-key-mode)
   (general-def 'normal epa-key-list-mode-map
     "gr" #'revert-buffer
     "q" #'epa-exit-buffer
     "f" #'link-hint-open-link
     "RET" #'epa-show-key
     "," #'epa-mark-key)))
#+end_src

** Ebuku
#+begin_src emacs-lisp
(noct-use ebuku)
#+end_src

** Emacs Everywhere
:PROPERTIES:
:ID:       730336f0-f552-4ee6-bf7b-2847e48f16ea
:END:
#+begin_src emacs-lisp
(use-package emacs-everywhere
  :config
  (general-def 'normal emacs-everywhere-mode-map
    "RET" #'emacs-everywhere-finish-or-ctrl-c-ctrl-c))
#+end_src

** Eat
#+begin_src emacs-lisp
(use-package eat
  ;; TODO I couldn't actually get this to work
  :ghook ('eshell-load-hook #'eat-eshell-mode)
  :config
  (gsetq eshell-visual-commands nil))
#+end_src

** Eshell
The nice thing about eshell is Emacs integration:
- ability to execute elisp
- intercept commands like man and ~grep <text> <file>~
- TRAMP integration (including docker container integration)
- ability to use ivy/helm/vertico/corfu for completion and search (shell can too)
- ability to use snippets (shell probably can too)
- evil for navigation/copying/etc. (shell and vterm also can)

That said, I don't do many complicated things in terminal, so I mostly use a dedicated terminal window for one-off commands and vterm for project related commands (e.g. ~yarn~ and ~make~).  Though for project commands, I try to use keybindings where possible (e.g. ~makefile-executor~).

The main use case of eshell for me is in situations where no other shell is available.  It will work on Windows if you're not using WSL and don't have vsh, and since it works with TRAMP, you can use it on systems (or containers) that don't have your normal shell.

TODO
- https://gitlab.com/ambrevar/emacs-fish-completion
- better prompt (multiline)
- complete in vertico... optionally?
- syntax highlight not working

#+begin_src emacs-lisp
(use-package eshell
  :ensure nil
  :general
  (general-s "e" #'eshell)
  :config
  ;; e.g. get cc on prompt line to work
  (evil-collection-init 'eshell)
  (general-def 'insert eshell-mode-map
    ;; override lispy ret
    "RET" #'eshell-send-input
    "C-r" #'consult-history))

(general-with 'esh-mode
  ;; performance improvement
  ;; https://old.reddit.com/r/emacs/comments/nv7x0h/eshells_speed_on_emacs_28_with_nativecompilation/h13brxk/
  (gsetq eshell-output-filter-functions
         (remove 'eshell-postoutput-scroll-to-bottom
                 eshell-output-filter-functions)))

;; TODO any point when using eat?
(use-package stutter
  :ensure (:host github :repo "Stebalien/stutter.el")
  :ghook 'eshell-mode-hook)

(use-package eshell-syntax-highlighting
  :ghook 'eshell-mode-hook)

;; didn't work; capf-autosuggest is more generic (works in comint and doesn't
;; rely on company)
;; (use-package esh-autosuggest
;;   :ghook 'eshell-mode-hook)
#+end_src

** Ement.el
 #+begin_src emacs-lisp
(use-package ement
  :init
  ;; https://github.com/alphapapa/ement.el/issues/132
  (defun noct-ement-connect-or-list-rooms ()
    "List matrix rooms or connect if not connected."
    (interactive)
    (require 'ement)
    (cond (ement-sessions
           (call-interactively #'ement-list-rooms))
          ((ement--read-sessions)
           (call-interactively #'ement-connect))
          (t
           (ement-connect :user-id (concat "@" user-login-name ":matrix.org")
                          :password (password-store-get "matrix")
                          ;; use pantalaimon
                          :uri-prefix "http://localhost:8009"))))
  :general
  (general-s "l" #'noct-ement-connect-or-list-rooms)
  :gfhook ('ement-room-mode-hook (noct-disable display-line-numbers-mode))
  :config
  (gsetq ement-room-send-message-filter #'ement-room-send-org-filter)

  (noct-handle-popup-same-window (rx "*Ement room description"))
  (noct-handle-popup-same-window (rx "*Ement event"))
  (noct-handle-popup-same-window (rx "*Ement compose"))

  ;; TODO write reply in separate buffer command?
  (defun noct-ement-send ()
    "Reply if on an event, otherwise send a new message."
    (interactive)
    (if (ement-event-p (ewoc-data (ewoc-locate ement-ewoc)))
        (call-interactively #'ement-room-write-reply)
      (call-interactively #'ement-room-send-message)))

  (general-def 'normal ement-room-list-mode-map
    "q" #'quit-window
    "RET" #'ement-room-list-RET
    "S" #'ement-create-space
    "C" #'ement-create-room)

  (general-def 'normal ement-room-mode-map
    "q" #'quit-window
    "m" #'ement-room-transient
    "i" #'ement-room-send-message
    "o" #'ement-room-compose-message
    "RET" #'noct-ement-send
    "c" #'ement-room-edit-message
    "d" #'ement-room-delete-message)

  (general-def ement-room-minibuffer-map
    "C-'" #'ement-room-compose-from-minibuffer)

  (general-def 'normal ement-describe-room-mode-map
    "q" #'quit-window))
 #+end_src

** LLM
*** Helpers
 #+begin_src emacs-lisp
(defmemoize noct-get-openai-key ()
  "Return openapi key."
  (password-store-get-field "openai" "apikey"))

(defmemoize noct-get-openrouter-key ()
  "Return openapi key."
  (password-store-get-field "openrouter" "gptel-apikey"))

(defmemoize noct-get-featherless-key ()
  "Return openapi key."
  (password-store-get-field "featherless" "gptel-apikey"))

(defconst noct-openrouter-models
  '(anthropic/claude-sonnet-4
    openai/gpt-4.1
    openai/gpt-4o-mini
    google/gemini-2.5-pro-preview
    deepseek/deepseek-chat-v3-0324:free
    deepseek/deepseek-r1-0528:free))

(defconst noct-featherless-models
  '(deepseek-ai/DeepSeek-V3-0324
    deepseek-ai/DeepSeek-R1-0528
    mistralai/Devstral-Small-2505
    Qwen/Qwen2.5-Coder-32B-Instruct
    all-hands/openhands-lm-32b-v0.1
    meta-llama/Llama-3.3-70B-Instruct
    mistralai/Mistral-Small-3.1-24B-Instruct-2503))
 #+end_src

*** DALL-E
 #+begin_src emacs-lisp
(use-package openai
  :ensure (:host github :repo "emacs-openai/openai")
  :config
  (setq openai-key (noct-get-openai-key)))

(use-package dall-e
  :ensure (:host github :repo "emacs-openai/dall-e")
  :config
  (gsetq dall-e-n 3
         dall-e-size "1024x1024")

  (general-def 'normal dall-e-mode-map
    "RET" #'dall-e-type-response)

  (noct-handle-popup-same-window (rx "*DALL-E")))
 #+end_src

*** Gptel
 #+begin_src emacs-lisp
(use-package gptel
  :general
  (general-s
    "RET" #'gptel
    "C-<return>" #'gptel-send
    "S-<return>" #'gptel-rewrite)
  (general-cc "g" #'gptel-meneu)
  (general-def 'visual "RET" #'gptel-send)
  :config
  (gsetq gptel-default-mode 'org-mode
         gptel-use-header-line nil
         gptel-expert-commands t)

  ;; doesn't work? and not good idea if response is too long
  ;; (defun dylan-next-org-heading ()
  ;;   "Move to the next org heading."
  ;;   (interactive)
  ;;   (when (eq major-mode 'org-mode)
  ;;     (org-next-visible-heading 1)
  ;;     (org-end-of-line)))
  ;; (general-add-hook 'gptel-post-response-hook #'dylan-next-org-heading)

  (when noct-personal-computer-p
    (gptel-make-openai "Openrouter"
      :host "openrouter.ai"
      :endpoint "/api/v1/chat/completions"
      :stream t
      :key #'noct-get-openrouter-key
      :models noct-openrouter-models)

    (gsetq gptel-backend
           (gptel-make-openai "Featherless"
             :host "api.featherless.ai"
             :endpoint "/v1/chat/completions"
             :stream t
             :key #'noct-get-featherless-key
             :models noct-featherless-models))

    (gsetq gptel-model (car noct-featherless-models)))

  (noct-handle-popup-same-window (rx "*ChatGPT"))
  (noct-handle-popup-same-window (rx "*Openrouter"))
  (noct-handle-popup-same-window (rx "*Featherless"))
  ;; for rewrite diff
  (noct-handle-popup-same-window (rx "*Diff"))
  (noct-handle-popup-same-window (rx "*gptel-query*"))

  (general-m 'normal gptel-mode
    :definer 'minor-mode
    "m" #'gptel-menu)

  (general-def 'normal gptel-mode-map "RET" #'gptel-send))

(noct-use ( :elpaca gptel-quick
            :host github
            :repo "karthink/gptel-quick")
  (gsetq gptel-quick-timeout 20)
  ;; + - generate longer summary
  ;; M-RET - switch to chat buffer
  (general-s "N" #'gptel-quick))
 #+end_src

*** Gptel Magit
#+begin_src emacs-lisp
(noct-use (:and (not noct-personal-computer-p)
                gptel-magit)
  (:hooks 'magit-mode-hook #'gptel-magit-install))
#+end_src

*** MCP
#+begin_src emacs-lisp
;; https://github.com/lizqwerscott/mcp.el
(noct-use mcp
  (general-cc
    "m" #'mcp-hub)
  (:require-once "gptel")
  (:config
    (gsetq mcp-hub-servers
           '(("fetch" . (:command "uvx" :args ("mcp-server-fetch")))
             ("playwright" . ( :command "npx"
                               :args ("--yes" "@playwright/mcp@latest")))
             ;; add library documentation
             ("context7" . ( :command "npx"
                             :args ("-y" "@upstash/context7-mcp@latest")))
             ("ddg-search" . (:command "uvx" :args ("duckduckgo-mcp-server")))))
    (require 'gptel-integrations)
    (noct-handle-popup-same-window (rx "*Mcp-Hub*"))
    (noct-elpaca-after-init
      (mcp-hub-start-all-server))))
#+end_src

*** Minuet
#+begin_src emacs-lisp
(noct-use minuet
  (general-s
    "<C-m>" #'minuet-complete-with-minibuffer)
  (:config
    (defun noct-minuet-use-featherless ()
      (interactive)
      ;; too slow
      ;; (plist-put minuet-openai-fim-compatible-options
      ;;            :model "mistralai/Devstral-Small-2505")
      ;; (plist-put minuet-openai-fim-compatible-options
      ;;            :name "Devstral")
      ;; also slow
      (plist-put minuet-openai-fim-compatible-options
                 :model "Qwen/Qwen2.5-Coder-7B-Instruct")
      (plist-put minuet-openai-fim-compatible-options
                 :name "Qwen Coder 2.5 7B")
      (plist-put minuet-openai-fim-compatible-options
                 :end-point "https://api.featherless.ai/v1/completions")
      (plist-put minuet-openai-fim-compatible-options
                 :api-key #'noct-get-featherless-key))

    ;; slower even with small model
    (defun noct-minuet-use-local ()
      (plist-put minuet-openai-fim-compatible-options
                 ;; :model "koboldcpp/qwen2.5-coder-7b-instruct-q5_k_m"
                 :model "koboldcpp/qwen2.5-coder-1.5b-instruct-q5_k_m")
      (plist-put minuet-openai-fim-compatible-options
                 :name "Qwen")
      (plist-put minuet-openai-fim-compatible-options
                 :end-point "https://localhost:5001/v1/completions"))

    (defun noct-minuet-use-openrouter ()
      (plist-put minuet-openai-fim-compatible-options
                 :model "mistralai/codestral-2501")
      (plist-put minuet-openai-fim-compatible-options
                 :name "Codestral")
      (plist-put minuet-openai-fim-compatible-options
                 :end-point "https://openrouter.ai/api/v1/completions")
      (plist-put minuet-openai-fim-compatible-options
                 :api-key #'noct-get-openrouter-key))

    (noct-minuet-use-openrouter)))
#+end_src

*** Aider
#+begin_src emacs-lisp
(defun noct-try-install-aider ()
  (unless (or (executable-find "aider")
              (not (executable-find "uv")))
    (shell-command (concat "uv tool install --force --python python3.12 "
                           "--with pip aider-chat@latest"))))

(noct-try-install-aider)

(noct-use aidermacs
  (gsetq aidermacs-default-model "openai/deepseek-ai/DeepSeek-V3-0324"
         ;; no ediff
         aidermacs-show-diff-after-change nil)
  ;; (setq aidermacs-backend 'vterm)
  (setenv "AIDER_MODEL" "openai/deepseek-ai/DeepSeek-V3-0324")
  (setenv "AIDER_OPENAI_API_BASE" "https://api.featherless.ai/v1")

  (noct-handle-popup-same-window (rx "*aidermacs"))

  (general-add-hook
   'aidermacs-before-run-backend-hook
   (noct-defun aidermacs-setup ()
     (setenv "AIDER_OPENAI_API_KEY" (noct-get-featherless-key))))

  ;; this is easier with aider.el
  (defun noct-change-default-aidermacs-model ()
    (interactive)
    (let ((model (completing-read "Model: " noct-featherless-models)))
      (gsetq aidermacs-default-model (format "openai/%s" model))))

  (general-cc
    "a" #'aidermacs-transient-menu
    "o" #'noct-change-default-aidermacs-model)

  (:config
    (general-m aidermacs-comint-mode-map
      "m" #'aidermacs-transient-menu)))
#+end_src

*** Chatgpt Shell
#+begin_src emacs-lisp
(use-package chatgpt-shell
  :config
  (gsetq chatgpt-shell-openai-key #'noct-get-openai-key))
#+end_src

** Music
- EMMS supports mpd, though I think the other options have nicer interfaces
- Simple-mpc - too simple
- Mingus - think I prefer over mpdel though would need to try both thoroughly again

*** Smudge
Liked songs is not a playlist.
 #+begin_src emacs-lisp
(use-package smudge
  :general
  (general-s
    :infix "s"
    "d" #'smudge-select-device
    "m" #'smudge-my-playlists
    "/" #'smudge-track-search
    "?" #'smudge-playlist-search
    "." #'smudge-recently-played)
  :config
  (setq smudge-oauth2-client-id
        (password-store-get-field "smudge" "id")
        smudge-oauth2-client-secret
        (password-store-get "smudge"))

  (noct-handle-popup-same-window smudge-playlist-search-mode)
  (noct-handle-popup-same-window smudge-track-search-mode)
  (noct-handle-popup-same-window smudge-device-select-mode)

  ;; NOTE: tabulated list keybindings are available for sorting
  (general-def 'normal (smudge-playlist-search-mode-map
                        smudge-track-search-mode-map)
    "f" #'link-hint-open-link
    "i" #'push-button
    "c" #'smudge-create-playlist)

  (general-def 'normal smudge-playlist-search-mode-map
    "gr" #'smudge-playlist-reload
    "u" #'smudge-playlist-load-more
    "o" #'smudge-playlist-select)

  (general-def 'normal smudge-track-search-mode-map
    "gr" #'smudge-track-reload
    "u" #'smudge-track-load-more
    ;; add to playlist
    "a" #'smudge-track-add))

;; smudge-track-playlist-follow
;; smudge-playlist-follow
 #+end_src

** Pass
#+begin_src emacs-lisp
(use-package password-store
  :general
  (general-s
    "y" #'password-store-copy
    "u" #'password-store-url))

;; built on top of password-store.el
(use-package pass
  :general (general-s "p" #'pass)
  :config
  (noct-handle-popup-same-window (rx "*Password-Store*"))

  ;; NOTE: imenu works
  (general-def 'normal pass-mode-map
    ;; can still edit
    "RET" #'pass-view
    ;; copy password
    "y" #'pass-copy
    ;; delete entry
    "d" #'pass-kill
    ;; create new entry with generated password
    "i" #'pass-insert-generated
    ;; without
    "I" #'pass-insert
    "r" #'pass-rename
    ;; currently don't use
    ;; "o" #'pass-otp-options
    "q" #'pass-quit
    "gr" #'pass-update-buffer))
#+end_src

** Proced
#+begin_src emacs-lisp
(defun noct-proced-setup ()
  (visual-line-mode -1)
  ;; needs to be set after above
  (setq truncate-lines t)
  ;; not global; has to be run in buffer
  (proced-toggle-auto-update t))

(use-package proced
  :ensure nil
  ;; [h]top replacement
  ;; have bound globally to modifier + p which makes more sense
  :general (general-s "h" #'proced)
  :gfhook #'noct-proced-setup
  :config
  (gsetq proced-auto-update-interval 2)
  (evil-collection-init 'proced))
#+end_src

** Shell
Shell has some of the advantages of eshell like ~completing-read~ integration in ~term-line-mode~, but it supports zsh and other shells.  Plugins like autosuggestions won't work in line mode (and at least with this basic configuration autosuggestions don't seem to work in char-mode either for fish or zsh).  Obviously, it can't execute emacs lisp.  It can run it on a remote host, but the shell has to be available there.

#+begin_src emacs-lisp
;; `shell-file-name' is used for `execute-shell-command' (leave as default)
(gsetq explicit-shell-file-name "zsh")

(use-package native-complete
  :disabled t
  :ghook
  ('shell-mode-hook
   (noct-defun noct-shell-setup ()
     (general-pushnew 'native-complete-at-point completion-at-point-functions)
     (when (boundp 'company-backends)
       (general-pushnew 'company-native-complete company-backends))
     ;; (gsetq comint-prompt-regexp noct-shell-prompt-pattern)
     (gsetq comint-prompt-read-only t
            shell-pompt-pattern noct-shell-prompt-pattern))))
#+end_src

** Vterm
Vterm is an actual terminal emulator and my preferred method for executing shell command in Emacs. The main downsides it has for me compared to eshell and shell currently:

- There are some things that need to be polished (e.g. it changes cursor shape which is confusing when using different cursors for evil: #342)
- Every character is sent to the terminal immediately, so evil line-editing is not yet possible (minor since Emacs line-editing keybindings are more efficient, and the current behavior works with autosuggestions; sending the line only on enter would break autosuggestions)
- It does not currently integrate with completing-read frontends for completion

It might be cool to eventually replace a dedicated terminal emulator with vterm. Scrollback search, navigation, and copying are definitely better in Emacs than in any terminal or multiplexer.

#+begin_src emacs-lisp
(defun noct-vterm-setup ()
  "Setup for vterm."
  (gsetq-local term-prompt-regexp noct-shell-prompt-pattern)
  (toggle-truncate-lines 1))

(use-package vterm
  ;; :general
  ;; ('normal 'override "T" #'vterm)
  :init
  ;; not defined, vterm checks boundp for some reason
  (defvar vterm-install t)
  :gfhook
  (nil (noct-disable-global-mode whitespace-mode))
  (nil #'noct-vterm-setup)
  :config
  (gsetq vterm-shell "zsh"
         ;; increase scrollback
         vterm-max-scrollback 10000
         ;; because I'm not printing the characters it expects in my prompt (see
         ;; .zshrc); just use regexp
         vterm-use-vterm-prompt-detection-method nil)

  (general-def vterm-mode-map
    "<prior>" nil
    "<next>" nil)

  (general-def 'normal vterm-mode-map
    "E" #'vterm-previous-prompt
    "N" #'vterm-next-prompt)

  (general-def 'normal vterm-mode-map
    "<escape>"
    (noct-defun noct-vterm-send-escape ()
      "Send <escape> key."
      (interactive)
      (vterm-send-key "<escape>")))

  ;; temporary to fix if re-eval
  (general-def 'insert vterm-mode-map
    "C-c" nil)
  (evil-collection-init 'vterm)
  ;; x is weird but I don't need it
  (general-def 'normal vterm-mode-map
    ;; swap a and a
    "a" #'evil-collection-vterm-append
    "A" #'evil-collection-vterm-append-line
    "s" nil
    "S" nil)

  (general-def 'visual vterm-mode-map
    "<home>" #'evil-beginning-of-visual-line
    "<end>" #'evil-end-of-visual-line)

  (general-def 'insert vterm-mode-map
    "<home>" #'vterm--self-insert
    "<end>" #'vterm--self-insert
    "C-r" #'vterm--self-insert
    "C-c" #'vterm--self-insert
    "C-u" #'vterm--self-insert
    "C-w" #'vterm--self-insert
    "C-<backspace>"
    (noct-defun noct-vterm-send-c-w ()
      "Send <escape> key."
      (interactive)
      (vterm-send-key "w" nil nil t)))

  ;; don't trigger my C-j keybinding
  (general-add-advice
   'vterm-send-return
   :override
   (noct-defun noct-vterm-send-C-m ()
     "Like `vterm-send-return' but always d `C-m'."
     (interactive)
     (deactivate-mark)
     (when vterm--term
       (process-send-string vterm--process "\C-m")))))


(defvar vterm-buffer-name)
(defun noct-vterm-select-or-create (&optional number)
  "Switch to a vterm buffer, creating it if it does not exist.
  NUMBER specifies which vterm buffer to switch to. If nil, switch to the
    \"vterm\" buffer."
  (let ((vterm-buffer-name (if number
                               (format "*vterm<%s>*" number)
                             "vterm")))
    (vterm)))

(use-package vterm-toggle
  :general
  ('normal 'override "T" #'vterm-toggle-cd)
  :init
  ;; (noct-handle-popup vterm-mode)
  ;; too early first time show for major mode to work
  (noct-handle-popup-same-window (rx "*vterm"))
  :config
  (gsetq vterm-toggle-fullscreen-p nil
         vterm-toggle-evil-state-when-enter nil
         vterm-toggle-evil-state-when-leave nil
         ;; don't create a new buffer if the prompt is not available
         vterm-toggle-cd-auto-create-buffer nil
         ;; vterm-toggle-hide-method 'reset-all-window-configuration
         vterm-toggle-hide-method 'bury-all-vterm-buffer)

  ;; (cl-defun noct-tmux-select-or-create (number &optional (session "emacs"))
  ;;     "Select the tmux window with NUMBER, cerating it if it does not exist.
  ;; If SESSION is specified, act on that session instead of \"emacs\"."
  ;;     (shell-command
  ;;      (format "tmux select-window -t %1$s:%2$s || tmux new-window -t %1$s:%2$s"
  ;;              session number)))

  (general-def 'normal vterm-mode-map
    "mm" #'vterm
    "mc" #'vterm-toggle-insert-cd
    "ma" #'vterm
    "mr" (general-l (noct-vterm-select-or-create 2))
    "ms" (general-l (noct-vterm-select-or-create 3))
    "mt" (general-l (noct-vterm-select-or-create 4))
    "md" (general-l (noct-vterm-select-or-create 5))
    "mh" (general-l (noct-vterm-select-or-create 6))
    "mn" (general-l (noct-vterm-select-or-create 7))
    "me" (general-l (noct-vterm-select-or-create 8))
    "mi" (general-l (noct-vterm-select-or-create 9))
    "mo" (general-l (noct-vterm-select-or-create 10))))
#+end_src

** Global Hotkeys and Shell Integration
*** Helpers
#+begin_src emacs-lisp
(noct-handle-popup (rx "*Shell Command Output*"))

(defvar noct-global-keybinding nil
  "Whether the current command was spawned by a global system keybinding.
This is used to prevent hiding or deleting frames when a command is not called
from a global keybinding.")

(defmacro noct-with-global-keybinding (&rest body)
  "Run BODY with `noct-global-keybinding' non-nil."
  (declare (indent 0) (debug t))
  `(let ((noct-global-keybinding t))
     ,@body))

(defmacro noct-with-reuse-window (&rest body)
  "Run BODY reusing the current window to open new buffers. "
  (declare (indent 0) (debug t))
  `(let ((display-buffer-alist '((".*" . (display-buffer-use-some-window)))))
     ,@body))

(defmacro noct-with-sudo-command (&rest body)
  "Run BODY with the default-directory' as /sudo::."
  (declare (indent 0) (debug t))
  `(progn
     (require 'tramp)
     (let ((default-directory "/sudo::")
           ;; don't try to get sudo password from auth-sources
           auth-sources
           (tramp-remote-path (append tramp-remote-path
                                      (s-split ":" (getenv "PATH")))))
       ,@body)))

(defmacro noct-with-global-completing-read (&rest body)
  "Run BODY with vertico taking up the full window height.
Open any new windows in same buffer"
  (declare (indent 0) (debug t))
  `(progn
     (defvar vertico-count)
     (defvar vertico-multiform-categories)
     (let ((vertico-count 1000)
           (vertico-multiform-categories
            '((t
               buffer
               (vertico-buffer-display-action . (display-buffer-use-some-window)))))
           (display-buffer-alist '((".*" . (display-buffer-use-some-window)))))
       ,@body)))

(defun noct-global-completing-read-dir (prompt dirs)
  "Run `completing-read' with PROMPT to select a directory from DIRS.
This will add the file completion category to the directories, display
completions in an existing window, and open any new windows in the same buffer."
  (noct-with-global-completing-read
    (completing-read prompt
                     (lambda
                       (str pred action)
                       (if
                           (eq action 'metadata)
                           '(metadata
                             (category . file))
                         (complete-with-action action dirs str pred))))))

(defun noct-completing-read-media-dir (prompt)
  "Use `completing-read' to select a directory under /media."
  (let ((dirs
         (f-directories "/media")))
    (noct-global-completing-read-dir prompt dirs)))

;; must declare before loading vterm
(defvar vterm-buffer-name)
(defun noct-run-with-vterm (command)
  "Run COMMAND in a vterm buffer.
Open the vterm buffer reusing a window."
  (noct-with-reuse-window
    (let ((vterm-buffer-name (format "*vterm %s*" (car (split-string command)))))
      (vterm)
      (vterm-insert command)
      (with-current-buffer vterm-buffer-name
        (evil-insert 1))
      (vterm-send-return))))

(defvar vertico-count)
(defvar vertico-multiform-categories)
;; TODO do in empty buffer?
;; TODO allow `completing-read-multiple'
(defun noct-file-filter (&optional file)
  "Use `completing-read' to select a line in the current buffer.
If FILE is specified, first visit FILE. After selection, replace the buffer
contents with the selected line, kill the buffer, and close the frame. This s
meant to be used from the command line (specifically with my esel script)."
  (interactive)
  (when file
    (find-file file))
  (unwind-protect
      ;; TODO show only the minibuffer
      (let* ((vertico-count 1000)
             (vertico-multiform-categories
              '((t
                 buffer
                 (vertico-buffer-display-action . (display-buffer-same-window)))))
             (selection (completing-read
                         "> "
                         (thread-first (buffer-substring-no-properties
                                        (point-min)
                                        (point-max))
                                       (split-string (rx (1+ "\n")) t)
                                       ;; TODO optional
                                       ;; (delete-dups)
                                       ))))
        (when selection
          (delete-region (point-min) (point-max))
          (insert selection)
          (save-buffer)))
    (kill-buffer)
    (save-buffers-kill-terminal)
    ;; makes flicker much better
    ;; (switch-to-buffer "*blank*")
    ;; (call-process-shell-command "xdotool getactivewindow windowunmap")
    ))
#+end_src

*** Shell Command Menu
;; TODO differentiate when called globally (don't delete frames)
;TODO audio should close automatically update sxhkrd
; fix delete frame

**** Frame Hiding
#+begin_src emacs-lisp
(defun noct-maybe-hide-frame ()
  "Unmap this frame with xdotool if `noct-global-keybinding'."
  (when noct-global-keybinding
    (start-process "noct-unmap" nil "xdotool" "windowunmap" (fg--wid))))
#+end_src

**** Audio
#+begin_src emacs-lisp
(defun noct-hdmi-audio ()
  "Switch to hdmi audio.
Delete the frame if `noct-global-keybinding'."
  (interactive)
  (start-process "hdmi-audio" nil "audio_switch" "hdmi")
  (noct-maybe-hide-frame))

(defun noct-analog-audio ()
  "Switch to analog audio.
Delete the frame if `noct-global-keybinding'."
  (interactive)
  (start-process "hdmi-audio" nil "audio_switch" "analog")
  (noct-maybe-hide-frame))
#+end_src

**** Backup
#+begin_src emacs-lisp
(defun noct--local-borg-backup (command args)
  "Run local borg backup COMMAND with ARGS."
  ;; uses `let*'
  (when-let ((dirs (f-directories "/media"))
             (backup-dir
              ;; (noct-completing-read-media-dir "Backup to: ")
              (frog-menu-read "Backup to: " dirs)))
    (noct-run-with-vterm (concat
                          "borg_backup "
                          command
                          " "
                          (string-join args " ")
                          " "
                          (shell-quote-argument backup-dir)))))

(defun noct-borg-small-local-backup (&optional args)
  "Run small local borg backup with ARGS."
  (interactive (list (transient-args 'noct--backup-menu)))
  (noct--local-borg-backup "borg_small" args))

(defun noct-borgbase-small-backup (&optional args)
  "Run small local borg backup with ARGS."
  (interactive (list (transient-args 'noct--backup-menu)))
  (noct-run-with-vterm (concat
                        "borg_backup borgbase_small "
                        (string-join args " "))))

(general-with 'transient
  (transient-define-prefix noct--backup-menu ()
    "Create a backup with borg."
    ["Arguments"
     ("-n" "Don't check integrity" "-n")]
    ["Backup"
     ("s" "Small local" noct-borg-small-local-backup)
     ("r" "Small remote" noct-borgbase-small-backup)
     ;; ("b" "Big local")
     ])

  (defun noct-backup-menu ()
    "Reusing current window, call `noct--backup-menu'.
This is suitable for a global keybinding that creates a new Emacs frame."
    (interactive)
    (noct-with-reuse-window (noct--backup-menu))))
#+end_src

**** Filesystem and Mounting/Unmounting
#+begin_src emacs-lisp
(defun noct--lsblk ()
  "Run lsblk and display the output."
  (interactive)
  (noct-with-reuse-window
    (shell-command "lsblk")))

(defun noct-unmount-media ()
  "Unmount something under /media with udiskie."
  (interactive)
  (let ((unmount-dir (noct-completing-read-media-dir "Unmount: ")))
    (shell-command (concat "udiskie-umount "
                           (shell-quote-argument unmount-dir)))))

(defun noct-lvm-umount-datab ()
  "Unmount database."
  (interactive)
  (noct-with-reuse-window
    (noct-run-with-vterm "borg_backup umountdatab")))

(defun noct-lvm-mount-datab ()
  "Mount database."
  (interactive)
  (noct-with-reuse-window
    (noct-run-with-vterm "borg_backup mountdatab")))
#+end_src

**** Miscellaneous Aliases
#+begin_src emacs-lisp
(defun noct-restow ()
  "Restow dotfiles."
  (interactive)
  (noct-with-reuse-window
    (noct-run-with-vterm "restow")))
#+end_src

**** Systemd
#+begin_src emacs-lisp
(defun noct--systemd-read (prompt args &optional state)
  "Run `completing-read' on a list of systemd services.
Use PROMPT and add ARGS to systemctl command. Only show services with STATE if
it is specified."
  ;; uses `let*'
  (noct-with-global-completing-read
    (when-let ((base-command
                (concat
                 "systemctl list-units --no-pager --no-legend "
                 "--all --type=service "
                 (string-join args " " )))
               (command
                (concat (if state
                            (concat base-command " --state=" state)
                          base-command)
                        " | grep -v not-found"))
               (services
                (mapcar
                 (lambda (str) (car (split-string str)))
                 (split-string (shell-command-to-string command)
                               (rx (1+ "\n"))
                               t))))
      (completing-read prompt services))))

(defun noct--systemd-command (prompt command
                                     &optional args sudo delete-frame state)
  "Run a systemd command, selecting the service with `completing-read'.
PROMPT should be the prompt when selecting the service. COMMAND should be the
command to append the selected service. ARGS can contain arguments to pass to
the list-units command. If sudo is non-nil, run the command with sudo. If
DELETE-FRAME is non-nil, delete the frame on SUCCESS. If STATE is non-nil, only
allow selecting from units with that state."
  (let ((service (noct--systemd-read prompt args state))
        (default-directory (if sudo "/sudo::" default-directory))
        auth-sources)
    (noct-with-reuse-window
      (when (and (= (shell-command (concat command service)) 0)
                 delete-frame
                 noct-global-keybinding)
        (delete-frame)))))

(defun noct-systemctl-service-status (&optional args)
  "Show the status of a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Show service status: "
                         "systemctl --no-pager status "
                         args))

(defun noct-journalctl-logs (&optional args)
  "Show the journalctl logs of a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Show journactl logs: "
                         "journalctl --no-pager -u "
                         args))

(defun noct-systemctl-start-service (&optional args)
  "Start a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Start service: " "systemctl start " args t t))

(defun noct-systemctl-restart-service (&optional args)
  "Restart a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Retart service: " "systemctl restart " args t t))

(defun noct-systemctl-stop-service (&optional args)
  "Stop a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Stop service: " "systemctl stop " args t t "active"))

(defun noct-systemctl-enable-service (&optional args)
  "Enable and start a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Enable and start service: " "systemctl enable --now"
                         args t t))

(defun noct-systemctl-disable-service (&optional args)
  "Disable and stop a systemd service.
ARGS can contain args to add to the systemctl list-units command."
  (interactive (list (transient-args 'noct--systemctl-menu)))
  (noct--systemd-command "Disable and stop service: " "systemctl disable --now"
                         args t t "active"))

(general-with 'transient
  (transient-define-prefix noct--systemctl-menu ()
    "Run a systemctl command using `completing-read' to select the service."
    ["Arguments"
     ("-u" "Act on user services" "--user")]
    ["Systemctl"
     ("s" "Service status" noct-systemctl-service-status)
     ("j" "Journalctl logs" noct-journalctl-logs)
     ("t" "Start service" noct-systemctl-start-service)
     ("p" "Stop service" noct-systemctl-stop-service)
     ("r" "Restart service" noct-systemctl-restart-service)
     ("e" "Enable/start service" noct-systemctl-enable-service)
     ("d" "Disable/stop service" noct-systemctl-disable-service)])

  (defun noct-systemctl-menu ()
    "Reusing current window, call `noct--systemctl-menu'.
This is suitable for a global keybinding that creates a new Emacs frame."
    (interactive)
    (noct-with-reuse-window (noct--systemctl-menu))))
#+end_src

**** Vpn
#+begin_src emacs-lisp
;; memoized
(defun noct--wireguard-names ()
  "Return a list of available wireguard configurations."
  (let ((default-directory "/sudo::/etc/wireguard")
        auth-sources)
    (mapcar (lambda (path)
              (file-name-sans-extension (f-filename path)))
            (f-files "./"))))

(defun noct--wireguard-command (prompt command)
  "Run a wireguard command.
Select a wireguard configuration using PROMPT and then run COMMAND on it."
  (interactive)
  (noct-with-global-completing-read
    (noct-with-sudo-command
      (let* ((wireguard-names (noct--wireguard-names))
             (wireguard-name (completing-read prompt wireguard-names)))
        (when (and (= (shell-command (concat command " " wireguard-name))
                      0)
                   noct-global-keybinding)
          (delete-frame))))))

(defun noct-vpnup ()
  "Start wireguard vpn."
  (interactive)
  (noct--wireguard-command "Start vpn: " "vpnup"))

(defun noct-vpndown ()
  "Stop wireguard vpn."
  (interactive)
  (noct--wireguard-command "Stop vpn: " "vpndown"))

(defun noct-revpn ()
  "Restart wireguard vpn."
  (interactive)
  (noct--wireguard-command "Restart vpn: " "revpn"))

(general-with 'transient
  (require 'memoize)
  (memoize 'noct--wireguard-names)

  (noct-with-global-keybinding
    (transient-define-prefix noct--vpn-menu ()
      "Start/stop wireguard vpn."
      ["Wireguard vpn"
       ("u" "Vpn up" noct-vpnup)
       ("d" "Vpn down" noct-vpndown)
       ("r" "Restart vpn" noct-revpn)]))

  (defun noct-vpn-menu ()
    "Reusing current window, call `noct--vpn-menu'.
This is suitable for a global keybinding that creates a new Emacs frame."
    (interactive)
    (noct-with-reuse-window (noct--vpn-menu))))
#+end_src

**** X11
#+begin_src emacs-lisp
(defun noct-xprop ()
  "Run xprop in the curernt window."
  (interactive)
  (noct-with-reuse-window
    (shell-command "xprop")))

(defun noct-xwininfo ()
  "Run xwininfo in the curernt window."
  (interactive)
  (noct-with-reuse-window
    (shell-command "xwininfo")))

(defun noct-xev ()
  "Run xev in the curernt window."
  (interactive)
  (noct-with-reuse-window
    (noct-run-with-vterm "xev")))
#+end_src

**** Menu
#+begin_src emacs-lisp
(general-with 'transient
  (transient-define-prefix noct--shell-menu ()
    "Shell command menu."
    [:description "Shell commands"]
    ["Audio"
     ("h" "Switch to hdmi audio" noct-hdmi-audio
      ;; don't exit transient
      :transient t)
     ("a" "Switch to analog audio" noct-analog-audio
      :transient t)]
    ["Backup"
     ("b" "Backup" noct-backup-menu)]
    ["Filesystem"
     ("l" "Lsblk" noct--lsblk)
     ("u" "Udiskie unmount" noct-unmount-media)
     ("d" "Lvm mount database" noct-lvm-mount-datab)
     ("D" "Lvm unmount database" noct-lvm-umount-datab)]
    ["Miscellaneous"
     ("r" "Restow" noct-restow)
     ("SPC" "Capture" org-capture)]
    ["Package Management"
     ("i" "AUR installed packages" aurel-installed-packages)
     ("/" "AUR package search" aurel-package-search)]
    ["Systemctl"
     ("s" "Systemctl commands" noct-systemctl-menu)]
    ["Vpn"
     ("v" "Vpn commands" noct-vpn-menu)]
    ["X11"
     ("w" "Xwininfo" noct-xwininfo)
     ("x" "Xprop" noct-xprop)
     ("X" "Xev" noct-xev)]))

(defun noct-shell-menu ()
  "Reusing current window, call `noct--shell-menu'.
This is suitable for a global keybinding that creates a new Emacs frame."
  (interactive)
  (require 'transient)
  (noct-with-reuse-window (noct--shell-menu)))
#+end_src

* Fun/Games
** Fireplace
#+begin_src emacs-lisp
(use-package fireplace)
#+end_src

** Screenshots
[[https://www.reddit.com/r/emacs/comments/idz35e/emacs_27_can_take_svg_screenshots_of_itself/][Emacs 27 supports svg screenshots of itself.]]
#+begin_src emacs-lisp
(defun screenshot-svg ()
  "Save a screenshot of the current frame as an SVG image.
Saves to a temp file and puts the filename in the kill ring."
  (interactive)
  (let* ((filename (make-temp-file "Emacs" nil ".svg"))
         (data (x-export-frames nil 'svg)))
    (with-temp-file filename
      (insert data))
    (kill-new filename)
    (message filename)))

(general-s "S" #'screenshot-svg)
#+end_src

* Computer Local Setup
Load at end so can override configuration.
#+begin_src emacs-lisp
(let ((local-file (expand-file-name "lisp/local.el" user-emacs-directory)))
  (when (file-exists-p local-file)
    (load-file local-file)))
#+end_src

* Removed
- Various org presentation packages (only used once; haven't decided on one)
- hippie expand (just using company now)
- workgoups2, elscreen, etc. (switched to framegroups)
- eval in repl (never used)
- quickrun (never used)
- helm-swoop (switched to swiper)
- ediff (switched to vdiff)
- nlinum (switched to builtin line numbers)
- unfill (never used)
- weather (never used)
- anyblock (switched to targets/things)
- company quickhelp (company-box replaces it; doesn't work well with company childframe)
- vertigo (switched to using counts and relative line numbers)
- golden ratio (switched to zoom)
- multiple cursors and evil-mc (never found a great use case for)
- key chord (old usage was not ideal or saving much effort; input lag causes accidental actions)
- evil-visual-star (I don't use \* that often and a dedicated text object would be preferable to overriding \* in visual state)
- evil-goggles (really cool package but from a practical standpoint I don't need it)
- evil-anzu (using mainly swiper now which supports this functionality)
- shackle (easy enough to do what I want with =display-buffer-alist= directly)
- circe, ERC, and jabber (for now; haven't used IRC or jabber much in a while)
- shell-pop (not really using Emacs terminals at all; may add back with libvterm keybinding)
- jammer and schrute-mode (good idea but found too intrusive/annoying)
- adjust-parens (I updated lispy to have this functionality)
- cleverparens (using lispyville)
- slime (using sly)
- elisp-slime-nav-mode (using xref and helpful)
- historian and company-statistics (replaced with prescient)
- counsel-projectile (just projectile is good enough for my use cases)
